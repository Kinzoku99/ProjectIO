{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TagsFactory = exports.AllTags = exports.NoTags = exports.AbstractTags = exports.TagInfo = exports.Label = void 0;\n\nvar TexParser_js_1 = require(\"./TexParser.js\");\n\nvar Label = function () {\n  function Label(tag, id) {\n    if (tag === void 0) {\n      tag = '???';\n    }\n\n    if (id === void 0) {\n      id = '';\n    }\n\n    this.tag = tag;\n    this.id = id;\n  }\n\n  return Label;\n}();\n\nexports.Label = Label;\n\nvar TagInfo = function () {\n  function TagInfo(env, taggable, defaultTags, tag, tagId, tagFormat, noTag, labelId) {\n    if (env === void 0) {\n      env = '';\n    }\n\n    if (taggable === void 0) {\n      taggable = false;\n    }\n\n    if (defaultTags === void 0) {\n      defaultTags = false;\n    }\n\n    if (tag === void 0) {\n      tag = null;\n    }\n\n    if (tagId === void 0) {\n      tagId = '';\n    }\n\n    if (tagFormat === void 0) {\n      tagFormat = '';\n    }\n\n    if (noTag === void 0) {\n      noTag = false;\n    }\n\n    if (labelId === void 0) {\n      labelId = '';\n    }\n\n    this.env = env;\n    this.taggable = taggable;\n    this.defaultTags = defaultTags;\n    this.tag = tag;\n    this.tagId = tagId;\n    this.tagFormat = tagFormat;\n    this.noTag = noTag;\n    this.labelId = labelId;\n  }\n\n  return TagInfo;\n}();\n\nexports.TagInfo = TagInfo;\n\nvar AbstractTags = function () {\n  function AbstractTags() {\n    this.counter = 0;\n    this.allCounter = 0;\n    this.configuration = null;\n    this.ids = {};\n    this.allIds = {};\n    this.labels = {};\n    this.allLabels = {};\n    this.redo = false;\n    this.refUpdate = false;\n    this.currentTag = new TagInfo();\n    this.history = [];\n    this.stack = [];\n\n    this.enTag = function (node, tag) {\n      var nf = this.configuration.nodeFactory;\n      var cell = nf.create('node', 'mtd', [node]);\n      var row = nf.create('node', 'mlabeledtr', [tag, cell]);\n      var table = nf.create('node', 'mtable', [row], {\n        side: this.configuration.options['tagSide'],\n        minlabelspacing: this.configuration.options['tagIndent'],\n        displaystyle: true\n      });\n      return table;\n    };\n  }\n\n  AbstractTags.prototype.start = function (env, taggable, defaultTags) {\n    if (this.currentTag) {\n      this.stack.push(this.currentTag);\n    }\n\n    this.currentTag = new TagInfo(env, taggable, defaultTags);\n  };\n\n  Object.defineProperty(AbstractTags.prototype, \"env\", {\n    get: function () {\n      return this.currentTag.env;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractTags.prototype.end = function () {\n    this.history.push(this.currentTag);\n    this.currentTag = this.stack.pop();\n  };\n\n  AbstractTags.prototype.tag = function (tag, noFormat) {\n    this.currentTag.tag = tag;\n    this.currentTag.tagFormat = noFormat ? tag : this.formatTag(tag);\n    this.currentTag.noTag = false;\n  };\n\n  AbstractTags.prototype.notag = function () {\n    this.tag('', true);\n    this.currentTag.noTag = true;\n  };\n\n  Object.defineProperty(AbstractTags.prototype, \"noTag\", {\n    get: function () {\n      return this.currentTag.noTag;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractTags.prototype, \"label\", {\n    get: function () {\n      return this.currentTag.labelId;\n    },\n    set: function (label) {\n      this.currentTag.labelId = label;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractTags.prototype.formatUrl = function (id, base) {\n    return base + '#' + encodeURIComponent(id);\n  };\n\n  AbstractTags.prototype.formatTag = function (tag) {\n    return '(' + tag + ')';\n  };\n\n  AbstractTags.prototype.formatId = function (id) {\n    return 'mjx-eqn:' + id.replace(/\\s/g, '_');\n  };\n\n  AbstractTags.prototype.formatNumber = function (n) {\n    return n.toString();\n  };\n\n  AbstractTags.prototype.autoTag = function () {\n    if (this.currentTag.tag == null) {\n      this.counter++;\n      this.tag(this.formatNumber(this.counter), false);\n    }\n  };\n\n  AbstractTags.prototype.clearTag = function () {\n    this.label = '';\n    this.tag(null, true);\n    this.currentTag.tagId = '';\n  };\n\n  AbstractTags.prototype.getTag = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (force) {\n      this.autoTag();\n      return this.makeTag();\n    }\n\n    var ct = this.currentTag;\n\n    if (ct.taggable && !ct.noTag) {\n      if (ct.defaultTags) {\n        this.autoTag();\n      }\n\n      if (ct.tag) {\n        return this.makeTag();\n      }\n    }\n\n    return null;\n  };\n\n  AbstractTags.prototype.resetTag = function () {\n    this.history = [];\n    this.redo = false;\n    this.refUpdate = false;\n    this.clearTag();\n  };\n\n  AbstractTags.prototype.reset = function (offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    this.resetTag();\n    this.counter = this.allCounter = offset;\n    this.allLabels = {};\n    this.allIds = {};\n  };\n\n  AbstractTags.prototype.startEquation = function (math) {\n    this.history = [];\n    this.stack = [];\n    this.clearTag();\n    this.currentTag = new TagInfo('', undefined, undefined);\n    this.labels = {};\n    this.ids = {};\n    this.counter = this.allCounter;\n    this.redo = false;\n    var recompile = math.inputData.recompile;\n\n    if (recompile) {\n      this.refUpdate = true;\n      this.counter = recompile.counter;\n    }\n  };\n\n  AbstractTags.prototype.finishEquation = function (math) {\n    if (this.redo) {\n      math.inputData.recompile = {\n        state: math.state(),\n        counter: this.allCounter\n      };\n    }\n\n    if (!this.refUpdate) {\n      this.allCounter = this.counter;\n    }\n\n    Object.assign(this.allIds, this.ids);\n    Object.assign(this.allLabels, this.labels);\n  };\n\n  AbstractTags.prototype.finalize = function (node, env) {\n    if (!env.display || this.currentTag.env || this.currentTag.tag == null) {\n      return node;\n    }\n\n    var tag = this.makeTag();\n    var table = this.enTag(node, tag);\n    return table;\n  };\n\n  AbstractTags.prototype.makeId = function () {\n    this.currentTag.tagId = this.formatId(this.configuration.options['useLabelIds'] ? this.label || this.currentTag.tag : this.currentTag.tag);\n  };\n\n  AbstractTags.prototype.makeTag = function () {\n    this.makeId();\n\n    if (this.label) {\n      this.labels[this.label] = new Label(this.currentTag.tag, this.currentTag.tagId);\n    }\n\n    var mml = new TexParser_js_1.default('\\\\text{' + this.currentTag.tagFormat + '}', {}, this.configuration).mml();\n    return this.configuration.nodeFactory.create('node', 'mtd', [mml], {\n      id: this.currentTag.tagId\n    });\n  };\n\n  return AbstractTags;\n}();\n\nexports.AbstractTags = AbstractTags;\n\nvar NoTags = function (_super) {\n  __extends(NoTags, _super);\n\n  function NoTags() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  NoTags.prototype.autoTag = function () {};\n\n  NoTags.prototype.getTag = function () {\n    return !this.currentTag.tag ? null : _super.prototype.getTag.call(this);\n  };\n\n  return NoTags;\n}(AbstractTags);\n\nexports.NoTags = NoTags;\n\nvar AllTags = function (_super) {\n  __extends(AllTags, _super);\n\n  function AllTags() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  AllTags.prototype.finalize = function (node, env) {\n    if (!env.display || this.history.find(function (x) {\n      return x.taggable;\n    })) {\n      return node;\n    }\n\n    var tag = this.getTag(true);\n    return this.enTag(node, tag);\n  };\n\n  return AllTags;\n}(AbstractTags);\n\nexports.AllTags = AllTags;\nvar TagsFactory;\n\n(function (TagsFactory) {\n  var tagsMapping = new Map([['none', NoTags], ['all', AllTags]]);\n  var defaultTags = 'none';\n  TagsFactory.OPTIONS = {\n    tags: defaultTags,\n    tagSide: 'right',\n    tagIndent: '0.8em',\n    useLabelIds: true,\n    ignoreDuplicateLabels: false\n  };\n\n  TagsFactory.add = function (name, constr) {\n    tagsMapping.set(name, constr);\n  };\n\n  TagsFactory.addTags = function (tags) {\n    var e_1, _a;\n\n    try {\n      for (var _b = __values(Object.keys(tags)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n        TagsFactory.add(key, tags[key]);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n\n  TagsFactory.create = function (name) {\n    var constr = tagsMapping.get(name) || tagsMapping.get(defaultTags);\n\n    if (!constr) {\n      throw Error('Unknown tags class');\n    }\n\n    return new constr();\n  };\n\n  TagsFactory.setDefault = function (name) {\n    defaultTags = name;\n  };\n\n  TagsFactory.getDefault = function () {\n    return TagsFactory.create(defaultTags);\n  };\n})(TagsFactory = exports.TagsFactory || (exports.TagsFactory = {}));","map":{"version":3,"mappings":"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","names":["tag","id","exports","env","taggable","defaultTags","tagId","tagFormat","noTag","labelId","TagInfo","node","nf","configuration","nodeFactory","cell","create","row","table","side","options","minlabelspacing","displaystyle","AbstractTags","currentTag","stack","push","Object","history","pop","noFormat","formatTag","label","base","encodeURIComponent","replace","n","toString","counter","formatNumber","force","autoTag","makeTag","ct","redo","refUpdate","clearTag","offset","resetTag","allCounter","allLabels","allIds","math","undefined","labels","ids","recompile","inputData","state","assign","display","enTag","formatId","makeId","Label","mml","TexParser_js_1","__extends","NoTags","_super","getTag","call","AllTags","find","x","TagsFactory","tagsMapping","Map","tags","tagSide","tagIndent","useLabelIds","ignoreDuplicateLabels","name","constr","set","keys","_c","key","add","get","Error"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/input/tex/Tags.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Class for generating tags, references, etc.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport TexParser from './TexParser.js';\nimport {MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {MathItem} from '../../core/MathItem.js';\nimport {EnvList} from './StackItem.js';\nimport ParseOptions from './ParseOptions.js';\nimport {OptionList} from '../../util/Options.js';\n\n\n/**\n *  Simple class for label objects.\n */\nexport class Label {\n\n  /**\n   * @constructor\n   * @param {string=} tag The tag that's displayed.\n   * @param {string=} id The id that serves as reference.\n   */\n  constructor(public tag: string = '???', public id: string = '') {}\n}\n\n\n/**\n * A simple class for keeping track of tag information.\n */\nexport class TagInfo {\n\n  /**\n   * @constructor\n   * @param {string} env The environment name (e.g., align).\n   * @param {boolean} taggable Environment supports tags (e.g., align* does, but\n   *     split does not.)\n   * @param {boolean} defaultTags Environment is tagged by default (e.g., align\n   *     is, but align* is not).\n   * @param {string} tag The tag name (e.g., 1).\n   * @param {string} tagId The unique id for that tag (e.g., mjx-eqn:1).\n   * @param {string} tagFormat The formatted tag (e.g., \"(1)\").\n   * @param {boolean} noTag A no tagging command has been set (e.g., \\notag,\n   *     \\nonumber).\n   * @param {string} labelId The label referring to the tag.\n   */\n  constructor(readonly env: string = '',\n              readonly taggable: boolean = false,\n              readonly defaultTags: boolean = false,\n              public tag: string = null,\n              public tagId: string = '',\n              public tagFormat: string = '',\n              public noTag: boolean = false,\n              public labelId: string = '') {}\n\n}\n\n\nexport interface Tags {\n\n  /**\n   * The global configurations in which the parsing takes place.\n   * @type {ParseOptions}\n   */\n  configuration: ParseOptions;\n\n  /**\n   * IDs used in this equation.\n   * @type {Object.<boolean>}\n   */\n  ids: {[key: string]: boolean};\n\n  /**\n   * IDs used in previous equations.\n   * @type {Object.<boolean>}\n   */\n  allIds: {[key: string]: boolean};\n\n  /**\n   * Labels in the current equation.\n   * @type {Object.<Label>}\n   */\n  labels: {[key: string]: Label};\n\n  /**\n   * Labels in previous equations.\n   * @type {Object.<Label>}\n   */\n  allLabels: {[key: string]: Label};\n\n  /**\n   * The label to use for the next tag.\n   * @type {string}\n   */\n  label: string;\n\n  /**\n   * True if the equation contains an undefined label and must be reprocessed later.\n   * @type {boolean}\n   */\n  redo: boolean;\n\n  /**\n   * True when recompiling to update undefined references\n   * @type {boolean}\n   */\n  refUpdate: boolean;\n\n  /**\n   * The environment that is currently tagged.\n   * @type {string}\n   */\n  env: string;\n\n  /**\n   * The currently active tag.\n   * @type {TagInfo}\n   */\n  currentTag: TagInfo;\n\n  /**\n   * How to format tags.\n   * @param {string} tag The tag string.\n   * @return {string} The formatted numbered tag.\n   */\n  formatTag(tag: string): string;\n\n  /**\n   * How to format URLs for references.\n   * @param {string} id The reference id.\n   * @param {string} base The base URL in the reference.\n   * @return {}\n   */\n  formatUrl(id: string, base: string): string;\n\n  /**\n   * Set the tag automatically, by incrementing equation number.\n   */\n  autoTag(): void;\n\n  /**\n   * @return {MmlNode|void} Generates and returns the tag node.\n   */\n  getTag(): MmlNode | void;\n\n  /**\n   * Clears tagging information.\n   */\n  clearTag(): void;\n\n  /**\n   * Resets the tag structure after an expression has been typeset.\n   */\n  resetTag(): void;\n\n  /**\n   * Fully resets the tag structure, in particular all the tagging and label\n   * history.\n   * @param {number} offset A new offset value to start counting ids from.\n   */\n  reset(offset?: number): void;\n\n  /**\n   * Initialise tagging for a MathItem\n   * (clear equation-specific labels and ids, set counter\n   * and check for recompile)\n   * @param {MathItem} math   The MathItem for the current equation\n   */\n    startEquation(math: MathItem<any, any, any>): void;\n\n  /**\n   * Move equation-specific labels and ids to global ones,\n   * save the counter, and mark the MathItem for redos\n   */\n    finishEquation(math: MathItem<any, any, any>): void;\n\n  /**\n   * Finalizes tag creation.\n   * @param {MmlNode} node\n   * @param {EnvList} env List of environment properties.\n   * @return {MmlNode} The newly created tag.\n   */\n  finalize(node: MmlNode, env: EnvList): MmlNode;\n\n  /**\n   * Starts tagging on a given environment.\n   * @param {string} env The name of the environment.\n   * @param {boolean} taggable True if taggable.\n   * @param {boolean} defaultTags True if tagged by default.\n   */\n  start(env: string, taggable: boolean, defaultTags: boolean): void;\n\n  /**\n   * End tagging.\n   */\n  end(): void;\n\n  /**\n   * Computes the next tag.\n   * @param {string} tag The tag content.\n   * @param {boolean} noFormat True if tag should not be formatted.\n   */\n  tag(tag: string, noFormat: boolean): void;\n\n  /**\n   * Call an explicit no tag.\n   */\n  notag(): void;\n\n  /**\n   * Entag an element by creating a table around it.\n   * @param {MmlNode} node The node to be tagged.\n   * @param {MmlNode} tag The tag node.\n   * @return {MmlNode} The table node containing the original node and tag.\n   */\n  enTag(node: MmlNode, tag: MmlNode): MmlNode;\n}\n\n\nexport class AbstractTags implements Tags {\n\n  /**\n   * Current equation number.\n   * @type {number}\n   */\n  protected counter: number = 0;\n\n  /**\n   * Equation number as equation begins.\n   * @type {number}\n   */\n  protected allCounter: number = 0;\n\n  /**\n   * @override\n   */\n  public configuration: ParseOptions = null;\n\n  /**\n   * @override\n   */\n  public ids: {[key: string]: boolean} = {};\n\n  /**\n   * @override\n   */\n  public allIds: {[key: string]: boolean} = {};\n\n  /**\n   * @override\n   */\n  public labels: {[key: string]: Label} = {};\n\n  /**\n   * @override\n   */\n  public allLabels: {[key: string]: Label} = {};\n\n  /**\n   * @override\n   */\n  public redo: boolean = false;\n\n  /**\n   * @override\n   */\n  public refUpdate: boolean = false;\n\n  /**\n   * @override\n   */\n  public currentTag: TagInfo = new TagInfo();\n\n\n  /**\n   * Chronology of all previous tags, in case we need to look something up in\n   * the finalize method.\n   * @type {TagInfo[]}\n   */\n  protected history: TagInfo[] = [];\n\n  private stack: TagInfo[] = [];\n\n  /**\n   * @override\n   */\n  public start(env: string, taggable: boolean, defaultTags: boolean) {\n    if (this.currentTag) {\n      this.stack.push(this.currentTag);\n    }\n    this.currentTag = new TagInfo(env, taggable, defaultTags);\n  }\n\n  public get env() {\n    return this.currentTag.env;\n  }\n\n\n  /**\n   * @override\n   */\n  public end() {\n    this.history.push(this.currentTag);\n    this.currentTag = this.stack.pop();\n  }\n\n\n  /**\n   * @override\n   */\n  public tag(tag: string, noFormat: boolean) {\n    this.currentTag.tag = tag;\n    this.currentTag.tagFormat = noFormat ? tag : this.formatTag(tag);\n    this.currentTag.noTag = false;\n  }\n\n\n  /**\n   * @override\n   */\n  public notag() {\n    this.tag('', true);\n    this.currentTag.noTag = true;\n  }\n\n  protected get noTag(): boolean {\n    return this.currentTag.noTag;\n  }\n\n  public set label(label: string) {\n    this.currentTag.labelId = label;\n  }\n\n  public get label() {\n    return this.currentTag.labelId;\n  }\n\n  /**\n   * @override\n   */\n  public formatUrl(id: string, base: string) {\n    return base + '#' + encodeURIComponent(id);\n  }\n\n  /**\n   * @override\n   */\n  public formatTag(tag: string) {\n    return '(' + tag + ')';\n  }\n\n  /**\n   * How to format ids for labelling equations.\n   * @param {string} id The unique part of the id (e.g., label or number).\n   * @return {string} The formatted id.\n   */\n  protected formatId(id: string): string {\n    return 'mjx-eqn:' + id.replace(/\\s/g, '_');\n  }\n\n  /**\n   * How to format numbers in tags.\n   * @param {number} n The tag number.\n   * @return {string} The formatted number.\n   */\n  protected formatNumber(n: number): string {\n    return n.toString();\n  }\n\n  // Tag handling functions.\n  /**\n   * @override\n   */\n  public autoTag() {\n    if (this.currentTag.tag == null) {\n      this.counter++;\n      this.tag(this.formatNumber(this.counter), false);\n    }\n  }\n\n\n  /**\n   * @override\n   */\n  public clearTag() {\n    this.label = '';\n    this.tag(null, true);\n    this.currentTag.tagId = '';\n  }\n\n\n  /**\n   * @override\n   */\n  public getTag(force: boolean = false) {\n    if (force) {\n      this.autoTag();\n      return this.makeTag();\n    }\n    const ct = this.currentTag;\n    if (ct.taggable && !ct.noTag) {\n      if (ct.defaultTags) {\n        this.autoTag();\n      }\n      if (ct.tag) {\n        return this.makeTag();\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * @override\n   */\n  public resetTag() {\n    this.history = [];\n    this.redo = false;\n    this.refUpdate = false;\n    this.clearTag();\n  }\n\n  /**\n   * @override\n   */\n  public reset(offset: number = 0) {\n    this.resetTag();\n    this.counter = this.allCounter = offset;\n    this.allLabels = {};\n    this.allIds = {};\n  }\n\n  /**\n   * @override\n   */\n  public startEquation(math: MathItem<any, any, any>) {\n    this.history = [];\n    this.stack = [];\n    this.clearTag();\n    this.currentTag = new TagInfo('', undefined, undefined);\n    this.labels = {};\n    this.ids = {};\n    this.counter = this.allCounter;\n    this.redo = false;\n    const recompile = math.inputData.recompile;\n    if (recompile) {\n      this.refUpdate = true;\n      this.counter = recompile.counter;\n    }\n  }\n\n  /**\n   * @override\n   */\n  public finishEquation(math: MathItem<any, any, any>) {\n    if (this.redo) {\n      math.inputData.recompile = {\n        state: math.state(),\n        counter: this.allCounter\n      };\n    }\n    if (!this.refUpdate) {\n      this.allCounter = this.counter;\n    }\n    Object.assign(this.allIds, this.ids);\n    Object.assign(this.allLabels, this.labels);\n  }\n\n  /**\n   * @override\n   */\n  public finalize(node: MmlNode, env: EnvList): MmlNode {\n    if (!env.display || this.currentTag.env ||\n        this.currentTag.tag == null) {\n      return node;\n    }\n    let tag = this.makeTag();\n    let table = this.enTag(node, tag);\n    return table;\n  }\n\n  /**\n   * @override\n   */\n  public enTag = function(node: MmlNode, tag: MmlNode): MmlNode {\n    let nf = this.configuration.nodeFactory;\n    let cell = nf.create('node', 'mtd', [node]);\n    let row = nf.create('node', 'mlabeledtr', [tag, cell]);\n    let table = nf.create('node', 'mtable', [row], {\n      side: this.configuration.options['tagSide'],\n      minlabelspacing: this.configuration.options['tagIndent'],\n      displaystyle: true\n    });\n    return table;\n  };\n\n\n  /**\n   * Sets the tag id.\n   */\n  private makeId() {\n    this.currentTag.tagId = this.formatId(\n      this.configuration.options['useLabelIds'] ?\n        (this.label || this.currentTag.tag) : this.currentTag.tag);\n  }\n\n\n  /**\n   * @return {MmlNode} The actual tag node as an mtd.\n   */\n  private makeTag(): MmlNode {\n    this.makeId();\n    if (this.label) {\n      this.labels[this.label] = new Label(this.currentTag.tag, this.currentTag.tagId);\n    }\n    let mml = new TexParser('\\\\text{' + this.currentTag.tagFormat + '}', {},\n                            this.configuration).mml();\n    return this.configuration.nodeFactory.create('node', 'mtd', [mml],\n                                                 {id: this.currentTag.tagId});\n  }\n\n}\n\n\n/**\n * No tags, except where explicitly set.\n * @constructor\n * @extends {AbstractTags}\n */\nexport class NoTags extends AbstractTags {\n\n  /**\n   * @override\n   */\n  public autoTag() {}\n\n  /**\n   * @override\n   */\n  public getTag() {\n    return !this.currentTag.tag ? null : super.getTag();\n  }\n\n}\n\n\n/**\n * Tags every display formula. Exceptions are: Environments that explicitly\n * disallow tags, e.g., equation*.\n * @constructor\n * @extends {AbstractTags}\n */\nexport class AllTags extends AbstractTags {\n\n  /**\n   * @override\n   */\n  public finalize(node: MmlNode, env: EnvList) {\n    if (!env.display || this.history.find(\n      function(x: TagInfo) { return x.taggable; })) {\n      return node;\n    }\n    let tag = this.getTag(true);\n    return this.enTag(node, tag);\n  }\n\n}\n\n\n/**\n * Class interface for factory.\n * @interface\n */\nexport interface TagsClass {\n  new (): Tags;\n}\n\n\nexport namespace TagsFactory {\n\n  let tagsMapping = new Map<string, TagsClass>([\n    ['none', NoTags],\n    ['all', AllTags]\n  ]);\n\n  let defaultTags = 'none';\n\n  /**\n   * The default options for tagging\n   * @type {OptionList}\n   */\n  export let OPTIONS: OptionList = {\n    // Tagging style, used to be autonumber in v2.\n    tags: defaultTags,\n    // This specifies the side on which \\tag{} macros will place the tags.\n    // Set to 'left' to place on the left-hand side.\n    tagSide: 'right',\n    // This is the amount of indentation (from right or left) for the tags.\n    tagIndent: '0.8em',\n    // make element ID's use \\label name rather than equation number\n    // MJ puts in an equation prefix: mjx-eqn\n    // When true it uses the label name XXX as mjx-eqn:XXX\n    // If false it uses the actual number N that is displayed: mjx-eqn:N\n    useLabelIds: true,\n    // Set to true in order to prevent error messages for duplicate label ids\n    ignoreDuplicateLabels: false\n  };\n\n\n  /**\n   * Add a tagging object.\n   * @param {string} name Name of the tagging object.\n   * @param {TagsClass} constr The class of the Tagging object.\n   */\n  export let add = function(name: string, constr: TagsClass) {\n    tagsMapping.set(name, constr);\n  };\n\n\n  /**\n   * Adds a list of tagging objects to the factory.\n   * @param {{[name: string]: TagsClass}} tags The list of tagging objects.\n   */\n  export let addTags = function(tags: {[name: string]: TagsClass}) {\n    for (const key of Object.keys(tags)) {\n      TagsFactory.add(key, tags[key]);\n    }\n  };\n\n\n  /**\n   * Creates a new tagging object.\n   * @param {string} name The name of the tagging object.\n   * @return {Tags} The newly created object.\n   */\n  export let create = function(name: string): Tags {\n    let constr = tagsMapping.get(name) || tagsMapping.get(defaultTags);\n    if (!constr) {\n        throw Error('Unknown tags class');\n    }\n    return new constr();\n  };\n\n\n  /**\n   * Set the name of the default tagging object.\n   * @param {string} name The default.\n   */\n  export let setDefault = function(name: string) {\n    defaultTags = name;\n  };\n\n\n  /**\n   * @return {Tags} The default tagging object.\n   */\n  export let getDefault = function(): Tags {\n    return TagsFactory.create(defaultTags);\n  };\n\n}\n"]},"metadata":{},"sourceType":"script"}