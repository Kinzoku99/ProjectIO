{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseItem = exports.MmlStack = void 0;\n\nvar TexError_js_1 = require(\"./TexError.js\");\n\nvar MmlStack = function () {\n  function MmlStack(_nodes) {\n    this._nodes = _nodes;\n  }\n\n  Object.defineProperty(MmlStack.prototype, \"nodes\", {\n    get: function () {\n      return this._nodes;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  MmlStack.prototype.Push = function () {\n    var _a;\n\n    var nodes = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      nodes[_i] = arguments[_i];\n    }\n\n    (_a = this._nodes).push.apply(_a, __spreadArray([], __read(nodes)));\n  };\n\n  MmlStack.prototype.Pop = function () {\n    return this._nodes.pop();\n  };\n\n  Object.defineProperty(MmlStack.prototype, \"First\", {\n    get: function () {\n      return this._nodes[this.Size() - 1];\n    },\n    set: function (node) {\n      this._nodes[this.Size() - 1] = node;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MmlStack.prototype, \"Last\", {\n    get: function () {\n      return this._nodes[0];\n    },\n    set: function (node) {\n      this._nodes[0] = node;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  MmlStack.prototype.Peek = function (n) {\n    if (n == null) {\n      n = 1;\n    }\n\n    return this._nodes.slice(this.Size() - n);\n  };\n\n  MmlStack.prototype.Size = function () {\n    return this._nodes.length;\n  };\n\n  MmlStack.prototype.Clear = function () {\n    this._nodes = [];\n  };\n\n  MmlStack.prototype.toMml = function (inferred, forceRow) {\n    if (inferred === void 0) {\n      inferred = true;\n    }\n\n    if (this._nodes.length === 1 && !forceRow) {\n      return this.First;\n    }\n\n    return this.create('node', inferred ? 'inferredMrow' : 'mrow', this._nodes, {});\n  };\n\n  MmlStack.prototype.create = function (kind) {\n    var _a;\n\n    var rest = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n\n    return (_a = this.factory.configuration.nodeFactory).create.apply(_a, __spreadArray([kind], __read(rest)));\n  };\n\n  return MmlStack;\n}();\n\nexports.MmlStack = MmlStack;\n\nvar BaseItem = function (_super) {\n  __extends(BaseItem, _super);\n\n  function BaseItem(factory) {\n    var nodes = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      nodes[_i - 1] = arguments[_i];\n    }\n\n    var _this = _super.call(this, nodes) || this;\n\n    _this.factory = factory;\n    _this.global = {};\n    _this._properties = {};\n\n    if (_this.isOpen) {\n      _this._env = {};\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(BaseItem.prototype, \"kind\", {\n    get: function () {\n      return 'base';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseItem.prototype, \"env\", {\n    get: function () {\n      return this._env;\n    },\n    set: function (value) {\n      this._env = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseItem.prototype, \"copyEnv\", {\n    get: function () {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  BaseItem.prototype.getProperty = function (key) {\n    return this._properties[key];\n  };\n\n  BaseItem.prototype.setProperty = function (key, value) {\n    this._properties[key] = value;\n    return this;\n  };\n\n  Object.defineProperty(BaseItem.prototype, \"isOpen\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseItem.prototype, \"isClose\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseItem.prototype, \"isFinal\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  BaseItem.prototype.isKind = function (kind) {\n    return kind === this.kind;\n  };\n\n  BaseItem.prototype.checkItem = function (item) {\n    if (item.isKind('over') && this.isOpen) {\n      item.setProperty('num', this.toMml(false));\n      this.Clear();\n    }\n\n    if (item.isKind('cell') && this.isOpen) {\n      if (item.getProperty('linebreak')) {\n        return BaseItem.fail;\n      }\n\n      throw new TexError_js_1.default('Misplaced', 'Misplaced %1', item.getName());\n    }\n\n    if (item.isClose && this.getErrors(item.kind)) {\n      var _a = __read(this.getErrors(item.kind), 2),\n          id = _a[0],\n          message = _a[1];\n\n      throw new TexError_js_1.default(id, message, item.getName());\n    }\n\n    if (!item.isFinal) {\n      return BaseItem.success;\n    }\n\n    this.Push(item.First);\n    return BaseItem.fail;\n  };\n\n  BaseItem.prototype.clearEnv = function () {\n    var e_1, _a;\n\n    try {\n      for (var _b = __values(Object.keys(this.env)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var id = _c.value;\n        delete this.env[id];\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n\n  BaseItem.prototype.setProperties = function (def) {\n    Object.assign(this._properties, def);\n    return this;\n  };\n\n  BaseItem.prototype.getName = function () {\n    return this.getProperty('name');\n  };\n\n  BaseItem.prototype.toString = function () {\n    return this.kind + '[' + this.nodes.join('; ') + ']';\n  };\n\n  BaseItem.prototype.getErrors = function (kind) {\n    var CLASS = this.constructor;\n    return (CLASS.errors || {})[kind] || BaseItem.errors[kind];\n  };\n\n  BaseItem.fail = [null, false];\n  BaseItem.success = [null, true];\n  BaseItem.errors = {\n    end: ['MissingBeginExtraEnd', 'Missing \\\\begin{%1} or extra \\\\end{%1}'],\n    close: ['ExtraCloseMissingOpen', 'Extra close brace or missing open brace'],\n    right: ['MissingLeftExtraRight', 'Missing \\\\left or extra \\\\right'],\n    middle: ['ExtraMiddle', 'Extra \\\\middle']\n  };\n  return BaseItem;\n}(MmlStack);\n\nexports.BaseItem = BaseItem;","map":{"version":3,"mappings":"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","names":["_nodes","Object","MmlStack","nodes","push","apply","_a","__spreadArray","pop","Size","node","n","slice","length","inferred","forceRow","First","create","kind","rest","factory","configuration","nodeFactory","__read","exports","__extends","_super","_this","isOpen","_env","BaseItem","value","key","_properties","item","isKind","setProperty","toMml","Clear","getProperty","fail","TexError_js_1","getName","isClose","getErrors","id","message","isFinal","success","Push","keys","env","_c","def","assign","join","CLASS","constructor","errors","end","close","right","middle"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/input/tex/StackItem.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2009-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Stack items hold information on the TexParser stack.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {FactoryNodeClass} from '../../core/Tree/Factory.js';\nimport TexError from './TexError.js';\nimport StackItemFactory from './StackItemFactory.js';\n\n// Union types for abbreviation.\nexport type EnvProp = string | number | boolean;\n\nexport type EnvList = {[key: string]: EnvProp};\n\n// This is the type for all fields that used to be set with With.\nexport type Prop = string | number | boolean | MmlNode | PropList;\n\nexport type PropList = {[key: string]: Prop};\n\nexport type CheckType = [(MmlNode | StackItem)[], boolean];\n\n\nexport interface NodeStack {\n\n  /**\n   * Get or set the topmost element on the node stack without removing it.\n   * @return {MmlNode} The topmost node on the stack.\n   */\n  First: MmlNode;\n\n  /**\n   * Get or set the last element on the node stack without removing it.\n   * @return {MmlNode} The last node on the stack.\n   */\n  Last: MmlNode;\n\n  /**\n   * @return {MmlNode} The topmost node on the item's node stack.\n   */\n  Pop(): MmlNode | void;\n\n  /**\n   * Pushes new nodes onto the items node stack.\n   * @param {MmlNode[]} ...nodes A list of nodes.\n   */\n  Push(...nodes: MmlNode[]): void;\n\n  /**\n   * Get the top n elements on the node stack without removing them.\n   * @param {number=} n Number of elements that should be returned.\n   * @return {MmlNode[]} List of nodes on top of stack.\n   */\n  Peek(n?: number): MmlNode[];\n\n  /**\n   * @return {number} The size of the stack.\n   */\n  Size(): number;\n\n  /**\n   * Clears the stack.\n   */\n  Clear(): void;\n\n  /**\n   * Returns nodes on the stack item's node stack as an Mml node. I.e., in case\n   * the item contains more than one node, it creates an mrow.\n   * @param {boolean=} inferred If set the mrow will be an inferred mrow.\n   * @param {boolean=} forceRow If set an mrow will be created, regardless of\n   *     how many nodes the item contains.\n   * @return {MmlNode} The topmost Mml node.\n   */\n  toMml(inferred?: boolean, forceRow?: boolean): MmlNode;\n\n}\n\n\nexport abstract class MmlStack implements NodeStack {\n\n  /**\n   * @constructor\n   * @extends {NodeStack}\n   * @param {MmlNode[]} nodes An initial list of nodes to put on the stack.\n   */\n  constructor(private _nodes: MmlNode[]) { }\n\n  /**\n   * @return {MmlNode[]} The nodes on the stack.\n   */\n  protected get nodes(): MmlNode[] {\n    return this._nodes;\n  }\n\n  /**\n   * @override\n   */\n  public Push(...nodes: MmlNode[]) {\n    this._nodes.push(...nodes);\n  }\n\n\n  /**\n   * @override\n   */\n  public Pop(): MmlNode {\n    return this._nodes.pop();\n  }\n\n\n  /**\n   * @override\n   */\n  public get First(): MmlNode {\n    return this._nodes[this.Size() - 1];\n  }\n\n\n  /**\n   * @override\n   */\n  public set First(node: MmlNode) {\n    this._nodes[this.Size() - 1] = node;\n  }\n\n\n  /**\n   * @override\n   */\n  public get Last(): MmlNode {\n    return this._nodes[0];\n  }\n\n\n  /**\n   * @override\n   */\n  public set Last(node: MmlNode) {\n    this._nodes[0] = node;\n  }\n\n\n  /**\n   * @override\n   */\n  public Peek(n?: number): MmlNode[] {\n    if (n == null) {\n      n = 1;\n    }\n    return this._nodes.slice(this.Size() - n);\n  }\n\n\n  /**\n   * @override\n   */\n  public Size(): number {\n    return this._nodes.length;\n  }\n\n\n  /**\n   * @override\n   */\n  public Clear(): void {\n    this._nodes = [];\n  }\n\n\n  protected abstract get factory(): StackItemFactory;\n\n  /**\n   * @override\n   */\n  public toMml(inferred: boolean = true, forceRow?: boolean) {\n    if (this._nodes.length === 1 && !forceRow) {\n      return this.First;\n    }\n    // @test Two Identifiers\n    return this.create(\n      'node', inferred ? 'inferredMrow' : 'mrow', this._nodes, {});\n  }\n\n\n  /**\n   * Convenience method to create nodes with the node factory on this stack.\n   * @param {string} kind The kind of node to create.\n   * @param {any[]} ...rest The remaining arguments for the creation method.\n   * @return {MmlNode} The newly created node.\n   */\n  public create(kind: string, ...rest: any[]): MmlNode {\n    return this.factory.configuration.nodeFactory.create(kind, ...rest);\n  }\n\n}\n\nexport interface StackItem extends NodeStack {\n\n\n  /**\n   * Type of stack item.\n   * @type {string}\n   */\n  kind: string;\n\n  /**\n   * Is this a closing item, e.g., end.\n   * @type {boolean}\n   */\n  isClose: boolean;\n\n  /**\n   * Is this an opening item, e.g., begin.\n   * @type {boolean}\n   */\n  isOpen: boolean;\n\n  /**\n   * Is this a finalising item, i.e., one that only collects nodes.\n   * @type {boolean}\n   */\n  isFinal: boolean;\n\n  /**\n   * Global properties of the parser.\n   * @type {EnvList}\n   */\n   global: EnvList;\n\n  /**\n   * Local properties of the stack item.\n   * @type {EnvList}\n   */\n   env: EnvList;\n\n  /**\n   * Copy local properties when pushed to stack?\n   * @type {boolean}\n   */\n   copyEnv: boolean;\n\n  /**\n   * Tests if item is of the given type.\n   * @param {string} kind The type.\n   * @return {boolean} True if item is of that type.\n   */\n  isKind(kind: string): boolean;\n\n  /**\n   * Get a property of the item.\n   * @param {string} key Property name.\n   * @return {Prop} Property value if it exists.\n   */\n  getProperty(key: string): Prop;\n\n  /**\n   * Set a property.\n   * @param {string} key Property name.\n   * @param {Prop} value Property value.\n   * @return {StackItem} The item for pipelining.\n   */\n  setProperty(key: string, value: Prop): StackItem;\n\n  /**\n   * Sets a list of properties.\n   * @param {PropList} def The properties to set.\n   * @return {StackItem} Returns the stack item object for pipelining.\n   */\n  setProperties(def: PropList): StackItem;\n\n  /**\n   * Convenience method for returning the string property \"name\".\n   * @return {string} The value for the name property.\n   */\n  getName(): string;\n\n  /**\n   * TeX parsing in MathJax is essentially implemented via a nested stack\n   * automaton. That is the tex parser works on a stack, and each item on the\n   * stack can have a data stack of its own. Data on the stack is either a stack\n   * item or a node.\n   *\n   * The checkItem method effectively implements the recursive checking of\n   * input data from the parser against data recursively given on the stack.\n   *\n   * I.e., new input is parsed resulting in a new item. When pushed on the stack\n   * it is checked against the top most item on the stack. This either leads to\n   * the item being pushed onto the stack or combined with the top most\n   * element(s), pushing a new item, which is recursively checked, unless an\n   * error is thrown.\n   *\n   * A simple example: If \\\\end{foo} is parsed, an endItem is created, pushed on\n   * the stack. Nodes on the stack are collapsed into content of the 'foo'\n   * environment, until a beginItem for 'foo' is found.  If a beginItem is not\n   * for 'foo' or does not exist an error is thrown.\n   *\n   * @param {StackItem} item The pushed item.\n   * @return {CheckType} True/false or an item or node.\n   */\n  checkItem(item: StackItem): CheckType;\n\n}\n\nexport interface StackItemClass extends FactoryNodeClass<StackItem> {\n  // new (factory: StackItemFactory, ...args: any[]): StackItem;\n}\n\n\n/**\n * Abstract basic item class that implements most of the stack item\n * functionality. In particular, it contains the base method for checkItem.\n */\nexport abstract class BaseItem extends MmlStack implements StackItem {\n\n  /**\n   * The fail value.\n   * @type {CheckType}\n   */\n  protected static fail: CheckType = [null, false];\n\n  /**\n   * The success value.\n   * @type {CheckType}\n   */\n  protected static success: CheckType = [null, true];\n\n  /**\n   * A list of basic errors.\n   * @type {{[key: string]: string[]}}\n   */\n  protected static errors: {[key: string]: string[]} = {\n    // @test ExtraOpenMissingClose\n    end: ['MissingBeginExtraEnd', 'Missing \\\\begin{%1} or extra \\\\end{%1}'],\n    // @test ExtraCloseMissingOpen\n    close: ['ExtraCloseMissingOpen', 'Extra close brace or missing open brace'],\n    // @test MissingLeftExtraRight\n    right: ['MissingLeftExtraRight', 'Missing \\\\left or extra \\\\right'],\n    middle: ['ExtraMiddle', 'Extra \\\\middle']\n  };\n\n\n  /**\n   * @override\n   */\n  public global: EnvList = {};\n\n  private _env: EnvList;\n\n  private _properties: PropList = {};\n\n\n  /**\n   * @constructor\n   * @extends {MmlStack}\n   */\n  constructor(protected factory: StackItemFactory, ...nodes: MmlNode[]) {\n    super(nodes);\n    if (this.isOpen) {\n      this._env = {};\n    }\n  }\n\n  /**\n   * @return {string} The type of the stack item.\n   */\n    public get kind(): string {\n    return 'base';\n  }\n\n  /**\n   * @return {EnvList} Get the private environment\n   */\n  public get env(): EnvList {\n    return this._env;\n  }\n\n  /**\n   * Set the private environment\n   * @param {EnvList} value New private environemt.\n   */\n  public set env(value: EnvList) {\n    this._env = value;\n  }\n\n  /**\n   * Default is to copy local environment when pushed on stack\n   */\n  public get copyEnv() {\n    return true;\n  }\n\n  /**\n   * @override\n   */\n  public getProperty(key: string): Prop {\n    return this._properties[key];\n  }\n\n  /**\n   * @override\n   */\n  public setProperty(key: string, value: Prop) {\n    this._properties[key] = value;\n    return this;\n  }\n\n\n  /**\n   * @return {boolean} True if item is an opening entity, i.e., it expects a\n   *     closing counterpart on the stack later.\n   */\n  get isOpen(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean} True if item is an closing entity, i.e., it needs an\n   *     opening counterpart already on the stack.\n   */\n  get isClose(): boolean {\n    return false;\n  }\n\n\n  /**\n   * @return {boolean} True if item is final, i.e., it contains one or multiple\n   *      finished parsed nodes.\n   */\n  get isFinal(): boolean {\n    return false;\n  }\n\n\n  /**\n   * @override\n   */\n  public isKind(kind: string) {\n    return kind === this.kind;\n  }\n\n\n  /**\n   * @override\n   */\n  public checkItem(item: StackItem): CheckType {\n    if (item.isKind('over') && this.isOpen) {\n      item.setProperty('num', this.toMml(false));\n      this.Clear();\n    }\n    if (item.isKind('cell') && this.isOpen) {\n      if (item.getProperty('linebreak')) {\n        return BaseItem.fail;\n      }\n      // @test Ampersand-error\n      throw new TexError('Misplaced', 'Misplaced %1', item.getName());\n    }\n    if (item.isClose && this.getErrors(item.kind)) {\n      // @test ExtraOpenMissingClose, ExtraCloseMissingOpen,\n      //       MissingLeftExtraRight, MissingBeginExtraEnd\n      const [id, message] = this.getErrors(item.kind);\n      throw new TexError(id, message, item.getName());\n    }\n    if (!item.isFinal) {\n      return BaseItem.success;\n    }\n    this.Push(item.First);\n    return BaseItem.fail;\n  }\n\n\n  /**\n   * Clears the item's environment.\n   */\n  public clearEnv() {\n    for (const id of Object.keys(this.env)) {\n      delete this.env[id];\n    }\n  }\n\n\n  /**\n   * @override\n   */\n  public setProperties(def: PropList) {\n    Object.assign(this._properties, def);\n    return this;\n  }\n\n\n  /**\n   * @override\n   */\n  public getName() {\n    return this.getProperty('name') as string;\n  }\n\n\n  /**\n   * @override\n   */\n  public toString() {\n    return this.kind + '[' + this.nodes.join('; ') + ']';\n  }\n\n\n  /**\n   * Get error messages for a particular types of stack items. This reads error\n   * messages from the static errors object, which can be extended in\n   * subclasses.\n   * @param {string} kind The stack item type.\n   * @return {string[]} The list of arguments for the TeXError.\n   */\n  public getErrors(kind: string): string[] {\n    const CLASS = (this.constructor as typeof BaseItem);\n    return (CLASS.errors || {})[kind] || BaseItem.errors[kind];\n  }\n\n}\n"]},"metadata":{},"sourceType":"script"}