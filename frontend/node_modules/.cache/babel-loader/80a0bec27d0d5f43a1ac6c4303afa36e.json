{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.newState = exports.STATE = exports.AbstractMathItem = exports.protoItem = void 0;\n\nfunction protoItem(open, math, close, n, start, end, display) {\n  if (display === void 0) {\n    display = null;\n  }\n\n  var item = {\n    open: open,\n    math: math,\n    close: close,\n    n: n,\n    start: {\n      n: start\n    },\n    end: {\n      n: end\n    },\n    display: display\n  };\n  return item;\n}\n\nexports.protoItem = protoItem;\n\nvar AbstractMathItem = function () {\n  function AbstractMathItem(math, jax, display, start, end) {\n    if (display === void 0) {\n      display = true;\n    }\n\n    if (start === void 0) {\n      start = {\n        i: 0,\n        n: 0,\n        delim: ''\n      };\n    }\n\n    if (end === void 0) {\n      end = {\n        i: 0,\n        n: 0,\n        delim: ''\n      };\n    }\n\n    this.root = null;\n    this.typesetRoot = null;\n    this.metrics = {};\n    this.inputData = {};\n    this.outputData = {};\n    this._state = exports.STATE.UNPROCESSED;\n    this.math = math;\n    this.inputJax = jax;\n    this.display = display;\n    this.start = start;\n    this.end = end;\n    this.root = null;\n    this.typesetRoot = null;\n    this.metrics = {};\n    this.inputData = {};\n    this.outputData = {};\n  }\n\n  Object.defineProperty(AbstractMathItem.prototype, \"isEscaped\", {\n    get: function () {\n      return this.display === null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractMathItem.prototype.render = function (document) {\n    document.renderActions.renderMath(this, document);\n  };\n\n  AbstractMathItem.prototype.rerender = function (document, start) {\n    if (start === void 0) {\n      start = exports.STATE.RERENDER;\n    }\n\n    if (this.state() >= start) {\n      this.state(start - 1);\n    }\n\n    document.renderActions.renderMath(this, document, start);\n  };\n\n  AbstractMathItem.prototype.convert = function (document, end) {\n    if (end === void 0) {\n      end = exports.STATE.LAST;\n    }\n\n    document.renderActions.renderConvert(this, document, end);\n  };\n\n  AbstractMathItem.prototype.compile = function (document) {\n    if (this.state() < exports.STATE.COMPILED) {\n      this.root = this.inputJax.compile(this, document);\n      this.state(exports.STATE.COMPILED);\n    }\n  };\n\n  AbstractMathItem.prototype.typeset = function (document) {\n    if (this.state() < exports.STATE.TYPESET) {\n      this.typesetRoot = document.outputJax[this.isEscaped ? 'escaped' : 'typeset'](this, document);\n      this.state(exports.STATE.TYPESET);\n    }\n  };\n\n  AbstractMathItem.prototype.updateDocument = function (_document) {};\n\n  AbstractMathItem.prototype.removeFromDocument = function (_restore) {\n    if (_restore === void 0) {\n      _restore = false;\n    }\n  };\n\n  AbstractMathItem.prototype.setMetrics = function (em, ex, cwidth, lwidth, scale) {\n    this.metrics = {\n      em: em,\n      ex: ex,\n      containerWidth: cwidth,\n      lineWidth: lwidth,\n      scale: scale\n    };\n  };\n\n  AbstractMathItem.prototype.state = function (state, restore) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    if (restore === void 0) {\n      restore = false;\n    }\n\n    if (state != null) {\n      if (state < exports.STATE.INSERTED && this._state >= exports.STATE.INSERTED) {\n        this.removeFromDocument(restore);\n      }\n\n      if (state < exports.STATE.TYPESET && this._state >= exports.STATE.TYPESET) {\n        this.outputData = {};\n      }\n\n      if (state < exports.STATE.COMPILED && this._state >= exports.STATE.COMPILED) {\n        this.inputData = {};\n      }\n\n      this._state = state;\n    }\n\n    return this._state;\n  };\n\n  AbstractMathItem.prototype.reset = function (restore) {\n    if (restore === void 0) {\n      restore = false;\n    }\n\n    this.state(exports.STATE.UNPROCESSED, restore);\n  };\n\n  return AbstractMathItem;\n}();\n\nexports.AbstractMathItem = AbstractMathItem;\nexports.STATE = {\n  UNPROCESSED: 0,\n  FINDMATH: 10,\n  COMPILED: 20,\n  CONVERT: 100,\n  METRICS: 110,\n  RERENDER: 125,\n  TYPESET: 150,\n  INSERTED: 200,\n  LAST: 10000\n};\n\nfunction newState(name, state) {\n  if (name in exports.STATE) {\n    throw Error('State ' + name + ' already exists');\n  }\n\n  exports.STATE[name] = state;\n}\n\nexports.newState = newState;","map":{"version":3,"mappings":"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","names":["protoItem","open","math","close","n","start","end","display","item","exports","jax","i","delim","UNPROCESSED","inputJax","root","typesetRoot","metrics","inputData","outputData","Object","AbstractMathItem","document","renderActions","renderMath","RERENDER","state","LAST","renderConvert","COMPILED","compile","TYPESET","outputJax","isEscaped","_document","_restore","em","ex","cwidth","lwidth","scale","containerWidth","lineWidth","restore","INSERTED","_state","removeFromDocument","FINDMATH","CONVERT","METRICS","newState","name","Error"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/core/MathItem.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the interface and abstract class for MathItem objects\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {MathDocument} from './MathDocument.js';\nimport {InputJax} from './InputJax.js';\nimport {OptionList} from '../util/Options.js';\nimport {MmlNode} from './MmlTree/MmlNode.js';\n\n/*****************************************************************/\n/**\n *  The Location gives a location of a position in a document\n *  (either a node and character position within it, or\n *  an index into a string array, the character position within\n *  the string, and the delimiter at that location).\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n */\nexport type Location<N, T> = {\n  i?: number;\n  n?: number;\n  delim?: string;\n  node?: N | T;\n};\n\n/*****************************************************************/\n/**\n *  The Metrics object includes the data needed to typeset\n *  a MathItem.\n */\nexport type Metrics = {\n  em: number;\n  ex: number;\n  containerWidth: number;\n  lineWidth: number;\n  scale: number;\n};\n\n/*****************************************************************/\n/**\n *  The MathItem interface\n *\n *  The MathItem is the object that holds the information about a\n *  particular expression on the page, including pointers to\n *  where it is in the document, its compiled version (in the\n *  internal format), its typeset version, its bounding box,\n *  and so on.\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport interface MathItem<N, T, D> {\n  /**\n   * The string representing the expression to be processed\n   */\n  math: string;\n\n  /**\n   * The input jax used to process the math\n   */\n  inputJax: InputJax<N, T, D>;\n\n  /**\n   * Whether the math is in display mode or inline mode\n   */\n  display: boolean;\n\n  /**\n   * Whether this item is an escaped character or not\n   */\n  isEscaped: boolean;\n\n  /**\n   * The start and ending locations in the document of\n   *   this expression\n   */\n  start: Location<N, T>;\n  end: Location<N, T>;\n\n  /**\n   * The internal format for this expression (once compiled)\n   */\n  root: MmlNode;\n\n  /**\n   * The typeset version of the expression (once typeset)\n   */\n  typesetRoot: N;\n\n  /**\n   * The metric information at the location of the math\n   * (the em-size, scaling factor, etc.)\n   */\n  metrics: Metrics;\n\n  /**\n   * Extra data needed by the input or output jax, as needed\n   */\n  inputData: OptionList;\n  outputData: OptionList;\n\n  /**\n   * Perform the renderActions on the document\n   *\n   * @param {MathDocument} document  The MathDocument in which the math resides\n   */\n  render(document: MathDocument<N, T, D>): void;\n\n  /**\n   * Rerenders an already rendered item and inserts it into the document\n   *\n   * @param {MathDocument} document  The MathDocument in which the math resides\n   * @param {number=} start          The state to start rerendering at (default = RERENDER)\n   */\n  rerender(document: MathDocument<N, T, D>, start?: number): void;\n\n  /**\n   * Converts the expression by calling the render actions until the state matches the end state\n   *\n   * @param {MathDocument} document  The MathDocument in which the math resides\n   * @param {number=} end            The state to end rerendering at (default = LAST)\n   */\n  convert(document: MathDocument<N, T, D>, end?: number): void;\n\n  /**\n   * Converts the expression into the internal format by calling the input jax\n   *\n   * @param {MathDocument} document  The MathDocument in which the math resides\n   */\n  compile(document: MathDocument<N, T, D>): void;\n\n  /**\n   * Converts the internal format to the typeset version by calling the output jax\n   *\n   * @param {MathDocument} document  The MathDocument in which the math resides\n   */\n  typeset(document: MathDocument<N, T, D>): void;\n\n  /**\n   * Inserts the typeset version in place of the original form in the document\n   *\n   * @param {MathDocument} document  The MathDocument in which the math resides\n   */\n  updateDocument(document: MathDocument<N, T, D>): void;\n\n  /**\n   * Removes the typeset version from the document, optionally replacing the original\n   * form of the expression and its delimiters.\n   *\n   * @param {boolean} restore  True if the original version is to be restored\n   */\n  removeFromDocument(restore: boolean): void;\n\n  /**\n   * Sets the metric information for this expression\n   *\n   * @param {number} em      The size of 1 em in pixels\n   * @param {number} ex      The size of 1 ex in pixels\n   * @param {number} cwidth  The container width in pixels\n   * @param {number} lwidth  The line breaking width in pixels\n   * @param {number} scale   The scaling factor (unitless)\n   */\n  setMetrics(em: number, ex: number, cwidth: number, lwidth: number, scale: number): void;\n\n  /**\n   * Set or return the current processing state of this expression,\n   * optionally restoring the document if rolling back an expression\n   * that has been added to the document.\n   *\n   * @param {number} state    The state to set for the expression\n   * @param {number} restore  True if the original form should be restored\n   *                           to the document when rolling back a typeset version\n   * @returns {number}        The current state\n   */\n  state(state?: number, restore?: boolean): number;\n\n  /**\n   * Reset the item to its unprocessed state\n   *\n   * @param {number} restore  True if the original form should be restored\n   *                           to the document when rolling back a typeset version\n   */\n  reset(restore?: boolean): void;\n}\n\n/*****************************************************************/\n/**\n *  The ProtoItem interface\n *\n *  This is what is returned by the FindMath class, giving the location\n *  of math within the document, and is used to produce the full\n *  MathItem later (e.g., when the position within a string array\n *  is translated back into the actual node location in the DOM).\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n */\nexport type ProtoItem<N, T> = {\n  math: string;            // The math expression itself\n  start: Location<N, T>;   // The starting location of the math\n  end: Location<N, T>;     // The ending location of the math\n  open?: string;           // The opening delimiter\n  close?: string;          // The closing delimiter\n  n?: number;              // The index of the string in which this math is found\n  display: boolean;        // True means display mode, false is inline mode\n};\n\n/**\n *  Produce a proto math item that can be turned into a MathItem\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n */\nexport function protoItem<N, T>(open: string, math: string, close: string, n: number,\n                                start: number, end: number, display: boolean = null) {\n  let item: ProtoItem<N, T> = {open: open, math: math, close: close,\n                               n: n, start: {n: start}, end: {n: end}, display: display};\n  return item;\n}\n\n/*****************************************************************/\n/**\n *  Implements the MathItem class\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport abstract class AbstractMathItem<N, T, D> implements MathItem<N, T, D> {\n\n  /**\n   * The source text for the math (e.g., TeX string)\n   */\n  public math: string;\n\n  /**\n   * The input jax associated with this item\n   */\n\n  public inputJax: InputJax<N, T, D>;\n\n  /**\n   * True when this math is in display mode\n   */\n  public display: boolean;\n\n  /**\n   * Reference to the beginning of the math in the document\n   */\n  public start: Location<N, T>;\n  /**\n   * Reference to the end of the math in the document\n   */\n  public end: Location<N, T>;\n\n  /**\n   * The compiled internal MathML (result of InputJax)\n   */\n  public root: MmlNode = null;\n  /**\n   * The typeset result (result of OutputJax)\n   */\n  public typesetRoot: N = null;\n\n  /**\n   * The metric information about the surrounding environment\n   */\n  public metrics: Metrics = {} as Metrics;\n\n  /**\n   * Data private to the input jax\n   */\n  public inputData: OptionList = {};\n\n  /**\n   * Data private to the output jax\n   */\n  public outputData: OptionList = {};\n\n  /**\n   * The current state of the item (how far in the render actions it has been processed)\n   */\n  protected _state: number = STATE.UNPROCESSED;\n\n  /**\n   * @return {boolean}   True when this item is an escaped delimiter\n   */\n  public get isEscaped(): boolean {\n    return this.display === null;\n  }\n\n  /**\n   * @param {string} math      The math expression for this item\n   * @param {Inputjax} jax     The input jax to use for this item\n   * @param {boolean} display  True if display mode, false if inline\n   * @param {Location} start   The starting position of the math in the document\n   * @param {Location} end     The ending position of the math in the document\n   * @constructor\n   */\n  constructor (math: string, jax: InputJax<N, T, D>, display: boolean = true,\n               start: Location<N, T> = {i: 0, n: 0, delim: ''},\n               end: Location<N, T> = {i: 0, n: 0, delim: ''}) {\n    this.math = math;\n    this.inputJax = jax;\n    this.display = display;\n    this.start = start;\n    this.end = end;\n    this.root = null;\n    this.typesetRoot = null;\n    this.metrics = {} as Metrics;\n    this.inputData = {};\n    this.outputData = {};\n  }\n\n  /**\n   * @override\n   */\n  public render(document: MathDocument<N, T, D>) {\n    document.renderActions.renderMath(this, document);\n  }\n\n  /**\n   * @override\n   */\n  public rerender(document: MathDocument<N, T, D>, start: number = STATE.RERENDER) {\n    if (this.state() >= start) {\n      this.state(start - 1);\n    }\n    document.renderActions.renderMath(this, document, start);\n  }\n\n  /**\n   * @override\n   */\n  public convert(document: MathDocument<N, T, D>, end: number = STATE.LAST) {\n    document.renderActions.renderConvert(this, document, end);\n  }\n\n  /**\n   * @override\n   */\n  public compile(document: MathDocument<N, T, D>) {\n    if (this.state() < STATE.COMPILED) {\n      this.root = this.inputJax.compile(this, document);\n      this.state(STATE.COMPILED);\n    }\n  }\n\n  /**\n   * @override\n   */\n  public typeset(document: MathDocument<N, T, D>) {\n    if (this.state() < STATE.TYPESET) {\n      this.typesetRoot = document.outputJax[this.isEscaped ? 'escaped' : 'typeset'](this, document);\n      this.state(STATE.TYPESET);\n    }\n  }\n\n  /**\n   * @override\n   */\n  public updateDocument(_document: MathDocument<N, T, D>) {}\n\n  /**\n   * @override\n   */\n  public removeFromDocument(_restore: boolean = false) {}\n\n  /**\n   * @override\n   */\n  public setMetrics(em: number, ex: number, cwidth: number, lwidth: number, scale: number) {\n    this.metrics = {\n      em: em, ex: ex,\n      containerWidth: cwidth,\n      lineWidth: lwidth,\n      scale: scale\n    };\n  }\n\n  /**\n   * @override\n   */\n  public state(state: number = null, restore: boolean = false) {\n    if (state != null) {\n      if (state < STATE.INSERTED && this._state >= STATE.INSERTED) {\n        this.removeFromDocument(restore);\n      }\n      if (state < STATE.TYPESET && this._state >= STATE.TYPESET) {\n        this.outputData = {};\n      }\n      if (state < STATE.COMPILED && this._state >= STATE.COMPILED) {\n        this.inputData = {};\n      }\n      this._state = state;\n    }\n    return this._state;\n  }\n\n  /**\n   * @override\n   */\n  public reset(restore: boolean = false) {\n    this.state(STATE.UNPROCESSED, restore);\n  }\n\n}\n\n/*****************************************************************/\n/**\n * The various states that a MathItem (or MathDocument) can be in\n *   (open-ended so that extensions can add to it)\n */\nexport const STATE: {[state: string]: number} = {\n  UNPROCESSED: 0,\n  FINDMATH: 10,\n  COMPILED: 20,\n  CONVERT: 100,\n  METRICS: 110,\n  RERENDER: 125,\n  TYPESET: 150,\n  INSERTED: 200,\n  LAST: 10000\n};\n\n/**\n * Allocate a new named state\n *\n * @param {string} name    The name of the new state\n * @param {number} state   The value for the new state\n */\nexport function newState(name: string, state: number) {\n  if (name in STATE) {\n    throw Error('State ' + name + ' already exists');\n  }\n  STATE[name] = state;\n}\n"]},"metadata":{},"sourceType":"script"}