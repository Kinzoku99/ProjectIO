{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar StackItemFactory_js_1 = require(\"./StackItemFactory.js\");\n\nvar NodeFactory_js_1 = require(\"./NodeFactory.js\");\n\nvar NodeUtil_js_1 = require(\"./NodeUtil.js\");\n\nvar Options_js_1 = require(\"../../util/Options.js\");\n\nvar ParseOptions = function () {\n  function ParseOptions(configuration, options) {\n    if (options === void 0) {\n      options = [];\n    }\n\n    this.options = {};\n    this.packageData = new Map();\n    this.parsers = [];\n    this.root = null;\n    this.nodeLists = {};\n    this.error = false;\n    this.handlers = configuration.handlers;\n    this.nodeFactory = new NodeFactory_js_1.NodeFactory();\n    this.nodeFactory.configuration = this;\n    this.nodeFactory.setCreators(configuration.nodes);\n    this.itemFactory = new StackItemFactory_js_1.default(configuration.items);\n    this.itemFactory.configuration = this;\n    Options_js_1.defaultOptions.apply(void 0, __spreadArray([this.options], __read(options)));\n    Options_js_1.defaultOptions(this.options, configuration.options);\n  }\n\n  ParseOptions.prototype.pushParser = function (parser) {\n    this.parsers.unshift(parser);\n  };\n\n  ParseOptions.prototype.popParser = function () {\n    this.parsers.shift();\n  };\n\n  Object.defineProperty(ParseOptions.prototype, \"parser\", {\n    get: function () {\n      return this.parsers[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ParseOptions.prototype.clear = function () {\n    this.parsers = [];\n    this.root = null;\n    this.nodeLists = {};\n    this.error = false;\n    this.tags.resetTag();\n  };\n\n  ParseOptions.prototype.addNode = function (property, node) {\n    var list = this.nodeLists[property];\n\n    if (!list) {\n      list = this.nodeLists[property] = [];\n    }\n\n    list.push(node);\n\n    if (node.kind !== property) {\n      var inlists = NodeUtil_js_1.default.getProperty(node, 'in-lists') || '';\n      var lists = (inlists ? inlists.split(/,/) : []).concat(property).join(',');\n      NodeUtil_js_1.default.setProperty(node, 'in-lists', lists);\n    }\n  };\n\n  ParseOptions.prototype.getList = function (property) {\n    var e_1, _a;\n\n    var list = this.nodeLists[property] || [];\n    var result = [];\n\n    try {\n      for (var list_1 = __values(list), list_1_1 = list_1.next(); !list_1_1.done; list_1_1 = list_1.next()) {\n        var node = list_1_1.value;\n\n        if (this.inTree(node)) {\n          result.push(node);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (list_1_1 && !list_1_1.done && (_a = list_1.return)) _a.call(list_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    this.nodeLists[property] = result;\n    return result;\n  };\n\n  ParseOptions.prototype.removeFromList = function (property, nodes) {\n    var e_2, _a;\n\n    var list = this.nodeLists[property] || [];\n\n    try {\n      for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {\n        var node = nodes_1_1.value;\n        var i = list.indexOf(node);\n\n        if (i >= 0) {\n          list.splice(i, 1);\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  };\n\n  ParseOptions.prototype.inTree = function (node) {\n    while (node && node !== this.root) {\n      node = node.parent;\n    }\n\n    return !!node;\n  };\n\n  return ParseOptions;\n}();\n\nexports.default = ParseOptions;","map":{"version":3,"mappings":"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","names":["configuration","options","Map","handlers","nodeFactory","NodeFactory_js_1","setCreators","nodes","itemFactory","StackItemFactory_js_1","items","Options_js_1","apply","__spreadArray","__read","ParseOptions","parser","parsers","unshift","shift","Object","root","nodeLists","error","tags","resetTag","property","node","list","push","kind","inlists","NodeUtil_js_1","getProperty","lists","split","concat","join","setProperty","result","list_1_1","inTree","nodes_1_1","i","indexOf","splice","parent"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/input/tex/ParseOptions.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Factory generating maps to keep options for the TeX parser.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport StackItemFactory from './StackItemFactory.js';\nimport {Tags} from './Tags.js';\nimport {SubHandlers} from './MapHandler.js';\nimport {NodeFactory} from './NodeFactory.js';\nimport NodeUtil from './NodeUtil.js';\nimport {MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport TexParser from './TexParser.js';\nimport {defaultOptions, OptionList} from '../../util/Options.js';\nimport {ParserConfiguration} from './Configuration.js';\n\n\n/**\n * @class\n */\nexport default class ParseOptions {\n\n  /**\n   * A set of sub handlers\n   * @type {SubHandlers}\n   */\n  public handlers: SubHandlers;\n\n  /**\n   * A set of options, mapping names to string or boolean values.\n   * @type {OptionList}\n   */\n  public options: OptionList = {};\n\n  /**\n   * The current item factory.\n   * @type {StackItemFactory}\n   */\n  public itemFactory: StackItemFactory;\n\n  /**\n   * The current node factory.\n   * @type {NodeFactory}\n   */\n  public nodeFactory: NodeFactory;\n\n  /**\n   * The current tagging object.\n   * @type {Tags}\n   */\n  public tags: Tags;\n\n  /**\n   * Storage area for parser-specific package data (indexed by package name)\n   * @type {Map<string, any>}\n   */\n  public packageData: Map<string, any> = new Map();\n\n  // Fields for ephemeral options, i.e., options that will be cleared for each\n  // run of the parser.\n  /**\n   * Stack of previous tex parsers. This is used to keep track of parser\n   * settings when expressions are recursively parsed.\n   * @type {TexParser[]}\n   */\n  public parsers: TexParser[] = [];\n\n\n  /**\n   * The current root node.\n   * @type {MmlNode}\n   */\n  public root: MmlNode = null;\n\n  /**\n   * List of node lists saved with respect to some property or their kind.\n   * @type {{[key: string]: MmlNode[]}}\n   */\n  public nodeLists: {[key: string]: MmlNode[]} = {};\n\n  /**\n   * Error state of the parser.\n   * @type {boolean}\n   */\n  public error: boolean = false;\n\n\n\n  /**\n   * @constructor\n   * @param {Configuration} configuration Configuration object of the current\n   *     TeX parser.\n   * @param {OptionList[]} options   [TeX options, Tag options, {packages}]\n   */\n  public constructor(configuration: ParserConfiguration, options: OptionList[] = []) {\n    this.handlers = configuration.handlers;\n    // Add node factory methods from packages.\n    this.nodeFactory = new NodeFactory();\n    this.nodeFactory.configuration = this;\n    this.nodeFactory.setCreators(configuration.nodes);\n    // Add stackitems from packages.\n    this.itemFactory = new StackItemFactory(configuration.items);\n    this.itemFactory.configuration = this;\n    // Set default options for parser from packages and for tags.\n    defaultOptions(this.options, ...options);\n    defaultOptions(this.options, configuration.options);\n  }\n\n\n  // Methods for dealing with ephemeral fields.\n  /**\n   * Pushes a new tex parser onto the stack.\n   * @param {TexParser} parser The new parser.\n   */\n  public pushParser(parser: TexParser) {\n    this.parsers.unshift(parser);\n  }\n\n\n  /**\n   * Pops a parser of the tex parser stack.\n   */\n  public popParser() {\n    this.parsers.shift();\n  }\n\n\n  /**\n   * @return {TexParser} The currently active tex parser.\n   */\n  public get parser(): TexParser {\n    return this.parsers[0];\n  }\n\n  /**\n   * Clears all the ephemeral options.\n   */\n  public clear() {\n    this.parsers = [];\n    this.root = null;\n    this.nodeLists = {};\n    this.error = false;\n    this.tags.resetTag();\n  }\n\n\n  /**\n   * Saves a tree node to a list of nodes for post processing.\n   * @param {string} property The property name that will be used for\n   *     postprocessing.\n   * @param {MmlNode} node The node to save.\n   */\n  public addNode(property: string, node: MmlNode) {\n    let list = this.nodeLists[property];\n    if (!list) {\n      list = this.nodeLists[property] = [];\n    }\n    list.push(node);\n    if (node.kind !== property) {\n      //\n      // If the list is not just for its kind, record that it is in this list\n      //   so that if it is copied, the copy can also be added to the list.\n      //\n      const inlists = (NodeUtil.getProperty(node, 'in-lists') as string || '');\n      const lists = (inlists ? inlists.split(/,/) : []).concat(property).join(',');\n      NodeUtil.setProperty(node, 'in-lists', lists);\n    }\n  }\n\n\n  /**\n   * Gets a saved node list with respect to a given property. It first ensures\n   * that all the nodes are \"live\", i.e., actually live in the current\n   * tree. Sometimes nodes are created, saved in the node list but discarded\n   * later in the parsing. These will be filtered out here.\n   *\n   * NB: Do not use this method before the root field of the options is\n   * set. Otherwise, your node list will always be empty!\n   * @param {string} property The property for which to retrieve the node list.\n   */\n  public getList(property: string) {\n    let list = this.nodeLists[property] || [];\n    let result = [];\n    for (let node of list) {\n      if (this.inTree(node)) {\n        result.push(node);\n      }\n    }\n    this.nodeLists[property] = result;\n    return result;\n  }\n\n\n  /**\n   * Remove a list of nodes from a saved list (e.g., when a filter removes the\n   * node from the DOM, like for munderover => munder).\n   *\n   * @param {string} property The property from which to remove nodes.\n   * @param {MmlNode[]} nodes The nodes to remove.\n   */\n  public removeFromList(property: string, nodes: MmlNode[]) {\n    const list = this.nodeLists[property] || [];\n    for (const node of nodes) {\n      const i = list.indexOf(node);\n      if (i >= 0) {\n        list.splice(i, 1);\n      }\n    }\n  }\n\n\n  /**\n   * Tests if the node is in the tree spanned by the current root node.\n   * @param {MmlNode} node The node to test.\n   */\n  private inTree(node: MmlNode) {\n    while (node && node !== this.root) {\n      node = node.parent;\n    }\n    return !!node;\n  }\n\n}\n"]},"metadata":{},"sourceType":"script"}