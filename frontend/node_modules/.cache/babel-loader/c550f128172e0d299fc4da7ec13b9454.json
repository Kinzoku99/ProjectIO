{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommonTextNodeMixin = void 0;\n\nfunction CommonTextNodeMixin(Base) {\n  return function (_super) {\n    __extends(class_1, _super);\n\n    function class_1() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    class_1.prototype.computeBBox = function (bbox, _recompute) {\n      var e_1, _a;\n\n      if (_recompute === void 0) {\n        _recompute = false;\n      }\n\n      var variant = this.parent.variant;\n      var text = this.node.getText();\n\n      if (variant === '-explicitFont') {\n        var font = this.jax.getFontData(this.parent.styles);\n\n        var _b = this.jax.measureText(text, variant, font),\n            w = _b.w,\n            h = _b.h,\n            d = _b.d;\n\n        bbox.h = h;\n        bbox.d = d;\n        bbox.w = w;\n      } else {\n        var chars = this.remappedText(text, variant);\n        bbox.empty();\n\n        try {\n          for (var chars_1 = __values(chars), chars_1_1 = chars_1.next(); !chars_1_1.done; chars_1_1 = chars_1.next()) {\n            var char = chars_1_1.value;\n\n            var _c = __read(this.getVariantChar(variant, char), 4),\n                h = _c[0],\n                d = _c[1],\n                w = _c[2],\n                data = _c[3];\n\n            if (data.unknown) {\n              var cbox = this.jax.measureText(String.fromCodePoint(char), variant);\n              w = cbox.w;\n              h = cbox.h;\n              d = cbox.d;\n            }\n\n            bbox.w += w;\n            if (h > bbox.h) bbox.h = h;\n            if (d > bbox.d) bbox.d = d;\n            bbox.ic = data.ic || 0;\n            bbox.sk = data.sk || 0;\n            bbox.dx = data.dx || 0;\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (chars_1_1 && !chars_1_1.done && (_a = chars_1.return)) _a.call(chars_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n\n        if (chars.length > 1) {\n          bbox.sk = 0;\n        }\n\n        bbox.clean();\n      }\n    };\n\n    class_1.prototype.remappedText = function (text, variant) {\n      var c = this.parent.stretch.c;\n      return c ? [c] : this.parent.remapChars(this.unicodeChars(text, variant));\n    };\n\n    class_1.prototype.getStyles = function () {};\n\n    class_1.prototype.getVariant = function () {};\n\n    class_1.prototype.getScale = function () {};\n\n    class_1.prototype.getSpace = function () {};\n\n    return class_1;\n  }(Base);\n}\n\nexports.CommonTextNodeMixin = CommonTextNodeMixin;","map":{"version":3,"mappings":"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","names":["CommonTextNodeMixin","Base","__extends","class_1","bbox","_recompute","variant","parent","text","node","getText","font","jax","getFontData","styles","measureText","w","h","d","chars","remappedText","empty","chars_1_1","char","getVariantChar","data","unknown","cbox","String","fromCodePoint","ic","sk","dx","length","clean","c","stretch","remapChars","unicodeChars","exports"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/output/common/Wrappers/TextNode.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the CommonTextNode wrapper mixin for the TextNode object\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AnyWrapper, WrapperConstructor, Constructor} from '../Wrapper.js';\nimport {BBox} from '../../../util/BBox.js';\nimport {TextNode} from '../../../core/MmlTree/MmlNode.js';\n\n/*****************************************************************/\n/**\n * The CommonTextNode interface\n */\nexport interface CommonTextNode extends AnyWrapper {\n  /**\n   * @param {string} text     The text to remap\n   * @param {string} variant  The variant for the character\n   * @return {number[]}       The unicode points for the (remapped) text\n   */\n  remappedText(text: string, variant: string): number[];\n}\n\n/**\n * Shorthand for the CommonTextNode constructor\n */\nexport type TextNodeConstructor = Constructor<CommonTextNode>;\n\n/*****************************************************************/\n/**\n *  The CommonTextNode wrapper mixin for the TextNode object\n *\n * @template T  The Wrapper class constructor type\n */\nexport function CommonTextNodeMixin<T extends WrapperConstructor>(Base: T): TextNodeConstructor & T {\n\n  return class extends Base {\n\n    /**\n     * @override\n     */\n    public computeBBox(bbox: BBox, _recompute: boolean = false) {\n      const variant = this.parent.variant;\n      const text = (this.node as TextNode).getText();\n      if (variant === '-explicitFont') {\n        //\n        // Measure the size of the text (using the DOM if possible)\n        //\n        const font = this.jax.getFontData(this.parent.styles);\n        const {w, h, d} = this.jax.measureText(text, variant, font);\n        bbox.h = h;\n        bbox.d = d;\n        bbox.w = w;\n      } else {\n        const chars = this.remappedText(text, variant);\n        bbox.empty();\n        //\n        // Loop through the characters and add them in one by one\n        //\n        for (const char of chars) {\n          let [h, d, w, data] = this.getVariantChar(variant, char);\n          if (data.unknown) {\n            //\n            // Measure unknown characters using the DOM (if possible)\n            //\n            const cbox = this.jax.measureText(String.fromCodePoint(char), variant);\n            w = cbox.w;\n            h = cbox.h;\n            d = cbox.d;\n          }\n          //\n          // Update the bounding box\n          //\n          bbox.w += w;\n          if (h > bbox.h) bbox.h = h;\n          if (d > bbox.d) bbox.d = d;\n          bbox.ic = data.ic || 0;\n          bbox.sk = data.sk || 0;\n          bbox.dx = data.dx || 0;\n        }\n        if (chars.length > 1) {\n          bbox.sk = 0;\n        }\n        bbox.clean();\n      }\n    }\n\n    /**\n     * @param {string} text     The text to remap\n     * @param {string} variant  The variant for the character\n     * @return {number[]}       The unicode points for the (remapped) text\n     */\n    public remappedText(text: string, variant: string): number[] {\n      const c = this.parent.stretch.c;\n      return (c ? [c] : this.parent.remapChars(this.unicodeChars(text, variant)));\n    }\n\n    /******************************************************/\n    /*\n     * TextNodes don't need these, since these properties\n     *   are inherited from the parent nodes\n     */\n\n    /**\n     * @override\n     */\n    public getStyles() {}\n\n    /**\n     * @override\n     */\n    public getVariant() {}\n\n    /**\n     * @override\n     */\n    public getScale() {}\n\n    /**\n     * @override\n     */\n    public getSpace() {}\n\n  };\n\n}\n"]},"metadata":{},"sourceType":"script"}