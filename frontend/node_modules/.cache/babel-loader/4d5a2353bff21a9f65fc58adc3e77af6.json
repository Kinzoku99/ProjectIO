{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommonMencloseMixin = void 0;\n\nvar Notation = require(\"../Notation.js\");\n\nvar string_js_1 = require(\"../../../util/string.js\");\n\nfunction CommonMencloseMixin(Base) {\n  return function (_super) {\n    __extends(class_1, _super);\n\n    function class_1() {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var _this = _super.apply(this, __spreadArray([], __read(args))) || this;\n\n      _this.notations = {};\n      _this.renderChild = null;\n      _this.msqrt = null;\n      _this.padding = Notation.PADDING;\n      _this.thickness = Notation.THICKNESS;\n      _this.arrowhead = {\n        x: Notation.ARROWX,\n        y: Notation.ARROWY,\n        dx: Notation.ARROWDX\n      };\n      _this.TRBL = [0, 0, 0, 0];\n\n      _this.getParameters();\n\n      _this.getNotations();\n\n      _this.removeRedundantNotations();\n\n      _this.initializeNotations();\n\n      _this.TRBL = _this.getBBoxExtenders();\n      return _this;\n    }\n\n    class_1.prototype.getParameters = function () {\n      var attributes = this.node.attributes;\n      var padding = attributes.get('data-padding');\n\n      if (padding !== undefined) {\n        this.padding = this.length2em(padding, Notation.PADDING);\n      }\n\n      var thickness = attributes.get('data-thickness');\n\n      if (thickness !== undefined) {\n        this.thickness = this.length2em(thickness, Notation.THICKNESS);\n      }\n\n      var arrowhead = attributes.get('data-arrowhead');\n\n      if (arrowhead !== undefined) {\n        var _b = __read(string_js_1.split(arrowhead), 3),\n            x = _b[0],\n            y = _b[1],\n            dx = _b[2];\n\n        this.arrowhead = {\n          x: x ? parseFloat(x) : Notation.ARROWX,\n          y: y ? parseFloat(y) : Notation.ARROWY,\n          dx: dx ? parseFloat(dx) : Notation.ARROWDX\n        };\n      }\n    };\n\n    class_1.prototype.getNotations = function () {\n      var e_1, _b;\n\n      var Notations = this.constructor.notations;\n\n      try {\n        for (var _c = __values(string_js_1.split(this.node.attributes.get('notation'))), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_1 = _d.value;\n          var notation = Notations.get(name_1);\n\n          if (notation) {\n            this.notations[name_1] = notation;\n\n            if (notation.renderChild) {\n              this.renderChild = notation.renderer;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    };\n\n    class_1.prototype.removeRedundantNotations = function () {\n      var e_2, _b, e_3, _c;\n\n      try {\n        for (var _d = __values(Object.keys(this.notations)), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var name_2 = _e.value;\n\n          if (this.notations[name_2]) {\n            var remove = this.notations[name_2].remove || '';\n\n            try {\n              for (var _f = (e_3 = void 0, __values(remove.split(/ /))), _g = _f.next(); !_g.done; _g = _f.next()) {\n                var notation = _g.value;\n                delete this.notations[notation];\n              }\n            } catch (e_3_1) {\n              e_3 = {\n                error: e_3_1\n              };\n            } finally {\n              try {\n                if (_g && !_g.done && (_c = _f.return)) _c.call(_f);\n              } finally {\n                if (e_3) throw e_3.error;\n              }\n            }\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    };\n\n    class_1.prototype.initializeNotations = function () {\n      var e_4, _b;\n\n      try {\n        for (var _c = __values(Object.keys(this.notations)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_3 = _d.value;\n          var init = this.notations[name_3].init;\n          init && init(this);\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n    };\n\n    class_1.prototype.computeBBox = function (bbox, recompute) {\n      if (recompute === void 0) {\n        recompute = false;\n      }\n\n      var _b = __read(this.TRBL, 4),\n          T = _b[0],\n          R = _b[1],\n          B = _b[2],\n          L = _b[3];\n\n      var child = this.childNodes[0].getBBox();\n      bbox.combine(child, L, 0);\n      bbox.h += T;\n      bbox.d += B;\n      bbox.w += R;\n      this.setChildPWidths(recompute);\n    };\n\n    class_1.prototype.getBBoxExtenders = function () {\n      var e_5, _b;\n\n      var TRBL = [0, 0, 0, 0];\n\n      try {\n        for (var _c = __values(Object.keys(this.notations)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_4 = _d.value;\n          this.maximizeEntries(TRBL, this.notations[name_4].bbox(this));\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n\n      return TRBL;\n    };\n\n    class_1.prototype.getPadding = function () {\n      var e_6, _b;\n\n      var _this = this;\n\n      var BTRBL = [0, 0, 0, 0];\n\n      try {\n        for (var _c = __values(Object.keys(this.notations)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_5 = _d.value;\n          var border = this.notations[name_5].border;\n\n          if (border) {\n            this.maximizeEntries(BTRBL, border(this));\n          }\n        }\n      } catch (e_6_1) {\n        e_6 = {\n          error: e_6_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_6) throw e_6.error;\n        }\n      }\n\n      return [0, 1, 2, 3].map(function (i) {\n        return _this.TRBL[i] - BTRBL[i];\n      });\n    };\n\n    class_1.prototype.maximizeEntries = function (X, Y) {\n      for (var i = 0; i < X.length; i++) {\n        if (X[i] < Y[i]) {\n          X[i] = Y[i];\n        }\n      }\n    };\n\n    class_1.prototype.getOffset = function (direction) {\n      var _b = __read(this.TRBL, 4),\n          T = _b[0],\n          R = _b[1],\n          B = _b[2],\n          L = _b[3];\n\n      var d = (direction === 'X' ? R - L : B - T) / 2;\n      return Math.abs(d) > .001 ? d : 0;\n    };\n\n    class_1.prototype.getArgMod = function (w, h) {\n      return [Math.atan2(h, w), Math.sqrt(w * w + h * h)];\n    };\n\n    class_1.prototype.arrow = function (_w, _a, _double, _offset, _dist) {\n      if (_offset === void 0) {\n        _offset = '';\n      }\n\n      if (_dist === void 0) {\n        _dist = 0;\n      }\n\n      return null;\n    };\n\n    class_1.prototype.arrowData = function () {\n      var _b = __read([this.padding, this.thickness], 2),\n          p = _b[0],\n          t = _b[1];\n\n      var r = t * (this.arrowhead.x + Math.max(1, this.arrowhead.dx));\n\n      var _c = this.childNodes[0].getBBox(),\n          h = _c.h,\n          d = _c.d,\n          w = _c.w;\n\n      var H = h + d;\n      var R = Math.sqrt(H * H + w * w);\n      var x = Math.max(p, r * w / R);\n      var y = Math.max(p, r * H / R);\n\n      var _d = __read(this.getArgMod(w + 2 * x, H + 2 * y), 2),\n          a = _d[0],\n          W = _d[1];\n\n      return {\n        a: a,\n        W: W,\n        x: x,\n        y: y\n      };\n    };\n\n    class_1.prototype.arrowAW = function () {\n      var _b = this.childNodes[0].getBBox(),\n          h = _b.h,\n          d = _b.d,\n          w = _b.w;\n\n      var _c = __read(this.TRBL, 4),\n          T = _c[0],\n          R = _c[1],\n          B = _c[2],\n          L = _c[3];\n\n      return this.getArgMod(L + w + R, T + h + d + B);\n    };\n\n    class_1.prototype.createMsqrt = function (child) {\n      var mmlFactory = this.node.factory;\n      var mml = mmlFactory.create('msqrt');\n      mml.inheritAttributesFrom(this.node);\n      mml.childNodes[0] = child.node;\n      var node = this.wrap(mml);\n      node.parent = this;\n      return node;\n    };\n\n    class_1.prototype.sqrtTRBL = function () {\n      var bbox = this.msqrt.getBBox();\n      var cbox = this.msqrt.childNodes[0].getBBox();\n      return [bbox.h - cbox.h, 0, bbox.d - cbox.d, bbox.w - cbox.w];\n    };\n\n    return class_1;\n  }(Base);\n}\n\nexports.CommonMencloseMixin = CommonMencloseMixin;","map":{"version":3,"mappings":"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","names":["CommonMencloseMixin","Base","__extends","args","_this","Notation","PADDING","THICKNESS","x","ARROWX","y","ARROWY","dx","ARROWDX","getParameters","getNotations","removeRedundantNotations","initializeNotations","TRBL","getBBoxExtenders","class_1","attributes","node","padding","get","undefined","length2em","thickness","arrowhead","string_js_1","parseFloat","Notations","constructor","notations","_d","name_1","notation","renderChild","renderer","keys","_e","name_2","remove","split","_g","name_3","init","bbox","recompute","T","R","B","L","child","childNodes","getBBox","combine","h","d","w","setChildPWidths","name_4","maximizeEntries","BTRBL","name_5","border","map","i","X","Y","length","direction","Math","abs","atan2","sqrt","_w","_a","_double","_offset","_dist","p","t","r","max","H","getArgMod","a","W","mmlFactory","factory","mml","create","inheritAttributesFrom","wrap","parent","msqrt","cbox","exports"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/output/common/Wrappers/menclose.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the CommonMenclose wrapper mixin for the MmlMenclose object\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AnyWrapper, WrapperConstructor, Constructor, AnyWrapperClass} from '../Wrapper.js';\nimport * as Notation from '../Notation.js';\nimport {CommonMsqrt} from './msqrt.js';\nimport {BBox} from '../../../util/BBox.js';\nimport {AbstractMmlNode} from '../../../core/MmlTree/MmlNode.js';\nimport {split} from '../../../util/string.js';\n\n/*****************************************************************/\n/**\n * The CommonMenclose interface\n *\n * @template W  The menclose wrapper type\n */\nexport interface CommonMenclose<W extends AnyWrapper, S extends CommonMsqrt, N> extends AnyWrapper {\n  /**\n   *  The notations active on this menclose, and the one to use for the child, if any\n   */\n  notations: Notation.List<W, N>;\n  renderChild: Notation.Renderer<W, N>;\n\n  /**\n   * fake msqrt for radial notation (if used)\n   */\n  msqrt: S;\n\n  /**\n   * The padding, thickness, and shape of the arrow head\n   *   (may be overridden using data-padding, data-thickness, and data-arrowhead attibutes)\n   */\n  padding: number;\n  thickness: number;\n  arrowhead: {x: number, y: number, dx: number};\n\n  /**\n   * The top, right, bottom, and left padding, added by notations\n   */\n  TRBL: Notation.PaddingData;\n\n  /**\n   * Look up the data-* attributes and override the default values\n   */\n  getParameters(): void;\n\n  /**\n   *  Get the notations given in the notation attribute\n   *    and check if any are used to render the child nodes\n   */\n  getNotations(): void;\n\n  /**\n   *  Remove any redundant notations\n   */\n  removeRedundantNotations(): void;\n\n  /**\n   *  Run any initialization needed by notations in use\n   */\n  initializeNotations(): void;\n\n  /**\n   * @return {Notation.PaddingData}  Array of the maximum extra space from the notations along each side\n   */\n  getBBoxExtenders(): Notation.PaddingData;\n\n  /**\n   * @return {Notation.PaddingData}  Array of padding (i.e., BBox minus border) along each side\n   */\n  getPadding(): Notation.PaddingData;\n\n  /**\n   * Each entry in X gets replaced by the corresponding one in Y if it is larger\n   *\n   * @param {Notation.PaddingData} X   An array of numbers\n   * @param {Notation.PaddingData} Y   An array of numbers that replace smaller ones in X\n   */\n  maximizeEntries(X: Notation.PaddingData, Y: Notation.PaddingData): void;\n\n  /**\n   * Get the offset amount for the given direction for vertical and horizontal centering\n   *\n   * @param {string} direction    The direction 'X' or 'Y' for the offset\n   * @return {number}             The amount of offset in that direction\n   */\n  getOffset(direction: string): number;\n\n  /**\n   * @param {number} w    The width of the box whose diagonal is needed\n   * @param {number} h    The height of the box whose diagonal is needed\n   * @return {number[]}   The angle and width of the diagonal of the box\n   */\n  getArgMod(w: number, h: number): [number, number];\n\n  /**\n   * Create an arrow for output\n   *\n   * @param {number} w         The length of the arrow\n   * @param {number} a         The angle for the arrow\n   * @param {boolean} double   True if this is a double-headed arrow\n   * @param {string} offset    'X' for vertical arrow, 'Y' for horizontal\n   * @param {number} trans     Distance to translate in the offset direction\n   * @return {N}               The newly created arrow\n   */\n  arrow(w: number, a: number, double: boolean, offset?: string, trans?: number): N;\n\n  /**\n   * Get the angle and width of a diagonal arrow, plus the x and y extension\n   *   past the content bounding box\n   */\n  arrowData(): {a: number, W: number, x: number, y: number};\n\n  /**\n   * Get the angle and width for a diagonal arrow\n   *\n   * @return {[number, number]}   The angle and width\n   */\n  arrowAW(): [number, number];\n\n  /**\n   * Create an unattached msqrt wrapper to render the 'radical' notation.\n   *   We replace the inferred mrow of the msqrt with the one from the menclose\n   *   but without changing the parent pointer, so as not to detach it from\n   *   the menclose (which would desrtoy the original MathML tree).\n   *\n   * @param {W} child   The inferred mrow that is the child of this menclose\n   * @return {S}        The newly created (but detached) msqrt wrapper\n   */\n  createMsqrt(child: W): S;\n\n  /**\n   * @return {number[]}  The differences between the msqrt bounding box\n   *                     and its child bounding box (i.e., the extra space\n   *                     created by the radical symbol).\n   */\n  sqrtTRBL(): number[];\n}\n\n/**\n * The CommonMenclose class interface\n *\n * @template W  The menclose wrapper type\n * @templare N  The DOM node class\n */\nexport interface CommonMencloseClass<W extends AnyWrapper, N> extends AnyWrapperClass {\n  /**\n   *  The definitions of the various notations\n   */\n  notations: Notation.DefList<W, N>;\n}\n\n/**\n * Shorthand for the CommonMenclose constructor\n *\n * @template W  The menclose wrapper type\n */\nexport type MencloseConstructor<W extends AnyWrapper, S extends CommonMsqrt, N> = Constructor<CommonMenclose<W, S, N>>;\n\n/*****************************************************************/\n/**\n * The CommonMenclose wrapper mixin for the MmlMenclose object\n *\n * @template W  The menclose wrapper type\n * @templare N  The DOM node class\n * @templare S  The msqrt wrapper class\n * @template T  The Wrapper class constructor type\n */\nexport function CommonMencloseMixin<\n  W extends AnyWrapper,\n  S extends CommonMsqrt,\n  N,\n  T extends WrapperConstructor\n>(Base: T): MencloseConstructor<W, S, N> & T {\n\n  return class extends Base {\n\n    /**\n     *  The notations active on this menclose, if any\n     */\n    public notations: Notation.List<W, N> = {};\n\n    /**\n     *  The notation to use for the child, if any\n     */\n    public renderChild: Notation.Renderer<W, N> = null;\n\n    /**\n     * fake msqrt for radial notation (if used)\n     */\n    public msqrt: S = null;\n\n    /**\n     * The padding of the arrow head (may be overridden using data-padding attibute)\n     */\n    public padding: number = Notation.PADDING;\n    /**\n     * The thickness of the arrow head (may be overridden using data-thickness attibute)\n     */\n    public thickness: number = Notation.THICKNESS;\n    /**\n     * The shape of the arrow head (may be overridden using data-arrowhead attibutes)\n     */\n    public arrowhead = {x: Notation.ARROWX, y: Notation.ARROWY, dx: Notation.ARROWDX};\n\n    /**\n     * The top, right, bottom, and left padding (added by notations)\n     */\n    public TRBL: Notation.PaddingData = [0, 0, 0, 0];\n\n    /**\n     * @override\n     * @constructor\n     */\n    constructor(...args: any[]) {\n      super(...args);\n      this.getParameters();\n      this.getNotations();\n      this.removeRedundantNotations();\n      this.initializeNotations();\n      this.TRBL = this.getBBoxExtenders();\n    }\n\n    /**\n     * Look up the data-* attributes and override the default values\n     */\n    public getParameters() {\n      const attributes = this.node.attributes;\n      const padding = attributes.get('data-padding');\n      if (padding !== undefined) {\n        this.padding = this.length2em(padding, Notation.PADDING);\n      }\n      const thickness = attributes.get('data-thickness');\n      if (thickness !== undefined) {\n        this.thickness = this.length2em(thickness, Notation.THICKNESS);\n      }\n      const arrowhead = attributes.get('data-arrowhead') as string;\n      if (arrowhead !== undefined) {\n        let [x, y, dx] = split(arrowhead);\n        this.arrowhead = {\n          x: (x ? parseFloat(x) : Notation.ARROWX),\n          y: (y ? parseFloat(y) : Notation.ARROWY),\n          dx: (dx ? parseFloat(dx) : Notation.ARROWDX)\n        };\n      }\n    }\n\n    /**\n     *  Get the notations given in the notation attribute\n     *    and check if any are used to render the child nodes\n     */\n    public getNotations() {\n      const Notations = (this.constructor as CommonMencloseClass<W, N>).notations;\n      for (const name of split(this.node.attributes.get('notation') as string)) {\n        const notation = Notations.get(name);\n        if (notation) {\n          this.notations[name] = notation;\n          if (notation.renderChild) {\n            this.renderChild = notation.renderer;\n          }\n        }\n      }\n    }\n\n    /**\n     *  Remove any redundant notations\n     */\n    public removeRedundantNotations() {\n      for (const name of Object.keys(this.notations)) {\n        if (this.notations[name]) {\n          const remove = this.notations[name].remove || '';\n          for (const notation of remove.split(/ /)) {\n            delete this.notations[notation];\n          }\n        }\n      }\n    }\n\n    /**\n     *  Run any initialization needed by notations in use\n     */\n    public initializeNotations() {\n      for (const name of Object.keys(this.notations)) {\n        const init = this.notations[name].init;\n        init && init(this as any);\n      }\n    }\n\n    /********************************************************/\n\n    /**\n     * @override\n     */\n    public computeBBox(bbox: BBox, recompute: boolean = false) {\n      //\n      //  Combine the BBox from the child and add the extenders\n      //\n      let [T, R, B, L] = this.TRBL;\n      const child = this.childNodes[0].getBBox();\n      bbox.combine(child, L, 0);\n      bbox.h += T;\n      bbox.d += B;\n      bbox.w += R;\n      this.setChildPWidths(recompute);\n    }\n\n    /**\n     * @return {Notation.PaddingData}  Array of the maximum extra space from the notations along each side\n     */\n    public getBBoxExtenders(): Notation.PaddingData {\n      let TRBL = [0, 0, 0, 0] as Notation.PaddingData;\n      for (const name of Object.keys(this.notations)) {\n        this.maximizeEntries(TRBL, this.notations[name].bbox(this as any));\n      }\n      return TRBL;\n    }\n\n    /**\n     * @return {Notation.PaddingData}  Array of padding (i.e., BBox minus border) along each side\n     */\n    public getPadding(): Notation.PaddingData {\n      let BTRBL = [0, 0, 0, 0] as Notation.PaddingData;\n      for (const name of Object.keys(this.notations)) {\n        const border = this.notations[name].border;\n        if (border) {\n          this.maximizeEntries(BTRBL, border(this as any));\n        }\n      }\n      return [0, 1, 2, 3].map(i => this.TRBL[i] - BTRBL[i]) as Notation.PaddingData;\n    }\n\n    /**\n     * Each entry in X gets replaced by the corresponding one in Y if it is larger\n     *\n     * @param {Notation.PaddingData} X   An array of numbers\n     * @param {Notation.PaddingData} Y   An array of numbers that replace smaller ones in X\n     */\n    public maximizeEntries(X: Notation.PaddingData, Y: Notation.PaddingData) {\n      for (let i = 0; i < X.length; i++) {\n        if (X[i] < Y[i]) {\n          X[i] = Y[i];\n        }\n      }\n    }\n\n    /********************************************************/\n\n    /**\n     * Get the offset amount for the given direction for vertical and horizontal centering\n     *\n     * @param {string} direction    The direction 'X' or 'Y' for the offset\n     * @return {number}             The amount of offset in that direction\n     */\n    public getOffset(direction: string): number {\n      let [T, R, B, L] = this.TRBL;\n      const d = (direction === 'X' ? R - L : B - T) / 2;\n      return (Math.abs(d) > .001 ? d : 0);\n    }\n\n    /**\n     * @param {number} w    The width of the box whose diagonal is needed\n     * @param {number} h    The height of the box whose diagonal is needed\n     * @return {number[]}   The angle and width of the diagonal of the box\n     */\n    public getArgMod(w: number, h: number): [number, number] {\n      return [Math.atan2(h, w), Math.sqrt(w * w + h * h)];\n    }\n\n    /**\n     * Create an arrow using an svg element\n     *\n     * @param {number} w        The length of the arrow\n     * @param {number} a        The angle for the arrow\n     * @param {boolean} double  True if this is a double-headed arrow\n     * @param {string} offset   'X' for vertical arrow, 'Y' for horizontal\n     * @param {number} dist     Distance to translate in the offset direction\n     * @return {N}              The newly created arrow\n     */\n    public arrow(_w: number, _a: number, _double: boolean, _offset: string = '', _dist: number = 0): N {\n      return null as N;\n    }\n\n    /**\n     * Get the angle and width of a diagonal arrow, plus the x and y extension\n     *   past the content bounding box\n     *\n     * @return {Object}  The angle, width, and x and y extentions\n     */\n    public arrowData(): {a: number, W: number, x: number, y: number} {\n      const [p, t] = [this.padding, this.thickness];\n      const r = t * (this.arrowhead.x + Math.max(1, this.arrowhead.dx));\n      const {h, d, w} = this.childNodes[0].getBBox();\n      const H = h + d;\n      const R = Math.sqrt(H * H + w * w);\n      const x = Math.max(p, r * w / R);\n      const y = Math.max(p, r * H / R);\n      const [a, W] = this.getArgMod(w + 2 * x, H + 2 * y);\n      return {a, W, x, y};\n    }\n\n    /**\n     * Get the angle and width for a diagonal arrow\n     *\n     * @return {[number, number]}   The angle and width\n     */\n    public arrowAW(): [number, number] {\n      const {h, d, w} = this.childNodes[0].getBBox();\n      const [T, R, B, L] = this.TRBL;\n      return this.getArgMod(L + w + R, T + h + d + B);\n    }\n\n    /********************************************************/\n\n    /**\n     * Create an unattached msqrt wrapper to render the 'radical' notation.\n     *   We replace the inferred mrow of the msqrt with the one from the menclose\n     *   but without changing the parent pointer, so as not to detach it from\n     *   the menclose (which would desrtoy the original MathML tree).\n     *\n     * @param {W} child   The inferred mrow that is the child of this menclose\n     * @return {S}        The newly created (but detached) msqrt wrapper\n     */\n    public createMsqrt(child: W): S {\n      const mmlFactory = (this.node as AbstractMmlNode).factory;\n      const mml = mmlFactory.create('msqrt');\n      mml.inheritAttributesFrom(this.node);\n      mml.childNodes[0] = child.node;\n      const node = this.wrap(mml) as S;\n      node.parent = this;\n      return node;\n    }\n\n    /**\n     * @return {number[]}  The differences between the msqrt bounding box\n     *                     and its child bounding box (i.e., the extra space\n     *                     created by the radical symbol).\n     */\n    public sqrtTRBL(): [number, number, number, number] {\n      const bbox = this.msqrt.getBBox();\n      const cbox = this.msqrt.childNodes[0].getBBox();\n      return [bbox.h - cbox.h, 0, bbox.d - cbox.d, bbox.w - cbox.w];\n    }\n\n  };\n}\n"]},"metadata":{},"sourceType":"script"}