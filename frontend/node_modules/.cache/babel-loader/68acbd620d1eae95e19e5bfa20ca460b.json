{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XMLNode = exports.TextNode = exports.AbstractMmlEmptyNode = exports.AbstractMmlBaseNode = exports.AbstractMmlLayoutNode = exports.AbstractMmlTokenNode = exports.AbstractMmlNode = exports.indentAttributes = exports.TEXCLASSNAMES = exports.TEXCLASS = void 0;\n\nvar Attributes_js_1 = require(\"./Attributes.js\");\n\nvar Node_js_1 = require(\"../Tree/Node.js\");\n\nexports.TEXCLASS = {\n  ORD: 0,\n  OP: 1,\n  BIN: 2,\n  REL: 3,\n  OPEN: 4,\n  CLOSE: 5,\n  PUNCT: 6,\n  INNER: 7,\n  VCENTER: 8,\n  NONE: -1\n};\nexports.TEXCLASSNAMES = ['ORD', 'OP', 'BIN', 'REL', 'OPEN', 'CLOSE', 'PUNCT', 'INNER', 'VCENTER'];\nvar TEXSPACELENGTH = ['', 'thinmathspace', 'mediummathspace', 'thickmathspace'];\nvar TEXSPACE = [[0, -1, 2, 3, 0, 0, 0, 1], [-1, -1, 0, 3, 0, 0, 0, 1], [2, 2, 0, 0, 2, 0, 0, 2], [3, 3, 0, 0, 3, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0], [0, -1, 2, 3, 0, 0, 0, 1], [1, 1, 0, 1, 1, 1, 1, 1], [1, -1, 2, 3, 1, 0, 1, 1]];\nexports.indentAttributes = ['indentalign', 'indentalignfirst', 'indentshift', 'indentshiftfirst'];\n\nvar AbstractMmlNode = function (_super) {\n  __extends(AbstractMmlNode, _super);\n\n  function AbstractMmlNode(factory, attributes, children) {\n    if (attributes === void 0) {\n      attributes = {};\n    }\n\n    if (children === void 0) {\n      children = [];\n    }\n\n    var _this = _super.call(this, factory) || this;\n\n    _this.prevClass = null;\n    _this.prevLevel = null;\n    _this.texclass = null;\n\n    if (_this.arity < 0) {\n      _this.childNodes = [factory.create('inferredMrow')];\n      _this.childNodes[0].parent = _this;\n    }\n\n    _this.setChildren(children);\n\n    _this.attributes = new Attributes_js_1.Attributes(factory.getNodeClass(_this.kind).defaults, factory.getNodeClass('math').defaults);\n\n    _this.attributes.setList(attributes);\n\n    return _this;\n  }\n\n  AbstractMmlNode.prototype.copy = function (keepIds) {\n    var e_1, _a, e_2, _b;\n\n    if (keepIds === void 0) {\n      keepIds = false;\n    }\n\n    var node = this.factory.create(this.kind);\n    node.properties = __assign({}, this.properties);\n\n    if (this.attributes) {\n      var attributes = this.attributes.getAllAttributes();\n\n      try {\n        for (var _c = __values(Object.keys(attributes)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_1 = _d.value;\n\n          if (name_1 !== 'id' || keepIds) {\n            node.attributes.set(name_1, attributes[name_1]);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    if (this.childNodes && this.childNodes.length) {\n      var children = this.childNodes;\n\n      if (children.length === 1 && children[0].isInferred) {\n        children = children[0].childNodes;\n      }\n\n      try {\n        for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {\n          var child = children_1_1.value;\n\n          if (child) {\n            node.appendChild(child.copy());\n          } else {\n            node.childNodes.push(null);\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (children_1_1 && !children_1_1.done && (_b = children_1.return)) _b.call(children_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n\n    return node;\n  };\n\n  Object.defineProperty(AbstractMmlNode.prototype, \"texClass\", {\n    get: function () {\n      return this.texclass;\n    },\n    set: function (texClass) {\n      this.texclass = texClass;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"isToken\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"isEmbellished\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"isSpacelike\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"linebreakContainer\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"hasNewLine\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"arity\", {\n    get: function () {\n      return Infinity;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"isInferred\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"Parent\", {\n    get: function () {\n      var parent = this.parent;\n\n      while (parent && parent.notParent) {\n        parent = parent.Parent;\n      }\n\n      return parent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"notParent\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractMmlNode.prototype.setChildren = function (children) {\n    if (this.arity < 0) {\n      return this.childNodes[0].setChildren(children);\n    }\n\n    return _super.prototype.setChildren.call(this, children);\n  };\n\n  AbstractMmlNode.prototype.appendChild = function (child) {\n    var e_3, _a;\n\n    var _this = this;\n\n    if (this.arity < 0) {\n      this.childNodes[0].appendChild(child);\n      return child;\n    }\n\n    if (child.isInferred) {\n      if (this.arity === Infinity) {\n        child.childNodes.forEach(function (node) {\n          return _super.prototype.appendChild.call(_this, node);\n        });\n        return child;\n      }\n\n      var original = child;\n      child = this.factory.create('mrow');\n      child.setChildren(original.childNodes);\n      child.attributes = original.attributes;\n\n      try {\n        for (var _b = __values(original.getPropertyNames()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var name_2 = _c.value;\n          child.setProperty(name_2, original.getProperty(name_2));\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    }\n\n    return _super.prototype.appendChild.call(this, child);\n  };\n\n  AbstractMmlNode.prototype.replaceChild = function (newChild, oldChild) {\n    if (this.arity < 0) {\n      this.childNodes[0].replaceChild(newChild, oldChild);\n      return newChild;\n    }\n\n    return _super.prototype.replaceChild.call(this, newChild, oldChild);\n  };\n\n  AbstractMmlNode.prototype.core = function () {\n    return this;\n  };\n\n  AbstractMmlNode.prototype.coreMO = function () {\n    return this;\n  };\n\n  AbstractMmlNode.prototype.coreIndex = function () {\n    return 0;\n  };\n\n  AbstractMmlNode.prototype.childPosition = function () {\n    var e_4, _a;\n\n    var child = this;\n    var parent = child.parent;\n\n    while (parent && parent.notParent) {\n      child = parent;\n      parent = parent.parent;\n    }\n\n    if (parent) {\n      var i = 0;\n\n      try {\n        for (var _b = __values(parent.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var node = _c.value;\n\n          if (node === child) {\n            return i;\n          }\n\n          i++;\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  AbstractMmlNode.prototype.setTeXclass = function (prev) {\n    this.getPrevClass(prev);\n    return this.texClass != null ? this : prev;\n  };\n\n  AbstractMmlNode.prototype.updateTeXclass = function (core) {\n    if (core) {\n      this.prevClass = core.prevClass;\n      this.prevLevel = core.prevLevel;\n      core.prevClass = core.prevLevel = null;\n      this.texClass = core.texClass;\n    }\n  };\n\n  AbstractMmlNode.prototype.getPrevClass = function (prev) {\n    if (prev) {\n      this.prevClass = prev.texClass;\n      this.prevLevel = prev.attributes.get('scriptlevel');\n    }\n  };\n\n  AbstractMmlNode.prototype.texSpacing = function () {\n    var prevClass = this.prevClass != null ? this.prevClass : exports.TEXCLASS.NONE;\n    var texClass = this.texClass || exports.TEXCLASS.ORD;\n\n    if (prevClass === exports.TEXCLASS.NONE || texClass === exports.TEXCLASS.NONE) {\n      return '';\n    }\n\n    if (prevClass === exports.TEXCLASS.VCENTER) {\n      prevClass = exports.TEXCLASS.ORD;\n    }\n\n    if (texClass === exports.TEXCLASS.VCENTER) {\n      texClass = exports.TEXCLASS.ORD;\n    }\n\n    var space = TEXSPACE[prevClass][texClass];\n\n    if ((this.prevLevel > 0 || this.attributes.get('scriptlevel') > 0) && space >= 0) {\n      return '';\n    }\n\n    return TEXSPACELENGTH[Math.abs(space)];\n  };\n\n  AbstractMmlNode.prototype.hasSpacingAttributes = function () {\n    return this.isEmbellished && this.coreMO().hasSpacingAttributes();\n  };\n\n  AbstractMmlNode.prototype.setInheritedAttributes = function (attributes, display, level, prime) {\n    var e_5, _a;\n\n    if (attributes === void 0) {\n      attributes = {};\n    }\n\n    if (display === void 0) {\n      display = false;\n    }\n\n    if (level === void 0) {\n      level = 0;\n    }\n\n    if (prime === void 0) {\n      prime = false;\n    }\n\n    var defaults = this.attributes.getAllDefaults();\n\n    try {\n      for (var _b = __values(Object.keys(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n\n        if (defaults.hasOwnProperty(key) || AbstractMmlNode.alwaysInherit.hasOwnProperty(key)) {\n          var _d = __read(attributes[key], 2),\n              node = _d[0],\n              value = _d[1];\n\n          var noinherit = (AbstractMmlNode.noInherit[node] || {})[this.kind] || {};\n\n          if (!noinherit[key]) {\n            this.attributes.setInherited(key, value);\n          }\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    var displaystyle = this.attributes.getExplicit('displaystyle');\n\n    if (displaystyle === undefined) {\n      this.attributes.setInherited('displaystyle', display);\n    }\n\n    var scriptlevel = this.attributes.getExplicit('scriptlevel');\n\n    if (scriptlevel === undefined) {\n      this.attributes.setInherited('scriptlevel', level);\n    }\n\n    if (prime) {\n      this.setProperty('texprimestyle', prime);\n    }\n\n    var arity = this.arity;\n\n    if (arity >= 0 && arity !== Infinity && (arity === 1 && this.childNodes.length === 0 || arity !== 1 && this.childNodes.length !== arity)) {\n      if (arity < this.childNodes.length) {\n        this.childNodes = this.childNodes.slice(0, arity);\n      } else {\n        while (this.childNodes.length < arity) {\n          this.appendChild(this.factory.create('mrow'));\n        }\n      }\n    }\n\n    this.setChildInheritedAttributes(attributes, display, level, prime);\n  };\n\n  AbstractMmlNode.prototype.setChildInheritedAttributes = function (attributes, display, level, prime) {\n    var e_6, _a;\n\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n        child.setInheritedAttributes(attributes, display, level, prime);\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n  };\n\n  AbstractMmlNode.prototype.addInheritedAttributes = function (current, attributes) {\n    var e_7, _a;\n\n    var updated = __assign({}, current);\n\n    try {\n      for (var _b = __values(Object.keys(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var name_3 = _c.value;\n\n        if (name_3 !== 'displaystyle' && name_3 !== 'scriptlevel' && name_3 !== 'style') {\n          updated[name_3] = [this.kind, attributes[name_3]];\n        }\n      }\n    } catch (e_7_1) {\n      e_7 = {\n        error: e_7_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_7) throw e_7.error;\n      }\n    }\n\n    return updated;\n  };\n\n  AbstractMmlNode.prototype.inheritAttributesFrom = function (node) {\n    var attributes = node.attributes;\n    var display = attributes.get('displaystyle');\n    var scriptlevel = attributes.get('scriptlevel');\n    var defaults = !attributes.isSet('mathsize') ? {} : {\n      mathsize: ['math', attributes.get('mathsize')]\n    };\n    var prime = node.getProperty('texprimestyle') || false;\n    this.setInheritedAttributes(defaults, display, scriptlevel, prime);\n  };\n\n  AbstractMmlNode.prototype.verifyTree = function (options) {\n    if (options === void 0) {\n      options = null;\n    }\n\n    if (options === null) {\n      return;\n    }\n\n    this.verifyAttributes(options);\n    var arity = this.arity;\n\n    if (options['checkArity']) {\n      if (arity >= 0 && arity !== Infinity && (arity === 1 && this.childNodes.length === 0 || arity !== 1 && this.childNodes.length !== arity)) {\n        this.mError('Wrong number of children for \"' + this.kind + '\" node', options, true);\n      }\n    }\n\n    this.verifyChildren(options);\n  };\n\n  AbstractMmlNode.prototype.verifyAttributes = function (options) {\n    var e_8, _a;\n\n    if (options['checkAttributes']) {\n      var attributes = this.attributes;\n      var bad = [];\n\n      try {\n        for (var _b = __values(attributes.getExplicitNames()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var name_4 = _c.value;\n\n          if (name_4.substr(0, 5) !== 'data-' && attributes.getDefault(name_4) === undefined && !name_4.match(/^(?:class|style|id|(?:xlink:)?href)$/)) {\n            bad.push(name_4);\n          }\n        }\n      } catch (e_8_1) {\n        e_8 = {\n          error: e_8_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_8) throw e_8.error;\n        }\n      }\n\n      if (bad.length) {\n        this.mError('Unknown attributes for ' + this.kind + ' node: ' + bad.join(', '), options);\n      }\n    }\n  };\n\n  AbstractMmlNode.prototype.verifyChildren = function (options) {\n    var e_9, _a;\n\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n        child.verifyTree(options);\n      }\n    } catch (e_9_1) {\n      e_9 = {\n        error: e_9_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_9) throw e_9.error;\n      }\n    }\n  };\n\n  AbstractMmlNode.prototype.mError = function (message, options, short) {\n    if (short === void 0) {\n      short = false;\n    }\n\n    if (this.parent && this.parent.isKind('merror')) {\n      return null;\n    }\n\n    var merror = this.factory.create('merror');\n\n    if (options['fullErrors'] || short) {\n      var mtext = this.factory.create('mtext');\n      var text = this.factory.create('text');\n      text.setText(options['fullErrors'] ? message : this.kind);\n      mtext.appendChild(text);\n      merror.appendChild(mtext);\n      this.parent.replaceChild(merror, this);\n    } else {\n      this.parent.replaceChild(merror, this);\n      merror.appendChild(this);\n    }\n\n    return merror;\n  };\n\n  AbstractMmlNode.defaults = {\n    mathbackground: Attributes_js_1.INHERIT,\n    mathcolor: Attributes_js_1.INHERIT,\n    mathsize: Attributes_js_1.INHERIT,\n    dir: Attributes_js_1.INHERIT\n  };\n  AbstractMmlNode.noInherit = {\n    mstyle: {\n      mpadded: {\n        width: true,\n        height: true,\n        depth: true,\n        lspace: true,\n        voffset: true\n      },\n      mtable: {\n        width: true,\n        height: true,\n        depth: true,\n        align: true\n      }\n    },\n    maligngroup: {\n      mrow: {\n        groupalign: true\n      },\n      mtable: {\n        groupalign: true\n      }\n    }\n  };\n  AbstractMmlNode.alwaysInherit = {\n    scriptminsize: true,\n    scriptsizemultiplier: true\n  };\n  AbstractMmlNode.verifyDefaults = {\n    checkArity: true,\n    checkAttributes: false,\n    fullErrors: false,\n    fixMmultiscripts: true,\n    fixMtables: true\n  };\n  return AbstractMmlNode;\n}(Node_js_1.AbstractNode);\n\nexports.AbstractMmlNode = AbstractMmlNode;\n\nvar AbstractMmlTokenNode = function (_super) {\n  __extends(AbstractMmlTokenNode, _super);\n\n  function AbstractMmlTokenNode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(AbstractMmlTokenNode.prototype, \"isToken\", {\n    get: function () {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractMmlTokenNode.prototype.getText = function () {\n    var e_10, _a;\n\n    var text = '';\n\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n\n        if (child instanceof TextNode) {\n          text += child.getText();\n        }\n      }\n    } catch (e_10_1) {\n      e_10 = {\n        error: e_10_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_10) throw e_10.error;\n      }\n    }\n\n    return text;\n  };\n\n  AbstractMmlTokenNode.prototype.setChildInheritedAttributes = function (attributes, display, level, prime) {\n    var e_11, _a;\n\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n\n        if (child instanceof AbstractMmlNode) {\n          child.setInheritedAttributes(attributes, display, level, prime);\n        }\n      }\n    } catch (e_11_1) {\n      e_11 = {\n        error: e_11_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_11) throw e_11.error;\n      }\n    }\n  };\n\n  AbstractMmlTokenNode.prototype.walkTree = function (func, data) {\n    var e_12, _a;\n\n    func(this, data);\n\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n\n        if (child instanceof AbstractMmlNode) {\n          child.walkTree(func, data);\n        }\n      }\n    } catch (e_12_1) {\n      e_12 = {\n        error: e_12_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_12) throw e_12.error;\n      }\n    }\n\n    return data;\n  };\n\n  AbstractMmlTokenNode.defaults = __assign(__assign({}, AbstractMmlNode.defaults), {\n    mathvariant: 'normal',\n    mathsize: Attributes_js_1.INHERIT\n  });\n  return AbstractMmlTokenNode;\n}(AbstractMmlNode);\n\nexports.AbstractMmlTokenNode = AbstractMmlTokenNode;\n\nvar AbstractMmlLayoutNode = function (_super) {\n  __extends(AbstractMmlLayoutNode, _super);\n\n  function AbstractMmlLayoutNode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(AbstractMmlLayoutNode.prototype, \"isSpacelike\", {\n    get: function () {\n      return this.childNodes[0].isSpacelike;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlLayoutNode.prototype, \"isEmbellished\", {\n    get: function () {\n      return this.childNodes[0].isEmbellished;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlLayoutNode.prototype, \"arity\", {\n    get: function () {\n      return -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractMmlLayoutNode.prototype.core = function () {\n    return this.childNodes[0];\n  };\n\n  AbstractMmlLayoutNode.prototype.coreMO = function () {\n    return this.childNodes[0].coreMO();\n  };\n\n  AbstractMmlLayoutNode.prototype.setTeXclass = function (prev) {\n    prev = this.childNodes[0].setTeXclass(prev);\n    this.updateTeXclass(this.childNodes[0]);\n    return prev;\n  };\n\n  AbstractMmlLayoutNode.defaults = AbstractMmlNode.defaults;\n  return AbstractMmlLayoutNode;\n}(AbstractMmlNode);\n\nexports.AbstractMmlLayoutNode = AbstractMmlLayoutNode;\n\nvar AbstractMmlBaseNode = function (_super) {\n  __extends(AbstractMmlBaseNode, _super);\n\n  function AbstractMmlBaseNode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(AbstractMmlBaseNode.prototype, \"isEmbellished\", {\n    get: function () {\n      return this.childNodes[0].isEmbellished;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractMmlBaseNode.prototype.core = function () {\n    return this.childNodes[0];\n  };\n\n  AbstractMmlBaseNode.prototype.coreMO = function () {\n    return this.childNodes[0].coreMO();\n  };\n\n  AbstractMmlBaseNode.prototype.setTeXclass = function (prev) {\n    var e_13, _a;\n\n    this.getPrevClass(prev);\n    this.texClass = exports.TEXCLASS.ORD;\n    var base = this.childNodes[0];\n\n    if (base) {\n      if (this.isEmbellished || base.isKind('mi')) {\n        prev = base.setTeXclass(prev);\n        this.updateTeXclass(this.core());\n      } else {\n        base.setTeXclass(null);\n        prev = this;\n      }\n    } else {\n      prev = this;\n    }\n\n    try {\n      for (var _b = __values(this.childNodes.slice(1)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n\n        if (child) {\n          child.setTeXclass(null);\n        }\n      }\n    } catch (e_13_1) {\n      e_13 = {\n        error: e_13_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_13) throw e_13.error;\n      }\n    }\n\n    return prev;\n  };\n\n  AbstractMmlBaseNode.defaults = AbstractMmlNode.defaults;\n  return AbstractMmlBaseNode;\n}(AbstractMmlNode);\n\nexports.AbstractMmlBaseNode = AbstractMmlBaseNode;\n\nvar AbstractMmlEmptyNode = function (_super) {\n  __extends(AbstractMmlEmptyNode, _super);\n\n  function AbstractMmlEmptyNode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"isToken\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"isEmbellished\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"isSpacelike\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"linebreakContainer\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"hasNewLine\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"arity\", {\n    get: function () {\n      return 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"isInferred\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"notParent\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"Parent\", {\n    get: function () {\n      return this.parent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"texClass\", {\n    get: function () {\n      return exports.TEXCLASS.NONE;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"prevClass\", {\n    get: function () {\n      return exports.TEXCLASS.NONE;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"prevLevel\", {\n    get: function () {\n      return 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractMmlEmptyNode.prototype.hasSpacingAttributes = function () {\n    return false;\n  };\n\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"attributes\", {\n    get: function () {\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractMmlEmptyNode.prototype.core = function () {\n    return this;\n  };\n\n  AbstractMmlEmptyNode.prototype.coreMO = function () {\n    return this;\n  };\n\n  AbstractMmlEmptyNode.prototype.coreIndex = function () {\n    return 0;\n  };\n\n  AbstractMmlEmptyNode.prototype.childPosition = function () {\n    return 0;\n  };\n\n  AbstractMmlEmptyNode.prototype.setTeXclass = function (prev) {\n    return prev;\n  };\n\n  AbstractMmlEmptyNode.prototype.texSpacing = function () {\n    return '';\n  };\n\n  AbstractMmlEmptyNode.prototype.setInheritedAttributes = function (_attributes, _display, _level, _prime) {};\n\n  AbstractMmlEmptyNode.prototype.inheritAttributesFrom = function (_node) {};\n\n  AbstractMmlEmptyNode.prototype.verifyTree = function (_options) {};\n\n  AbstractMmlEmptyNode.prototype.mError = function (_message, _options, _short) {\n    if (_short === void 0) {\n      _short = false;\n    }\n  };\n\n  return AbstractMmlEmptyNode;\n}(Node_js_1.AbstractEmptyNode);\n\nexports.AbstractMmlEmptyNode = AbstractMmlEmptyNode;\n\nvar TextNode = function (_super) {\n  __extends(TextNode, _super);\n\n  function TextNode() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.text = '';\n    return _this;\n  }\n\n  Object.defineProperty(TextNode.prototype, \"kind\", {\n    get: function () {\n      return 'text';\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  TextNode.prototype.getText = function () {\n    return this.text;\n  };\n\n  TextNode.prototype.setText = function (text) {\n    this.text = text;\n    return this;\n  };\n\n  TextNode.prototype.copy = function () {\n    return this.factory.create(this.kind).setText(this.getText());\n  };\n\n  TextNode.prototype.toString = function () {\n    return this.text;\n  };\n\n  return TextNode;\n}(AbstractMmlEmptyNode);\n\nexports.TextNode = TextNode;\n\nvar XMLNode = function (_super) {\n  __extends(XMLNode, _super);\n\n  function XMLNode() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.xml = null;\n    _this.adaptor = null;\n    return _this;\n  }\n\n  Object.defineProperty(XMLNode.prototype, \"kind\", {\n    get: function () {\n      return 'XML';\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  XMLNode.prototype.getXML = function () {\n    return this.xml;\n  };\n\n  XMLNode.prototype.setXML = function (xml, adaptor) {\n    if (adaptor === void 0) {\n      adaptor = null;\n    }\n\n    this.xml = xml;\n    this.adaptor = adaptor;\n    return this;\n  };\n\n  XMLNode.prototype.getSerializedXML = function () {\n    return this.adaptor.serializeXML(this.xml);\n  };\n\n  XMLNode.prototype.copy = function () {\n    return this.factory.create(this.kind).setXML(this.adaptor.clone(this.xml));\n  };\n\n  XMLNode.prototype.toString = function () {\n    return 'XML data';\n  };\n\n  return XMLNode;\n}(AbstractMmlEmptyNode);\n\nexports.XMLNode = XMLNode;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;;AACA;;AAYaA,mBAAW;AACtBC,KAAG,EAAI,CADe;AAEtBC,IAAE,EAAK,CAFe;AAGtBC,KAAG,EAAI,CAHe;AAItBC,KAAG,EAAI,CAJe;AAKtBC,MAAI,EAAG,CALe;AAMtBC,OAAK,EAAE,CANe;AAOtBC,OAAK,EAAE,CAPe;AAQtBC,OAAK,EAAE,CARe;AAStBC,SAAO,EAAE,CATa;AAUtBC,MAAI,EAAI,CAAC;AAVa,CAAX;AAaAV,wBAAgB,CAAC,KAAD,EAAQ,IAAR,EAAc,KAAd,EAAqB,KAArB,EAA4B,MAA5B,EAAoC,OAApC,EAA6C,OAA7C,EAAsD,OAAtD,EAA+D,SAA/D,CAAhB;AAKb,IAAMW,cAAc,GAAG,CAAC,EAAD,EAAK,eAAL,EAAsB,iBAAtB,EAAyC,gBAAzC,CAAvB;AAKA,IAAMC,QAAQ,GAAG,CACf,CAAE,CAAF,EAAK,CAAC,CAAN,EAAU,CAAV,EAAc,CAAd,EAAkB,CAAlB,EAAsB,CAAtB,EAA0B,CAA1B,EAA8B,CAA9B,CADe,EAEf,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,EAAU,CAAV,EAAc,CAAd,EAAkB,CAAlB,EAAsB,CAAtB,EAA0B,CAA1B,EAA8B,CAA9B,CAFe,EAGf,CAAE,CAAF,EAAM,CAAN,EAAU,CAAV,EAAc,CAAd,EAAkB,CAAlB,EAAsB,CAAtB,EAA0B,CAA1B,EAA8B,CAA9B,CAHe,EAIf,CAAE,CAAF,EAAM,CAAN,EAAU,CAAV,EAAc,CAAd,EAAkB,CAAlB,EAAsB,CAAtB,EAA0B,CAA1B,EAA8B,CAA9B,CAJe,EAKf,CAAE,CAAF,EAAM,CAAN,EAAU,CAAV,EAAc,CAAd,EAAkB,CAAlB,EAAsB,CAAtB,EAA0B,CAA1B,EAA8B,CAA9B,CALe,EAMf,CAAE,CAAF,EAAK,CAAC,CAAN,EAAU,CAAV,EAAc,CAAd,EAAkB,CAAlB,EAAsB,CAAtB,EAA0B,CAA1B,EAA8B,CAA9B,CANe,EAOf,CAAE,CAAF,EAAM,CAAN,EAAU,CAAV,EAAc,CAAd,EAAkB,CAAlB,EAAsB,CAAtB,EAA0B,CAA1B,EAA8B,CAA9B,CAPe,EAQf,CAAE,CAAF,EAAK,CAAC,CAAN,EAAU,CAAV,EAAc,CAAd,EAAkB,CAAlB,EAAsB,CAAtB,EAA0B,CAA1B,EAA8B,CAA9B,CARe,CAAjB;AAcaZ,2BAAmB,CAC9B,aAD8B,EACf,kBADe,EAE9B,aAF8B,EAEf,kBAFe,CAAnB;;AAuKb;AAA8Ca;;AAoG5C,2BAAYC,OAAZ,EAAiCC,UAAjC,EAAgEC,QAAhE,EAAwF;AAAvD;AAAAD;AAA6B;;AAAE;AAAAC;AAAwB;;AAAxF,gBACEC,kBAAMH,OAAN,KAAc,IADhB;;AAxCOI,sBAAoB,IAApB;AAKAA,sBAAoB,IAApB;AAyBGA,qBAAmB,IAAnB;;AAYR,QAAIA,KAAI,CAACC,KAAL,GAAa,CAAjB,EAAoB;AAClBD,WAAI,CAACE,UAAL,GAAkB,CAACN,OAAO,CAACO,MAAR,CAAe,cAAf,CAAD,CAAlB;AACAH,WAAI,CAACE,UAAL,CAAgB,CAAhB,EAAmBE,MAAnB,GAA4BJ,KAA5B;AACD;;AACDA,SAAI,CAACK,WAAL,CAAiBP,QAAjB;;AACAE,SAAI,CAACH,UAAL,GAAkB,IAAIS,0BAAJ,CAChBV,OAAO,CAACW,YAAR,CAAqBP,KAAI,CAACQ,IAA1B,EAAgCC,QADhB,EAEhBb,OAAO,CAACW,YAAR,CAAqB,MAArB,EAA6BE,QAFb,CAAlB;;AAIAT,SAAI,CAACH,UAAL,CAAgBa,OAAhB,CAAwBb,UAAxB;;;AACD;;AASMc,mCAAP,UAAYC,OAAZ,EAAoC;;;AAAxB;AAAAA;AAAwB;;AAClC,QAAMC,IAAI,GAAG,KAAKjB,OAAL,CAAaO,MAAb,CAAoB,KAAKK,IAAzB,CAAb;AACAK,QAAI,CAACC,UAAL,GAAeC,aAAO,KAAKD,UAAZ,CAAf;;AACA,QAAI,KAAKjB,UAAT,EAAqB;AACnB,UAAMA,UAAU,GAAG,KAAKA,UAAL,CAAgBmB,gBAAhB,EAAnB;;;AACA,aAAmB,wBAAM,CAACC,IAAP,CAAYpB,UAAZ,IAAuBqB,cAA1C,EAA0C,QAA1C,EAA0CA,cAA1C,EAA4C;AAAvC,cAAMC,MAAI,WAAV;;AACH,cAAIA,MAAI,KAAK,IAAT,IAAiBP,OAArB,EAA8B;AAC5BC,gBAAI,CAAChB,UAAL,CAAgBuB,GAAhB,CAAoBD,MAApB,EAA0BtB,UAAU,CAACsB,MAAD,CAApC;AACD;AACF;;;;;;;;;;;;AACF;;AACD,QAAI,KAAKjB,UAAL,IAAmB,KAAKA,UAAL,CAAgBmB,MAAvC,EAA+C;AAC7C,UAAIvB,QAAQ,GAAG,KAAKI,UAApB;;AACA,UAAIJ,QAAQ,CAACuB,MAAT,KAAoB,CAApB,IAAyBvB,QAAQ,CAAC,CAAD,CAAR,CAAYwB,UAAzC,EAAqD;AACnDxB,gBAAQ,GAAGA,QAAQ,CAAC,CAAD,CAAR,CAAYI,UAAvB;AACD;;;AACD,aAAoB,qCAAQqB,gCAA5B,EAA4B,kBAA5B,EAA4BA,gCAA5B,EAA8B;AAAzB,cAAMC,KAAK,qBAAX;;AACH,cAAIA,KAAJ,EAAW;AACTX,gBAAI,CAACY,WAAL,CAAiBD,KAAK,CAACE,IAAN,EAAjB;AACD,WAFD,MAEO;AACLb,gBAAI,CAACX,UAAL,CAAgByB,IAAhB,CAAqB,IAArB;AACD;AACF;;;;;;;;;;;;AACF;;AACD,WAAOd,IAAP;AACD,GAzBM;;AA8BPe,wBAAWjB,yBAAX,EAAW,UAAX,EAAmB;SAAnB;AACE,aAAO,KAAKkB,QAAZ;AACD,KAFkB;SAOnB,UAAoBC,QAApB,EAAoC;AAClC,WAAKD,QAAL,GAAgBC,QAAhB;AACD,KATkB;qBAAA;;AAAA,GAAnB;AAcAF,wBAAWjB,yBAAX,EAAW,SAAX,EAAkB;SAAlB;AACE,aAAO,KAAP;AACD,KAFiB;qBAAA;;AAAA,GAAlB;AAOAiB,wBAAWjB,yBAAX,EAAW,eAAX,EAAwB;SAAxB;AACE,aAAO,KAAP;AACD,KAFuB;qBAAA;;AAAA,GAAxB;AAOAiB,wBAAWjB,yBAAX,EAAW,aAAX,EAAsB;SAAtB;AACE,aAAO,KAAP;AACD,KAFqB;qBAAA;;AAAA,GAAtB;AAOAiB,wBAAWjB,yBAAX,EAAW,oBAAX,EAA6B;SAA7B;AACE,aAAO,KAAP;AACD,KAF4B;qBAAA;;AAAA,GAA7B;AAOAiB,wBAAWjB,yBAAX,EAAW,YAAX,EAAqB;SAArB;AACE,aAAO,KAAP;AACD,KAFoB;qBAAA;;AAAA,GAArB;AAUAiB,wBAAWjB,yBAAX,EAAW,OAAX,EAAgB;SAAhB;AACE,aAAOoB,QAAP;AACD,KAFe;qBAAA;;AAAA,GAAhB;AAOAH,wBAAWjB,yBAAX,EAAW,YAAX,EAAqB;SAArB;AACE,aAAO,KAAP;AACD,KAFoB;qBAAA;;AAAA,GAArB;AAQAiB,wBAAWjB,yBAAX,EAAW,QAAX,EAAiB;SAAjB;AACE,UAAIP,MAAM,GAAG,KAAKA,MAAlB;;AACA,aAAOA,MAAM,IAAIA,MAAM,CAAC4B,SAAxB,EAAmC;AACjC5B,cAAM,GAAGA,MAAM,CAAC6B,MAAhB;AACD;;AACD,aAAO7B,MAAP;AACD,KANgB;qBAAA;;AAAA,GAAjB;AAWAwB,wBAAWjB,yBAAX,EAAW,WAAX,EAAoB;SAApB;AACE,aAAO,KAAP;AACD,KAFmB;qBAAA;;AAAA,GAApB;;AASOA,0CAAP,UAAmBb,QAAnB,EAAsC;AACpC,QAAI,KAAKG,KAAL,GAAa,CAAjB,EAAoB;AAClB,aAAO,KAAKC,UAAL,CAAgB,CAAhB,EAAmBG,WAAnB,CAA+BP,QAA/B,CAAP;AACD;;AACD,WAAOC,iBAAMM,WAAN,CAAiB6B,IAAjB,CAAiB,IAAjB,EAAkBpC,QAAlB,CAAP;AACD,GALM;;AAYAa,0CAAP,UAAmBa,KAAnB,EAAiC;;;AAAjC;;AACE,QAAI,KAAKvB,KAAL,GAAa,CAAjB,EAAoB;AAClB,WAAKC,UAAL,CAAgB,CAAhB,EAAmBuB,WAAnB,CAA+BD,KAA/B;AACA,aAAOA,KAAP;AACD;;AACD,QAAIA,KAAK,CAACF,UAAV,EAAsB;AAKpB,UAAI,KAAKrB,KAAL,KAAe8B,QAAnB,EAA6B;AAC3BP,aAAK,CAACtB,UAAN,CAAiBiC,OAAjB,CAAyB,UAACtB,IAAD,EAAK;AAAK,kCAAMY,WAAN,CAAiBS,IAAjB,CAAiBlC,KAAjB,EAAkBa,IAAlB;AAAuB,SAA1D;AACA,eAAOW,KAAP;AACD;;AAID,UAAMY,QAAQ,GAAGZ,KAAjB;AACAA,WAAK,GAAG,KAAK5B,OAAL,CAAaO,MAAb,CAAoB,MAApB,CAAR;AACAqB,WAAK,CAACnB,WAAN,CAAkB+B,QAAQ,CAAClC,UAA3B;AACAsB,WAAK,CAAC3B,UAAN,GAAmBuC,QAAQ,CAACvC,UAA5B;;;AACA,aAAmB,0BAAQ,CAACwC,gBAAT,KAA2BC,cAA9C,EAA8C,QAA9C,EAA8CA,cAA9C,EAAgD;AAA3C,cAAMC,MAAI,WAAV;AACHf,eAAK,CAACgB,WAAN,CAAkBD,MAAlB,EAAwBH,QAAQ,CAACK,WAAT,CAAqBF,MAArB,CAAxB;AACD;;;;;;;;;;;;AACF;;AACD,WAAOxC,iBAAM0B,WAAN,CAAiBS,IAAjB,CAAiB,IAAjB,EAAkBV,KAAlB,CAAP;AACD,GA1BM;;AAgCAb,2CAAP,UAAoB+B,QAApB,EAAuCC,QAAvC,EAAwD;AACtD,QAAI,KAAK1C,KAAL,GAAa,CAAjB,EAAoB;AAClB,WAAKC,UAAL,CAAgB,CAAhB,EAAmB0C,YAAnB,CAAgCF,QAAhC,EAA0CC,QAA1C;AACA,aAAOD,QAAP;AACD;;AACD,WAAO3C,iBAAM6C,YAAN,CAAkBV,IAAlB,CAAkB,IAAlB,EAAmBQ,QAAnB,EAA6BC,QAA7B,CAAP;AACD,GANM;;AAWAhC,mCAAP;AACE,WAAO,IAAP;AACD,GAFM;;AAOAA,qCAAP;AACE,WAAO,IAAP;AACD,GAFM;;AAOAA,wCAAP;AACE,WAAO,CAAP;AACD,GAFM;;AAOAA,4CAAP;;;AACE,QAAIa,KAAK,GAAY,IAArB;AACA,QAAIpB,MAAM,GAAGoB,KAAK,CAACpB,MAAnB;;AACA,WAAOA,MAAM,IAAIA,MAAM,CAAC4B,SAAxB,EAAmC;AACjCR,WAAK,GAAGpB,MAAR;AACAA,YAAM,GAAGA,MAAM,CAACA,MAAhB;AACD;;AACD,QAAIA,MAAJ,EAAY;AACV,UAAIyC,CAAC,GAAG,CAAR;;;AACA,aAAmB,wBAAM,CAAC3C,UAAP,GAAiBoC,cAApC,EAAoC,QAApC,EAAoCA,cAApC,EAAsC;AAAjC,cAAMzB,IAAI,WAAV;;AACH,cAAIA,IAAI,KAAKW,KAAb,EAAoB;AAClB,mBAAOqB,CAAP;AACD;;AACDA,WAAC;AACF;;;;;;;;;;;;AACF;;AACD,WAAO,IAAP;AACD,GAjBM;;AAsBAlC,0CAAP,UAAmBmC,IAAnB,EAAgC;AAC9B,SAAKC,YAAL,CAAkBD,IAAlB;AACA,WAAQ,KAAKhB,QAAL,IAAiB,IAAjB,GAAwB,IAAxB,GAA+BgB,IAAvC;AACD,GAHM;;AASGnC,6CAAV,UAAyBqC,IAAzB,EAAsC;AACpC,QAAIA,IAAJ,EAAU;AACR,WAAKC,SAAL,GAAiBD,IAAI,CAACC,SAAtB;AACA,WAAKC,SAAL,GAAiBF,IAAI,CAACE,SAAtB;AACAF,UAAI,CAACC,SAAL,GAAiBD,IAAI,CAACE,SAAL,GAAiB,IAAlC;AACA,WAAKpB,QAAL,GAAgBkB,IAAI,CAAClB,QAArB;AACD;AACF,GAPS;;AAaAnB,2CAAV,UAAuBmC,IAAvB,EAAoC;AAClC,QAAIA,IAAJ,EAAU;AACR,WAAKG,SAAL,GAAiBH,IAAI,CAAChB,QAAtB;AACA,WAAKoB,SAAL,GAAiBJ,IAAI,CAACjD,UAAL,CAAgBsD,GAAhB,CAAoB,aAApB,CAAjB;AACD;AACF,GALS;;AAUHxC,yCAAP;AACE,QAAIsC,SAAS,GAAI,KAAKA,SAAL,IAAkB,IAAlB,GAAyB,KAAKA,SAA9B,GAA0CnE,iBAASU,IAApE;AACA,QAAIsC,QAAQ,GAAG,KAAKA,QAAL,IAAiBhD,iBAASC,GAAzC;;AACA,QAAIkE,SAAS,KAAKnE,iBAASU,IAAvB,IAA+BsC,QAAQ,KAAKhD,iBAASU,IAAzD,EAA+D;AAC7D,aAAO,EAAP;AACD;;AACD,QAAIyD,SAAS,KAAKnE,iBAASS,OAA3B,EAAoC;AAClC0D,eAAS,GAAGnE,iBAASC,GAArB;AACD;;AACD,QAAI+C,QAAQ,KAAKhD,iBAASS,OAA1B,EAAmC;AACjCuC,cAAQ,GAAGhD,iBAASC,GAApB;AACD;;AACD,QAAIqE,KAAK,GAAG1D,QAAQ,CAACuD,SAAD,CAAR,CAAoBnB,QAApB,CAAZ;;AACA,QAAI,CAAC,KAAKoB,SAAL,GAAiB,CAAjB,IAAsB,KAAKrD,UAAL,CAAgBsD,GAAhB,CAAoB,aAApB,IAAqC,CAA5D,KAAkEC,KAAK,IAAI,CAA/E,EAAkF;AAChF,aAAO,EAAP;AACD;;AACD,WAAO3D,cAAc,CAAC4D,IAAI,CAACC,GAAL,CAASF,KAAT,CAAD,CAArB;AACD,GAjBM;;AAsBAzC,mDAAP;AACE,WAAO,KAAK4C,aAAL,IAAsB,KAAKC,MAAL,GAAcC,oBAAd,EAA7B;AACD,GAFM;;AAkBA9C,qDAAP,UAA8Bd,UAA9B,EAC8B6D,OAD9B,EACwDC,KADxD,EAC2EC,KAD3E,EACiG;;;AADnE;AAAA/D;AAA8B;;AAC9B;AAAA6D;AAAwB;;AAAE;AAAAC;AAAiB;;AAAE;AAAAC;AAAsB;;AAC/F,QAAInD,QAAQ,GAAG,KAAKZ,UAAL,CAAgBgE,cAAhB,EAAf;;;AACA,WAAkB,wBAAM,CAAC5C,IAAP,CAAYpB,UAAZ,IAAuByC,cAAzC,EAAyC,QAAzC,EAAyCA,cAAzC,EAA2C;AAAtC,YAAMwB,GAAG,WAAT;;AACH,YAAIrD,QAAQ,CAACsD,cAAT,CAAwBD,GAAxB,KAAgCnD,eAAe,CAACqD,aAAhB,CAA8BD,cAA9B,CAA6CD,GAA7C,CAApC,EAAuF;AACjF,0BAAgBjE,UAAU,CAACiE,GAAD,CAA1B,EAA+B,CAA/B;AAAA,cAACjD,IAAI,QAAL;AAAA,cAAOoD,KAAK,QAAZ;;AACJ,cAAIC,SAAS,GAAG,CAACvD,eAAe,CAACwD,SAAhB,CAA0BtD,IAA1B,KAAmC,EAApC,EAAwC,KAAKL,IAA7C,KAAsD,EAAtE;;AACA,cAAI,CAAC0D,SAAS,CAACJ,GAAD,CAAd,EAAqB;AACnB,iBAAKjE,UAAL,CAAgBuE,YAAhB,CAA6BN,GAA7B,EAAkCG,KAAlC;AACD;AACF;AACF;;;;;;;;;;;;;AACD,QAAII,YAAY,GAAG,KAAKxE,UAAL,CAAgByE,WAAhB,CAA4B,cAA5B,CAAnB;;AACA,QAAID,YAAY,KAAKE,SAArB,EAAgC;AAC9B,WAAK1E,UAAL,CAAgBuE,YAAhB,CAA6B,cAA7B,EAA6CV,OAA7C;AACD;;AACD,QAAIc,WAAW,GAAG,KAAK3E,UAAL,CAAgByE,WAAhB,CAA4B,aAA5B,CAAlB;;AACA,QAAIE,WAAW,KAAKD,SAApB,EAA+B;AAC7B,WAAK1E,UAAL,CAAgBuE,YAAhB,CAA6B,aAA7B,EAA4CT,KAA5C;AACD;;AACD,QAAIC,KAAJ,EAAW;AACT,WAAKpB,WAAL,CAAiB,eAAjB,EAAkCoB,KAAlC;AACD;;AACD,QAAI3D,KAAK,GAAG,KAAKA,KAAjB;;AACA,QAAIA,KAAK,IAAI,CAAT,IAAcA,KAAK,KAAK8B,QAAxB,KAAsC9B,KAAK,KAAK,CAAV,IAAe,KAAKC,UAAL,CAAgBmB,MAAhB,KAA2B,CAA3C,IACCpB,KAAK,KAAK,CAAV,IAAe,KAAKC,UAAL,CAAgBmB,MAAhB,KAA2BpB,KADhF,CAAJ,EAC6F;AAK3F,UAAIA,KAAK,GAAG,KAAKC,UAAL,CAAgBmB,MAA5B,EAAoC;AAClC,aAAKnB,UAAL,GAAkB,KAAKA,UAAL,CAAgBuE,KAAhB,CAAsB,CAAtB,EAAyBxE,KAAzB,CAAlB;AACD,OAFD,MAEO;AACL,eAAO,KAAKC,UAAL,CAAgBmB,MAAhB,GAAyBpB,KAAhC,EAAuC;AACrC,eAAKwB,WAAL,CAAiB,KAAK7B,OAAL,CAAaO,MAAb,CAAoB,MAApB,CAAjB;AACD;AACF;AACF;;AACD,SAAKuE,2BAAL,CAAiC7E,UAAjC,EAA6C6D,OAA7C,EAAsDC,KAAtD,EAA6DC,KAA7D;AACD,GAvCM;;AAkDGjD,0DAAV,UAAsCd,UAAtC,EAAiE6D,OAAjE,EAAmFC,KAAnF,EAAkGC,KAAlG,EAAgH;;;;AAC9G,WAAoB,uBAAK1D,UAAL,GAAeoC,cAAnC,EAAmC,QAAnC,EAAmCA,cAAnC,EAAqC;AAAhC,YAAMd,KAAK,WAAX;AACHA,aAAK,CAACmD,sBAAN,CAA6B9E,UAA7B,EAAyC6D,OAAzC,EAAkDC,KAAlD,EAAyDC,KAAzD;AACD;;;;;;;;;;;;AACF,GAJS;;AAYAjD,qDAAV,UAAiCiE,OAAjC,EAAyD/E,UAAzD,EAAiF;;;AAC/E,QAAIgF,OAAO,gBAAsBD,OAAtB,CAAX;;;AACA,WAAmB,wBAAM,CAAC3D,IAAP,CAAYpB,UAAZ,IAAuByC,cAA1C,EAA0C,QAA1C,EAA0CA,cAA1C,EAA4C;AAAvC,YAAMwC,MAAI,WAAV;;AACH,YAAIA,MAAI,KAAK,cAAT,IAA2BA,MAAI,KAAK,aAApC,IAAqDA,MAAI,KAAK,OAAlE,EAA2E;AACzED,iBAAO,CAACC,MAAD,CAAP,GAAgB,CAAC,KAAKtE,IAAN,EAAYX,UAAU,CAACiF,MAAD,CAAtB,CAAhB;AACD;AACF;;;;;;;;;;;;;AACD,WAAOD,OAAP;AACD,GARS;;AAgBHlE,oDAAP,UAA6BE,IAA7B,EAA0C;AACxC,QAAMhB,UAAU,GAAGgB,IAAI,CAAChB,UAAxB;AACA,QAAM6D,OAAO,GAAG7D,UAAU,CAACsD,GAAX,CAAe,cAAf,CAAhB;AACA,QAAMqB,WAAW,GAAG3E,UAAU,CAACsD,GAAX,CAAe,aAAf,CAApB;AACA,QAAM1C,QAAQ,GAAmB,CAACZ,UAAU,CAACkF,KAAX,CAAiB,UAAjB,CAAD,GAAgC,EAAhC,GAAqC;AACpEC,cAAQ,EAAE,CAAC,MAAD,EAASnF,UAAU,CAACsD,GAAX,CAAe,UAAf,CAAT;AAD0D,KAAtE;AAGA,QAAMS,KAAK,GAAG/C,IAAI,CAAC4B,WAAL,CAAiB,eAAjB,KAAgD,KAA9D;AACA,SAAKkC,sBAAL,CAA4BlE,QAA5B,EAAsCiD,OAAtC,EAA+Cc,WAA/C,EAA4DZ,KAA5D;AACD,GATM;;AAiBAjD,yCAAP,UAAkBsE,OAAlB,EAA8C;AAA5B;AAAAA;AAA4B;;AAC5C,QAAIA,OAAO,KAAK,IAAhB,EAAsB;AACpB;AACD;;AACD,SAAKC,gBAAL,CAAsBD,OAAtB;AACA,QAAIhF,KAAK,GAAG,KAAKA,KAAjB;;AACA,QAAIgF,OAAO,CAAC,YAAD,CAAX,EAA2B;AACzB,UAAIhF,KAAK,IAAI,CAAT,IAAcA,KAAK,KAAK8B,QAAxB,KACE9B,KAAK,KAAK,CAAV,IAAe,KAAKC,UAAL,CAAgBmB,MAAhB,KAA2B,CAA3C,IACCpB,KAAK,KAAK,CAAV,IAAe,KAAKC,UAAL,CAAgBmB,MAAhB,KAA2BpB,KAF5C,CAAJ,EAEyD;AACvD,aAAKkF,MAAL,CAAY,mCAAmC,KAAK3E,IAAxC,GAA+C,QAA3D,EAAqEyE,OAArE,EAA8E,IAA9E;AACD;AACF;;AACD,SAAKG,cAAL,CAAoBH,OAApB;AACD,GAdM;;AAqBGtE,+CAAV,UAA2BsE,OAA3B,EAAgD;;;AAC9C,QAAIA,OAAO,CAAC,iBAAD,CAAX,EAAgC;AAC9B,UAAMpF,UAAU,GAAG,KAAKA,UAAxB;AACA,UAAMwF,GAAG,GAAG,EAAZ;;;AACA,aAAmB,4BAAU,CAACC,gBAAX,KAA6BhD,cAAhD,EAAgD,QAAhD,EAAgDA,cAAhD,EAAkD;AAA7C,cAAMiD,MAAI,WAAV;;AACH,cAAIA,MAAI,CAACC,MAAL,CAAY,CAAZ,EAAe,CAAf,MAAsB,OAAtB,IAAiC3F,UAAU,CAAC4F,UAAX,CAAsBF,MAAtB,MAAgChB,SAAjE,IACA,CAACgB,MAAI,CAACG,KAAL,CAAW,sCAAX,CADL,EACyD;AAEvDL,eAAG,CAAC1D,IAAJ,CAAS4D,MAAT;AACD;AAEF;;;;;;;;;;;;;AACD,UAAIF,GAAG,CAAChE,MAAR,EAAgB;AACd,aAAK8D,MAAL,CAAY,4BAA4B,KAAK3E,IAAjC,GAAwC,SAAxC,GAAoD6E,GAAG,CAACM,IAAJ,CAAS,IAAT,CAAhE,EAAgFV,OAAhF;AACD;AACF;AACF,GAhBS;;AAuBAtE,6CAAV,UAAyBsE,OAAzB,EAA8C;;;;AAC5C,WAAoB,uBAAK/E,UAAL,GAAeoC,cAAnC,EAAmC,QAAnC,EAAmCA,cAAnC,EAAqC;AAAhC,YAAMd,KAAK,WAAX;AACHA,aAAK,CAACoE,UAAN,CAAiBX,OAAjB;AACD;;;;;;;;;;;;AACF,GAJS;;AAaHtE,qCAAP,UAAckF,OAAd,EAA+BZ,OAA/B,EAAsDa,KAAtD,EAA4E;AAAtB;AAAAA;AAAsB;;AAC1E,QAAI,KAAK1F,MAAL,IAAe,KAAKA,MAAL,CAAY2F,MAAZ,CAAmB,QAAnB,CAAnB,EAAiD;AAC/C,aAAO,IAAP;AACD;;AACD,QAAIC,MAAM,GAAG,KAAKpG,OAAL,CAAaO,MAAb,CAAoB,QAApB,CAAb;;AACA,QAAI8E,OAAO,CAAC,YAAD,CAAP,IAAyBa,KAA7B,EAAoC;AAClC,UAAIG,KAAK,GAAG,KAAKrG,OAAL,CAAaO,MAAb,CAAoB,OAApB,CAAZ;AACA,UAAI+F,IAAI,GAAG,KAAKtG,OAAL,CAAaO,MAAb,CAAoB,MAApB,CAAX;AACA+F,UAAI,CAACC,OAAL,CAAalB,OAAO,CAAC,YAAD,CAAP,GAAwBY,OAAxB,GAAkC,KAAKrF,IAApD;AACAyF,WAAK,CAACxE,WAAN,CAAkByE,IAAlB;AACAF,YAAM,CAACvE,WAAP,CAAmBwE,KAAnB;AACA,WAAK7F,MAAL,CAAYwC,YAAZ,CAAyBoD,MAAzB,EAAiC,IAAjC;AACD,KAPD,MAOO;AACL,WAAK5F,MAAL,CAAYwC,YAAZ,CAAyBoD,MAAzB,EAAiC,IAAjC;AACAA,YAAM,CAACvE,WAAP,CAAmB,IAAnB;AACD;;AACD,WAAOuE,MAAP;AACD,GAjBM;;AA3iBOrF,6BAAyB;AACrCyF,kBAAc,EAAE9F,uBADqB;AAErC+F,aAAS,EAAE/F,uBAF0B;AAGrC0E,YAAQ,EAAE1E,uBAH2B;AAKrCgG,OAAG,EAAEhG;AALgC,GAAzB;AAgBAK,8BAAkF;AAC9F4F,UAAM,EAAE;AACNC,aAAO,EAAE;AAACC,aAAK,EAAE,IAAR;AAAcC,cAAM,EAAE,IAAtB;AAA4BC,aAAK,EAAE,IAAnC;AAAyCC,cAAM,EAAE,IAAjD;AAAuDC,eAAO,EAAE;AAAhE,OADH;AAENC,YAAM,EAAG;AAACL,aAAK,EAAE,IAAR;AAAcC,cAAM,EAAE,IAAtB;AAA4BC,aAAK,EAAE,IAAnC;AAAyCI,aAAK,EAAE;AAAhD;AAFH,KADsF;AAK9FC,eAAW,EAAE;AACXC,UAAI,EAAE;AAACC,kBAAU,EAAE;AAAb,OADK;AAEXJ,YAAM,EAAE;AAACI,kBAAU,EAAE;AAAb;AAFG;AALiF,GAAlF;AAeAvG,kCAA2C;AACvDwG,iBAAa,EAAE,IADwC;AAEvDC,wBAAoB,EAAE;AAFiC,GAA3C;AAQAzG,mCAA+B;AAC3C0G,cAAU,EAAE,IAD+B;AAE3CC,mBAAe,EAAE,KAF0B;AAG3CC,cAAU,EAAE,KAH+B;AAI3CC,oBAAgB,EAAE,IAJyB;AAK3CC,cAAU,EAAE;AAL+B,GAA/B;AAuhBhB;AAAC,CAnkBD,CAA8CC,sBAA9C;;AAAsB5I;;AA0kBtB;AAAmDa;;AAAnD;;AA2DC;;AA7CCiC,wBAAW+F,8BAAX,EAAW,SAAX,EAAkB;SAAlB;AACE,aAAO,IAAP;AACD,KAFiB;qBAAA;;AAAA,GAAlB;;AAQOA,2CAAP;;;AACE,QAAIzB,IAAI,GAAG,EAAX;;;AACA,WAAoB,uBAAKhG,UAAL,GAAeoC,cAAnC,EAAmC,QAAnC,EAAmCA,cAAnC,EAAqC;AAAhC,YAAMd,KAAK,WAAX;;AACH,YAAIA,KAAK,YAAYoG,QAArB,EAA+B;AAC7B1B,cAAI,IAAI1E,KAAK,CAACqG,OAAN,EAAR;AACD;AACF;;;;;;;;;;;;;AACD,WAAO3B,IAAP;AACD,GARM;;AAeGyB,+DAAV,UAAsC9H,UAAtC,EAAiE6D,OAAjE,EAAmFC,KAAnF,EAAkGC,KAAlG,EAAgH;;;;AAC9G,WAAoB,uBAAK1D,UAAL,GAAeoC,cAAnC,EAAmC,QAAnC,EAAmCA,cAAnC,EAAqC;AAAhC,YAAMd,KAAK,WAAX;;AACH,YAAIA,KAAK,YAAYb,eAArB,EAAsC;AACpCa,eAAK,CAACmD,sBAAN,CAA6B9E,UAA7B,EAAyC6D,OAAzC,EAAkDC,KAAlD,EAAyDC,KAAzD;AACD;AACF;;;;;;;;;;;;AACF,GANS;;AAYH+D,4CAAP,UAAgBG,IAAhB,EAAwDC,IAAxD,EAAkE;;;AAChED,QAAI,CAAC,IAAD,EAAOC,IAAP,CAAJ;;;AACA,WAAoB,uBAAK7H,UAAL,GAAeoC,cAAnC,EAAmC,QAAnC,EAAmCA,cAAnC,EAAqC;AAAhC,YAAMd,KAAK,WAAX;;AACH,YAAIA,KAAK,YAAYb,eAArB,EAAsC;AACpCa,eAAK,CAACwG,QAAN,CAAeF,IAAf,EAAqBC,IAArB;AACD;AACF;;;;;;;;;;;;;AACD,WAAOA,IAAP;AACD,GARM;;AA5COJ,kCAAQ5G,sBACfJ,eAAe,CAACF,QADD,GACS;AAC7BwH,eAAW,EAAE,QADgB;AAE7BjD,YAAQ,EAAE1E;AAFmB,GADT,CAAR;AAsDhB;AAAC,CA3DD,CAAmDK,eAAnD;;AAAsB7B;;AAsEtB;AAAoDa;;AAApD;;AAkDC;;AAxCCiC,wBAAWsG,+BAAX,EAAW,aAAX,EAAsB;SAAtB;AACE,aAAO,KAAKhI,UAAL,CAAgB,CAAhB,EAAmBiI,WAA1B;AACD,KAFqB;qBAAA;;AAAA,GAAtB;AAOAvG,wBAAWsG,+BAAX,EAAW,eAAX,EAAwB;SAAxB;AACE,aAAO,KAAKhI,UAAL,CAAgB,CAAhB,EAAmBqD,aAA1B;AACD,KAFuB;qBAAA;;AAAA,GAAxB;AAOA3B,wBAAWsG,+BAAX,EAAW,OAAX,EAAgB;SAAhB;AACE,aAAO,CAAC,CAAR;AACD,KAFe;qBAAA;;AAAA,GAAhB;;AAOOA,yCAAP;AACE,WAAO,KAAKhI,UAAL,CAAgB,CAAhB,CAAP;AACD,GAFM;;AAOAgI,2CAAP;AACE,WAAO,KAAKhI,UAAL,CAAgB,CAAhB,EAAmBsD,MAAnB,EAAP;AACD,GAFM;;AAOA0E,gDAAP,UAAmBpF,IAAnB,EAAgC;AAC9BA,QAAI,GAAG,KAAK5C,UAAL,CAAgB,CAAhB,EAAmBkI,WAAnB,CAA+BtF,IAA/B,CAAP;AACA,SAAKuF,cAAL,CAAoB,KAAKnI,UAAL,CAAgB,CAAhB,CAApB;AACA,WAAO4C,IAAP;AACD,GAJM;;AAxCOoF,mCAAyBvH,eAAe,CAACF,QAAzC;AA6ChB;AAAC,CAlDD,CAAoDE,eAApD;;AAAsB7B;;AA6DtB;AAAkDa;;AAAlD;;AAqDC;;AA3CCiC,wBAAW0G,6BAAX,EAAW,eAAX,EAAwB;SAAxB;AACE,aAAO,KAAKpI,UAAL,CAAgB,CAAhB,EAAmBqD,aAA1B;AACD,KAFuB;qBAAA;;AAAA,GAAxB;;AAOO+E,uCAAP;AACE,WAAO,KAAKpI,UAAL,CAAgB,CAAhB,CAAP;AACD,GAFM;;AAOAoI,yCAAP;AACE,WAAO,KAAKpI,UAAL,CAAgB,CAAhB,EAAmBsD,MAAnB,EAAP;AACD,GAFM;;AAOA8E,8CAAP,UAAmBxF,IAAnB,EAAgC;;;AAC9B,SAAKC,YAAL,CAAkBD,IAAlB;AACA,SAAKhB,QAAL,GAAgBhD,iBAASC,GAAzB;AACA,QAAIwJ,IAAI,GAAG,KAAKrI,UAAL,CAAgB,CAAhB,CAAX;;AACA,QAAIqI,IAAJ,EAAU;AACR,UAAI,KAAKhF,aAAL,IAAsBgF,IAAI,CAACxC,MAAL,CAAY,IAAZ,CAA1B,EAA6C;AAC3CjD,YAAI,GAAGyF,IAAI,CAACH,WAAL,CAAiBtF,IAAjB,CAAP;AACA,aAAKuF,cAAL,CAAoB,KAAKrF,IAAL,EAApB;AACD,OAHD,MAGO;AACLuF,YAAI,CAACH,WAAL,CAAiB,IAAjB;AACAtF,YAAI,GAAG,IAAP;AACD;AACF,KARD,MAQO;AACLA,UAAI,GAAG,IAAP;AACD;;;AACD,WAAoB,uBAAK5C,UAAL,CAAgBuE,KAAhB,CAAsB,CAAtB,IAAwBnC,cAA5C,EAA4C,QAA5C,EAA4CA,cAA5C,EAA8C;AAAzC,YAAMd,KAAK,WAAX;;AACH,YAAIA,KAAJ,EAAW;AACTA,eAAK,CAAC4G,WAAN,CAAkB,IAAlB;AACD;AACF;;;;;;;;;;;;;AACD,WAAOtF,IAAP;AACD,GArBM;;AA1BOwF,iCAAyB3H,eAAe,CAACF,QAAzC;AAgDhB;AAAC,CArDD,CAAkDE,eAAlD;;AAAsB7B;;AAgEtB;AAAmDa;;AAAnD;;AA4KC;;AAlKCiC,wBAAW4G,8BAAX,EAAW,SAAX,EAAkB;SAAlB;AACE,aAAO,KAAP;AACD,KAFiB;qBAAA;;AAAA,GAAlB;AAOA5G,wBAAW4G,8BAAX,EAAW,eAAX,EAAwB;SAAxB;AACE,aAAO,KAAP;AACD,KAFuB;qBAAA;;AAAA,GAAxB;AAOA5G,wBAAW4G,8BAAX,EAAW,aAAX,EAAsB;SAAtB;AACE,aAAO,KAAP;AACD,KAFqB;qBAAA;;AAAA,GAAtB;AAOA5G,wBAAW4G,8BAAX,EAAW,oBAAX,EAA6B;SAA7B;AACE,aAAO,KAAP;AACD,KAF4B;qBAAA;;AAAA,GAA7B;AAOA5G,wBAAW4G,8BAAX,EAAW,YAAX,EAAqB;SAArB;AACE,aAAO,KAAP;AACD,KAFoB;qBAAA;;AAAA,GAArB;AAOA5G,wBAAW4G,8BAAX,EAAW,OAAX,EAAgB;SAAhB;AACE,aAAO,CAAP;AACD,KAFe;qBAAA;;AAAA,GAAhB;AAOA5G,wBAAW4G,8BAAX,EAAW,YAAX,EAAqB;SAArB;AACE,aAAO,KAAP;AACD,KAFoB;qBAAA;;AAAA,GAArB;AAOA5G,wBAAW4G,8BAAX,EAAW,WAAX,EAAoB;SAApB;AACE,aAAO,KAAP;AACD,KAFmB;qBAAA;;AAAA,GAApB;AAOA5G,wBAAW4G,8BAAX,EAAW,QAAX,EAAiB;SAAjB;AACE,aAAO,KAAKpI,MAAZ;AACD,KAFgB;qBAAA;;AAAA,GAAjB;AAOAwB,wBAAW4G,8BAAX,EAAW,UAAX,EAAmB;SAAnB;AACE,aAAO1J,iBAASU,IAAhB;AACD,KAFkB;qBAAA;;AAAA,GAAnB;AAOAoC,wBAAW4G,8BAAX,EAAW,WAAX,EAAoB;SAApB;AACE,aAAO1J,iBAASU,IAAhB;AACD,KAFmB;qBAAA;;AAAA,GAApB;AAOAoC,wBAAW4G,8BAAX,EAAW,WAAX,EAAoB;SAApB;AACE,aAAO,CAAP;AACD,KAFmB;qBAAA;;AAAA,GAApB;;AAOOA,wDAAP;AACE,WAAO,KAAP;AACD,GAFM;;AAOP5G,wBAAW4G,8BAAX,EAAW,YAAX,EAAqB;SAArB;AACE,aAAO,IAAP;AACD,KAFoB;qBAAA;;AAAA,GAArB;;AAOOA,wCAAP;AACE,WAAO,IAAP;AACD,GAFM;;AAOAA,0CAAP;AACE,WAAO,IAAP;AACD,GAFM;;AAOAA,6CAAP;AACE,WAAO,CAAP;AACD,GAFM;;AAOAA,iDAAP;AACE,WAAO,CAAP;AACD,GAFM;;AAOAA,+CAAP,UAAmB1F,IAAnB,EAAgC;AAC9B,WAAOA,IAAP;AACD,GAFM;;AAMA0F,8CAAP;AACE,WAAO,EAAP;AACD,GAFM;;AASAA,0DAAP,UAA8BC,WAA9B,EAA0DC,QAA1D,EAA6EC,MAA7E,EAA6FC,MAA7F,EAA4G,CAAI,CAAzG;;AAOAJ,yDAAP,UAA6BK,KAA7B,EAA2C,CAAI,CAAxC;;AAOAL,8CAAP,UAAkBM,QAAlB,EAAwC,CAAI,CAArC;;AAKAN,0CAAP,UAAcO,QAAd,EAAgCD,QAAhC,EAAwDE,MAAxD,EAA+E;AAAvB;AAAAA;AAAuB;AAAI,GAA5E;;AAET;AA5KA,EAAmDtB,2BAAnD;;AAAsB5I;;AAmLtB;AAA8Ba;;AAA9B;AAAA;;AAIYK,iBAAe,EAAf;;AAuCX;;AAlCC4B,wBAAWgG,kBAAX,EAAW,MAAX,EAAe;SAAf;AACE,aAAO,MAAP;AACD,KAFc;qBAAA;;AAAA,GAAf;;AAOOA,+BAAP;AACE,WAAO,KAAK1B,IAAZ;AACD,GAFM;;AAQA0B,+BAAP,UAAe1B,IAAf,EAA2B;AACzB,SAAKA,IAAL,GAAYA,IAAZ;AACA,WAAO,IAAP;AACD,GAHM;;AAQA0B,4BAAP;AACE,WAAQ,KAAKhI,OAAL,CAAaO,MAAb,CAAoB,KAAKK,IAAzB,EAA4C2F,OAA5C,CAAoD,KAAK0B,OAAL,EAApD,CAAR;AACD,GAFM;;AAOAD,gCAAP;AACE,WAAO,KAAK1B,IAAZ;AACD,GAFM;;AAIT;AA3CA,EAA8BsC,oBAA9B;;AAAa1J;;AAmDb;AAA6Ba;;AAA7B;AAAA;;AAIYK,gBAAc,IAAd;AAKAA,oBAAqC,IAArC;;AAgDX;;AA3CC4B,wBAAWqH,iBAAX,EAAW,MAAX,EAAe;SAAf;AACE,aAAO,KAAP;AACD,KAFc;qBAAA;;AAAA,GAAf;;AAOOA,6BAAP;AACE,WAAO,KAAKC,GAAZ;AACD,GAFM;;AASAD,6BAAP,UAAcC,GAAd,EAA2BC,OAA3B,EAAoE;AAAzC;AAAAA;AAAyC;;AAClE,SAAKD,GAAL,GAAWA,GAAX;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,WAAO,IAAP;AACD,GAJM;;AASAF,uCAAP;AACE,WAAO,KAAKE,OAAL,CAAaC,YAAb,CAA0B,KAAKF,GAA/B,CAAP;AACD,GAFM;;AAOAD,2BAAP;AACE,WAAQ,KAAKrJ,OAAL,CAAaO,MAAb,CAAoB,KAAKK,IAAzB,EAA2C6I,MAA3C,CAAkD,KAAKF,OAAL,CAAaG,KAAb,CAAmB,KAAKJ,GAAxB,CAAlD,CAAR;AACD,GAFM;;AAOAD,+BAAP;AACE,WAAO,UAAP;AACD,GAFM;;AAIT;AAzDA,EAA6BT,oBAA7B;;AAAa1J","names":["exports","ORD","OP","BIN","REL","OPEN","CLOSE","PUNCT","INNER","VCENTER","NONE","TEXSPACELENGTH","TEXSPACE","__extends","factory","attributes","children","_super","_this","arity","childNodes","create","parent","setChildren","Attributes_js_1","getNodeClass","kind","defaults","setList","AbstractMmlNode","keepIds","node","properties","__assign","getAllAttributes","keys","_d","name_1","set","length","isInferred","children_1_1","child","appendChild","copy","push","Object","texclass","texClass","Infinity","notParent","Parent","call","forEach","original","getPropertyNames","_c","name_2","setProperty","getProperty","newChild","oldChild","replaceChild","i","prev","getPrevClass","core","prevClass","prevLevel","get","space","Math","abs","isEmbellished","coreMO","hasSpacingAttributes","display","level","prime","getAllDefaults","key","hasOwnProperty","alwaysInherit","value","noinherit","noInherit","setInherited","displaystyle","getExplicit","undefined","scriptlevel","slice","setChildInheritedAttributes","setInheritedAttributes","current","updated","name_3","isSet","mathsize","options","verifyAttributes","mError","verifyChildren","bad","getExplicitNames","name_4","substr","getDefault","match","join","verifyTree","message","short","isKind","merror","mtext","text","setText","mathbackground","mathcolor","dir","mstyle","mpadded","width","height","depth","lspace","voffset","mtable","align","maligngroup","mrow","groupalign","scriptminsize","scriptsizemultiplier","checkArity","checkAttributes","fullErrors","fixMmultiscripts","fixMtables","Node_js_1","AbstractMmlTokenNode","TextNode","getText","func","data","walkTree","mathvariant","AbstractMmlLayoutNode","isSpacelike","setTeXclass","updateTeXclass","AbstractMmlBaseNode","base","AbstractMmlEmptyNode","_attributes","_display","_level","_prime","_node","_options","_message","_short","XMLNode","xml","adaptor","serializeXML","setXML","clone"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/core/MmlTree/MmlNode.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Interfaces and abstract classes for MmlNode objects\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {Attributes, INHERIT} from './Attributes.js';\nimport {Property, PropertyList, Node, AbstractNode, AbstractEmptyNode, NodeClass} from '../Tree/Node.js';\nimport {MmlFactory} from './MmlFactory.js';\nimport {DOMAdaptor} from '../DOMAdaptor.js';\n\n/**\n *  Used in setInheritedAttributes() to pass originating node kind as well as property value\n */\nexport type AttributeList = {[attribute: string]: [string, Property]};\n\n/**\n *  These are the TeX classes for spacing computations\n */\nexport const TEXCLASS = {\n  ORD:   0,\n  OP:    1,\n  BIN:   2,\n  REL:   3,\n  OPEN:  4,\n  CLOSE: 5,\n  PUNCT: 6,\n  INNER: 7,\n  VCENTER: 8,  // Used in TeXAtom, but not for spacing\n  NONE:   -1\n};\n\nexport const TEXCLASSNAMES = ['ORD', 'OP', 'BIN', 'REL', 'OPEN', 'CLOSE', 'PUNCT', 'INNER', 'VCENTER'];\n\n/**\n *  The spacing sizes used by the TeX spacing table below.\n */\nconst TEXSPACELENGTH = ['', 'thinmathspace', 'mediummathspace', 'thickmathspace'];\n\n/**\n * See TeXBook Chapter 18 (p. 170)\n */\nconst TEXSPACE = [\n  [ 0, -1,  2,  3,  0,  0,  0,  1], // ORD\n  [-1, -1,  0,  3,  0,  0,  0,  1], // OP\n  [ 2,  2,  0,  0,  2,  0,  0,  2], // BIN\n  [ 3,  3,  0,  0,  3,  0,  0,  3], // REL\n  [ 0,  0,  0,  0,  0,  0,  0,  0], // OPEN\n  [ 0, -1,  2,  3,  0,  0,  0,  1], // CLOSE\n  [ 1,  1,  0,  1,  1,  1,  1,  1], // PUNCT\n  [ 1, -1,  2,  3,  1,  0,  1,  1]  // INNER\n];\n\n/**\n * Attributes used to determine indentation and shifting\n */\nexport const indentAttributes = [\n  'indentalign', 'indentalignfirst',\n  'indentshift', 'indentshiftfirst'\n];\n\n/**\n * The nodes that can be in the internal MathML tree\n */\nexport type MMLNODE = MmlNode | TextNode | XMLNode;\n\n/*****************************************************************/\n/**\n *  The MmlNode interface (extends Node interface)\n */\n\nexport interface MmlNode extends Node {\n\n  /**\n   * Test various properties of MathML nodes\n   */\n  readonly isToken: boolean;\n  readonly isEmbellished: boolean;\n  readonly isSpacelike: boolean;\n  readonly linebreakContainer: boolean;\n  readonly hasNewLine: boolean;\n\n  /**\n   *  The expected number of children (-1 means use inferred mrow)\n   */\n  readonly arity: number;\n  readonly isInferred: boolean;\n\n  /**\n   *  Get the parent node (skipping inferred mrows and\n   *    other nodes marked as notParent)\n   */\n  readonly Parent: MmlNode;\n  readonly notParent: boolean;\n\n  /**\n   * The actual parent in the tree\n   */\n  parent: MmlNode;\n\n  /**\n   *  values needed for TeX spacing computations\n   */\n  texClass: number;\n  prevClass: number;\n  prevLevel: number;\n\n  /**\n   *  The attributes (explicit and inherited) for this node\n   */\n  attributes: Attributes;\n\n  /**\n   * @return {MmlNode}  For embellished operators, the child node that contains the\n   *                    core <mo> node.  For non-embellished nodes, the original node.\n   */\n  core(): MmlNode;\n\n  /**\n   * @return {MmlNode}  For embellished operators, the core <mo> element (at whatever\n   *                    depth).  For non-embellished nodes, the original node itself.\n   */\n  coreMO(): MmlNode;\n\n  /**\n   * @return {number}   For embellished operators, the index of the child node containing\n   *                    the core <mo>.  For non-embellished nodes, 0.\n   */\n  coreIndex(): number;\n\n  /**\n   * @return {number}  The index of this node in its parent's childNodes array.\n   */\n  childPosition(): number;\n\n  /**\n   * @param {MmlNode} prev  The node that is before this one for TeX spacing purposes\n   *                        (not all nodes count in TeX measurements)\n   * @return {MmlNode}  The node that should be the previous node for the next one\n   *                    in the tree (usually, either the last child, or the node itself)\n   */\n  setTeXclass(prev: MmlNode): MmlNode;\n\n  /**\n   * @return {string}  The spacing to use before this element (one of TEXSPACELENGTH array above)\n   */\n  texSpacing(): string;\n\n  /**\n   * @return {boolean}  The core mo element has an explicit 'form', 'lspace', or 'rspace' attribute\n   */\n  hasSpacingAttributes(): boolean;\n\n  /**\n   * Sets the nodes inherited attributes, and pushes them to the nodes children.\n   *\n   * @param {AttributeList} attributes  The list of inheritable attributes (with the node kinds\n   *                                    from which they came)\n   * @param {boolean} display           The displaystyle to inherit\n   * @param {number} level              The scriptlevel to inherit\n   * @param {boolean} prime             The TeX prime style to inherit (T vs. T', etc).\n   */\n  setInheritedAttributes(attributes: AttributeList, display: boolean, level: number, prime: boolean): void;\n\n  /**\n   * Set the nodes inherited attributes based on the attributes of the given node\n   *   (used for creating extra nodes in the tree after setInheritedAttributes has already run)\n   *\n   * @param {MmlNode} node   The node whose attributes are to be used as a template\n   */\n  inheritAttributesFrom(node: MmlNode): void;\n\n  /**\n   * Replace the current node with an error message (or the name of the node)\n   *\n   * @param {string} message         The error message to use\n   * @param {PropertyList} options   The options telling how much to verify\n   * @param {boolean} short          True means use just the kind if not using full errors\n   */\n  mError(message: string, options: PropertyList, short?: boolean): void;\n\n  /**\n   * Check integrity of MathML structure\n   *\n   * @param {PropertyList} options  The options controlling the check\n   */\n  verifyTree(options?: PropertyList): void;\n}\n\n\n/*****************************************************************/\n/**\n *  The MmlNode class interface (extends the NodeClass)\n */\n\nexport interface MmlNodeClass extends NodeClass {\n\n  /**\n   *  The list of default attribute values for nodes of this class\n   */\n  defaults?: PropertyList;\n\n  /**\n   * An MmlNode takes a NodeFactory (so it can create additional nodes as needed), a list\n   *   of attributes, and an array of children and returns the desired MmlNode with\n   *   those attributes and children\n   *\n   * @constructor\n   * @param {MmlFactory} factory       The MathML node factory to use to create additional nodes\n   * @param {PropertyList} attributes  The list of initial attributes for the node\n   * @param {MmlNode[]} children       The initial child nodes (more can be added later)\n   */\n  new (factory: MmlFactory, attributes?: PropertyList, children?: MmlNode[]): MmlNode;\n\n}\n\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode class (extends the AbstractNode class and implements\n *  the IMmlNode interface)\n */\n\nexport abstract class AbstractMmlNode extends AbstractNode implements MmlNode {\n\n  /**\n   * The properties common to all MathML nodes\n   */\n  public static defaults: PropertyList = {\n    mathbackground: INHERIT,\n    mathcolor: INHERIT,\n    mathsize: INHERIT,  // technically only for token elements, but <mstyle mathsize=\"...\"> should\n    //    scale all spaces, fractions, etc.\n    dir: INHERIT\n  };\n\n  /**\n   *  This lists properties that do NOT get inherited between specific kinds\n   *  of nodes.  The outer keys are the node kinds that are being inherited FROM,\n   *  while the second level of keys are the nodes that INHERIT the values.  Any\n   *  property appearing in the innermost list is NOT inherited by the pair.\n   *\n   *  For example, an mpadded element will not inherit a width attribute from an mstyle node.\n   */\n  public static noInherit: {[node1: string]: {[node2: string]: {[attribute: string]: boolean}}} = {\n    mstyle: {\n      mpadded: {width: true, height: true, depth: true, lspace: true, voffset: true},\n      mtable:  {width: true, height: true, depth: true, align: true}\n    },\n    maligngroup: {\n      mrow: {groupalign: true},\n      mtable: {groupalign: true}\n    }\n  };\n\n  /**\n   * This lists the attributes that should always be inherited,\n   *   even when there is no default value for the attribute.\n   */\n  public static alwaysInherit: {[name: string]: boolean} = {\n    scriptminsize: true,\n    scriptsizemultiplier: true\n  };\n\n  /**\n   * This is the list of options for the verifyTree() method\n   */\n  public static verifyDefaults: PropertyList = {\n    checkArity: true,\n    checkAttributes: false,\n    fullErrors: false,\n    fixMmultiscripts: true,\n    fixMtables: true\n  };\n\n  /*\n   * These default to being unset (the node doesn't participate in spacing calculations).\n   * The correct values are produced when the setTeXclass() method is called on the tree.\n   */\n\n  /**\n   * The TeX class for the preceding node\n   */\n  public prevClass: number = null;\n\n  /**\n   * The scriptlevel of the preceding node\n   */\n  public prevLevel: number = null;\n\n  /**\n   * This node's attributes\n   */\n  public attributes: Attributes;\n\n  /**\n   *  Child nodes are MmlNodes (special case of Nodes).\n   */\n  public childNodes: MmlNode[];\n\n  /**\n   * The parent is an MmlNode\n   */\n  public parent: MmlNode;\n\n  /**\n   * The node factory is an MmlFactory\n   */\n  public readonly factory: MmlFactory;\n\n  /**\n   * The TeX class of this node (obtained via texClass below)\n   */\n  protected texclass: number = null;\n\n  /**\n   *  Create an MmlNode:\n   *    If the arity is -1, add the inferred row (created by the factory)\n   *    Add the children, if any\n   *    Create the Attribute object from the class defaults and the global defaults (the math node defaults)\n   *\n   *  @override\n   */\n  constructor(factory: MmlFactory, attributes: PropertyList = {}, children: MmlNode[] = []) {\n    super(factory);\n    if (this.arity < 0) {\n      this.childNodes = [factory.create('inferredMrow')];\n      this.childNodes[0].parent = this;\n    }\n    this.setChildren(children);\n    this.attributes = new Attributes(\n      factory.getNodeClass(this.kind).defaults,\n      factory.getNodeClass('math').defaults\n    );\n    this.attributes.setList(attributes);\n  }\n\n  /**\n   * @override\n   *\n   * @param {boolean} keepIds   True to copy id attributes, false to skip them.\n   *                              (May cause error in the future, since not part of the interface.)\n   * @return {AbstractMmlNode}  The copied node tree.\n   */\n  public copy(keepIds: boolean = false): AbstractMmlNode {\n    const node = this.factory.create(this.kind) as AbstractMmlNode;\n    node.properties = {...this.properties};\n    if (this.attributes) {\n      const attributes = this.attributes.getAllAttributes();\n      for (const name of Object.keys(attributes)) {\n        if (name !== 'id' || keepIds) {\n          node.attributes.set(name, attributes[name]);\n        }\n      }\n    }\n    if (this.childNodes && this.childNodes.length) {\n      let children = this.childNodes as MmlNode[];\n      if (children.length === 1 && children[0].isInferred) {\n        children = children[0].childNodes as MmlNode[];\n      }\n      for (const child of children) {\n        if (child) {\n          node.appendChild(child.copy() as MmlNode);\n        } else {\n          node.childNodes.push(null);\n        }\n      }\n    }\n    return node;\n  }\n\n  /**\n   * The TeX class for this node\n   */\n  public get texClass(): number {\n    return this.texclass;\n  }\n\n  /**\n   * The TeX class for this node\n   */\n  public set texClass(texClass: number) {\n    this.texclass = texClass;\n  }\n\n  /**\n   * @return {boolean}  true if this is a token node\n   */\n  public get isToken(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  true if this is an embellished operator\n   */\n  public get isEmbellished(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  true if this is a space-like node\n   */\n  public get isSpacelike(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  true if this is a node that supports linebreaks in its children\n   */\n  public get linebreakContainer(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  true if this node contains a line break\n   */\n  public get hasNewLine(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {number}  The number of children allowed, or Infinity for any number,\n   *                   or -1 for when an inferred row is needed for the children.\n   *                   Special case is 1, meaning at least one (other numbers\n   *                   mean exactly that many).\n   */\n  public get arity(): number {\n    return Infinity;\n  }\n\n  /**\n   * @return {boolean}  true if this is an inferred mrow\n   */\n  public get isInferred(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {MmlNode}  The logical parent of this node (skipping over inferred rows\n   *                      some other node types)\n   */\n  public get Parent(): MmlNode {\n    let parent = this.parent;\n    while (parent && parent.notParent) {\n      parent = parent.Parent;\n    }\n    return parent;\n  }\n\n  /**\n   * @return {boolean}  true if this is a node that doesn't count as a parent node in Parent()\n   */\n  public get notParent(): boolean {\n    return false;\n  }\n\n  /**\n   * If there is an inferred row, the the children of that instead\n   *\n   * @override\n   */\n  public setChildren(children: MmlNode[]) {\n    if (this.arity < 0) {\n      return this.childNodes[0].setChildren(children);\n    }\n    return super.setChildren(children);\n  }\n  /**\n   * If there is an inferred row, append to that instead.\n   * If a child is inferred, append its children instead.\n   *\n   * @override\n   */\n  public appendChild(child: MmlNode) {\n    if (this.arity < 0) {\n      this.childNodes[0].appendChild(child);\n      return child;\n    }\n    if (child.isInferred) {\n      //\n      //  If we can have arbitrary children, remove the inferred mrow\n      //  (just add its children).\n      //\n      if (this.arity === Infinity) {\n        child.childNodes.forEach((node) => super.appendChild(node));\n        return child;\n      }\n      //\n      //  Otherwise, convert the inferred mrow to an explicit mrow\n      //\n      const original = child;\n      child = this.factory.create('mrow');\n      child.setChildren(original.childNodes);\n      child.attributes = original.attributes;\n      for (const name of original.getPropertyNames()) {\n        child.setProperty(name, original.getProperty(name));\n      }\n    }\n    return super.appendChild(child);\n  }\n  /**\n   * If there is an inferred row, remove the child from there\n   *\n   * @override\n   */\n  public replaceChild(newChild: MmlNode, oldChild: MmlNode) {\n    if (this.arity < 0) {\n      this.childNodes[0].replaceChild(newChild, oldChild);\n      return newChild;\n    }\n    return super.replaceChild(newChild, oldChild);\n  }\n\n  /**\n   * @override\n   */\n  public core(): MmlNode {\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public coreMO(): MmlNode {\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public coreIndex() {\n    return 0;\n  }\n\n  /**\n   * @override\n   */\n  public childPosition() {\n    let child: MmlNode = this;\n    let parent = child.parent;\n    while (parent && parent.notParent) {\n      child = parent;\n      parent = parent.parent;\n    }\n    if (parent) {\n      let i = 0;\n      for (const node of parent.childNodes) {\n        if (node === child) {\n          return i;\n        }\n        i++;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @override\n   */\n  public setTeXclass(prev: MmlNode): MmlNode {\n    this.getPrevClass(prev);\n    return (this.texClass != null ? this : prev);\n  }\n  /**\n   * For embellished operators, get the data from the core and clear the core\n   *\n   * @param {MmlNode} core  The core <mo> for this node\n   */\n  protected updateTeXclass(core: MmlNode) {\n    if (core) {\n      this.prevClass = core.prevClass;\n      this.prevLevel = core.prevLevel;\n      core.prevClass = core.prevLevel = null;\n      this.texClass = core.texClass;\n    }\n  }\n  /**\n   * Get the previous element's texClass and scriptlevel\n   *\n   * @param {MmlNode} prev  The previous node to this one\n   */\n  protected getPrevClass(prev: MmlNode) {\n    if (prev) {\n      this.prevClass = prev.texClass;\n      this.prevLevel = prev.attributes.get('scriptlevel') as number;\n    }\n  }\n\n  /**\n   * @return {string}  returns the spacing to use before this node\n   */\n  public texSpacing(): string {\n    let prevClass = (this.prevClass != null ? this.prevClass : TEXCLASS.NONE);\n    let texClass = this.texClass || TEXCLASS.ORD;\n    if (prevClass === TEXCLASS.NONE || texClass === TEXCLASS.NONE) {\n      return '';\n    }\n    if (prevClass === TEXCLASS.VCENTER) {\n      prevClass = TEXCLASS.ORD;\n    }\n    if (texClass === TEXCLASS.VCENTER) {\n      texClass = TEXCLASS.ORD;\n    }\n    let space = TEXSPACE[prevClass][texClass];\n    if ((this.prevLevel > 0 || this.attributes.get('scriptlevel') > 0) && space >= 0) {\n      return '';\n    }\n    return TEXSPACELENGTH[Math.abs(space)];\n  }\n\n  /**\n   * @return {boolean}  The core mo element has an explicit 'form' attribute\n   */\n  public hasSpacingAttributes(): boolean {\n    return this.isEmbellished && this.coreMO().hasSpacingAttributes();\n  }\n\n  /**\n   * Sets the inherited propertis for this node, and pushes inherited properties to the children\n   *\n   *   For each inheritable attribute:\n   *     If the node has a default for this attribute, try to inherit it\n   *       but check if the noInherit object prevents that.\n   *   If the node doesn't have an explicit displaystyle, inherit it\n   *   If the node doesn't have an explicit scriptstyle, inherit it\n   *   If the prime style is true, set it as a property (it is not a MathML attribute)\n   *   Check that the number of children is correct\n   *   Finally, push any inherited attributes to teh children.\n   *\n   * @override\n   */\n  public setInheritedAttributes(attributes: AttributeList = {},\n                                display: boolean = false, level: number = 0, prime: boolean = false) {\n    let defaults = this.attributes.getAllDefaults();\n    for (const key of Object.keys(attributes)) {\n      if (defaults.hasOwnProperty(key) || AbstractMmlNode.alwaysInherit.hasOwnProperty(key)) {\n        let [node, value] = attributes[key];\n        let noinherit = (AbstractMmlNode.noInherit[node] || {})[this.kind] || {};\n        if (!noinherit[key]) {\n          this.attributes.setInherited(key, value);\n        }\n      }\n    }\n    let displaystyle = this.attributes.getExplicit('displaystyle');\n    if (displaystyle === undefined) {\n      this.attributes.setInherited('displaystyle', display);\n    }\n    let scriptlevel = this.attributes.getExplicit('scriptlevel');\n    if (scriptlevel === undefined) {\n      this.attributes.setInherited('scriptlevel', level);\n    }\n    if (prime) {\n      this.setProperty('texprimestyle', prime);\n    }\n    let arity = this.arity;\n    if (arity >= 0 && arity !== Infinity && ((arity === 1 && this.childNodes.length === 0) ||\n                                             (arity !== 1 && this.childNodes.length !== arity))) {\n      //\n      //  Make sure there are the right number of child nodes\n      //  (trim them or add empty mrows)\n      //\n      if (arity < this.childNodes.length) {\n        this.childNodes = this.childNodes.slice(0, arity);\n      } else {\n        while (this.childNodes.length < arity) {\n          this.appendChild(this.factory.create('mrow'));\n        }\n      }\n    }\n    this.setChildInheritedAttributes(attributes, display, level, prime);\n  }\n  /**\n   * Apply inherited attributes to all children\n   * (Some classes override this to handle changes in displaystyle and scriptlevel)\n   *\n   * @param {AttributeList} attributes  The list of inheritable attributes (with the node kinds\n   *                                    from which they came)\n   * @param {boolean} display           The displaystyle to inherit\n   * @param {number} level              The scriptlevel to inherit\n   * @param {boolean} prime             The TeX prime style to inherit (T vs. T', etc).\n   */\n  protected setChildInheritedAttributes(attributes: AttributeList, display: boolean, level: number, prime: boolean) {\n    for (const child of this.childNodes) {\n      child.setInheritedAttributes(attributes, display, level, prime);\n    }\n  }\n  /**\n   * Used by subclasses to add their own attributes to the inherited list\n   * (e.g., mstyle uses this to augment the inherited attibutes)\n   *\n   * @param {AttributeList} current    The current list of inherited attributes\n   * @param {PropertyList} attributes  The new attributes to add into the list\n   */\n  protected addInheritedAttributes(current: AttributeList, attributes: PropertyList) {\n    let updated: AttributeList = {...current};\n    for (const name of Object.keys(attributes)) {\n      if (name !== 'displaystyle' && name !== 'scriptlevel' && name !== 'style') {\n        updated[name] = [this.kind, attributes[name]];\n      }\n    }\n    return updated;\n  }\n\n  /**\n   * Set the nodes inherited attributes based on the attributes of the given node\n   *   (used for creating extra nodes in the tree after setInheritedAttributes has already run)\n   *\n   * @param {MmlNode} node   The node whose attributes are to be used as a template\n   */\n  public inheritAttributesFrom(node: MmlNode) {\n    const attributes = node.attributes;\n    const display = attributes.get('displaystyle') as boolean;\n    const scriptlevel = attributes.get('scriptlevel') as number;\n    const defaults: AttributeList = (!attributes.isSet('mathsize') ? {} : {\n      mathsize: ['math', attributes.get('mathsize')]\n    });\n    const prime = node.getProperty('texprimestyle') as boolean || false;\n    this.setInheritedAttributes(defaults, display, scriptlevel, prime);\n  }\n\n  /**\n   * Verify the attributes, and that there are the right number of children.\n   * Then verify the children.\n   *\n   * @param {PropertyList} options   The options telling how much to verify\n   */\n  public verifyTree(options: PropertyList = null) {\n    if (options === null) {\n      return;\n    }\n    this.verifyAttributes(options);\n    let arity = this.arity;\n    if (options['checkArity']) {\n      if (arity >= 0 && arity !== Infinity &&\n          ((arity === 1 && this.childNodes.length === 0) ||\n           (arity !== 1 && this.childNodes.length !== arity))) {\n        this.mError('Wrong number of children for \"' + this.kind + '\" node', options, true);\n      }\n    }\n    this.verifyChildren(options);\n  }\n\n  /**\n   * Verify that all the attributes are valid (i.e., have defaults)\n   *\n   * @param {PropertyList} options   The options telling how much to verify\n   */\n  protected verifyAttributes(options: PropertyList) {\n    if (options['checkAttributes']) {\n      const attributes = this.attributes;\n      const bad = [];\n      for (const name of attributes.getExplicitNames()) {\n        if (name.substr(0, 5) !== 'data-' && attributes.getDefault(name) === undefined &&\n            !name.match(/^(?:class|style|id|(?:xlink:)?href)$/)) {\n          // FIXME: provide a configurable checker for names that are OK\n          bad.push(name);\n        }\n        // FIXME: add ability to check attribute values?\n      }\n      if (bad.length) {\n        this.mError('Unknown attributes for ' + this.kind + ' node: ' + bad.join(', '), options);\n      }\n    }\n  }\n\n  /**\n   * Verify the children.\n   *\n   * @param {PropertyList} options   The options telling how much to verify\n   */\n  protected verifyChildren(options: PropertyList) {\n    for (const child of this.childNodes) {\n      child.verifyTree(options);\n    }\n  }\n\n  /**\n   * Replace the current node with an error message (or the name of the node)\n   *\n   * @param {string} message         The error message to use\n   * @param {PropertyList} options   The options telling how much to verify\n   * @param {boolean} short          True means use just the kind if not using full errors\n   */\n  public mError(message: string, options: PropertyList, short: boolean = false) {\n    if (this.parent && this.parent.isKind('merror')) {\n      return null;\n    }\n    let merror = this.factory.create('merror');\n    if (options['fullErrors'] || short) {\n      let mtext = this.factory.create('mtext');\n      let text = this.factory.create('text') as TextNode;\n      text.setText(options['fullErrors'] ? message : this.kind);\n      mtext.appendChild(text);\n      merror.appendChild(mtext);\n      this.parent.replaceChild(merror, this);\n    } else {\n      this.parent.replaceChild(merror, this);\n      merror.appendChild(this);\n    }\n    return merror;\n  }\n\n}\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode Token node class (extends the AbstractMmlNode)\n */\n\nexport abstract class AbstractMmlTokenNode extends AbstractMmlNode {\n\n  /**\n   * Add the attributes common to all token nodes\n   */\n  public static defaults: PropertyList = {\n      ...AbstractMmlNode.defaults,\n    mathvariant: 'normal',\n    mathsize: INHERIT\n  };\n\n  /**\n   * @override\n   */\n  public get isToken() {\n    return true;\n  }\n\n  /**\n   * Get the text of the token node (skipping mglyphs, and combining\n   *   multiple text nodes)\n   */\n  public getText() {\n    let text = '';\n    for (const child of this.childNodes) {\n      if (child instanceof TextNode) {\n        text += child.getText();\n      }\n    }\n    return text;\n  }\n\n  /**\n   * Only inherit to child nodes that are AbstractMmlNodes (not TextNodes)\n   *\n   * @override\n   */\n  protected setChildInheritedAttributes(attributes: AttributeList, display: boolean, level: number, prime: boolean) {\n    for (const child of this.childNodes) {\n      if (child instanceof AbstractMmlNode) {\n        child.setInheritedAttributes(attributes, display, level, prime);\n      }\n    }\n  }\n\n  /**\n   * Only step into children that are AbstractMmlNodes (not TextNodes)\n   * @override\n   */\n  public walkTree(func: (node: Node, data?: any) => void, data?: any) {\n    func(this, data);\n    for (const child of this.childNodes) {\n      if (child instanceof AbstractMmlNode) {\n        child.walkTree(func, data);\n      }\n    }\n    return data;\n  }\n\n}\n\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode Layout class (extends the AbstractMmlNode)\n *\n *  These have inferred mrows (so only one child) and can be\n *  spacelike or embellished based on their contents.\n */\n\nexport abstract class AbstractMmlLayoutNode extends AbstractMmlNode {\n\n  /**\n   * Use the same defaults as AbstractMmlNodes\n   */\n  public static defaults: PropertyList = AbstractMmlNode.defaults;\n\n  /**\n   * @override\n   */\n  public get isSpacelike() {\n    return this.childNodes[0].isSpacelike;\n  }\n\n  /**\n   * @override\n   */\n  public get isEmbellished() {\n    return this.childNodes[0].isEmbellished;\n  }\n\n  /**\n   * @override\n   */\n  public get arity() {\n    return -1;\n  }\n\n  /**\n   * @override\n   */\n  public core() {\n    return this.childNodes[0];\n  }\n\n  /**\n   * @override\n   */\n  public coreMO() {\n    return this.childNodes[0].coreMO();\n  }\n\n  /**\n   * @override\n   */\n  public setTeXclass(prev: MmlNode) {\n    prev = this.childNodes[0].setTeXclass(prev);\n    this.updateTeXclass(this.childNodes[0]);\n    return prev;\n  }\n}\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode-with-base-node Class (extends the AbstractMmlNode)\n *\n *  These have a base element and other elemetns, (e.g., script elements for msubsup).\n *  They can be embellished (if their base is), and get their TeX classes\n *    from their base with their scripts being handled as separate math lists.\n */\n\nexport abstract class AbstractMmlBaseNode extends AbstractMmlNode {\n\n  /**\n   * Use the same defaults as AbstractMmlNodes\n   */\n  public static defaults: PropertyList = AbstractMmlNode.defaults;\n\n  /**\n   * @override\n   */\n  public get isEmbellished() {\n    return this.childNodes[0].isEmbellished;\n  }\n\n  /**\n   * @override\n   */\n  public core() {\n    return this.childNodes[0];\n  }\n\n  /**\n   * @override\n   */\n  public coreMO() {\n    return this.childNodes[0].coreMO();\n  }\n\n  /**\n   * @override\n   */\n  public setTeXclass(prev: MmlNode) {\n    this.getPrevClass(prev);\n    this.texClass = TEXCLASS.ORD;\n    let base = this.childNodes[0];\n    if (base) {\n      if (this.isEmbellished || base.isKind('mi')) {\n        prev = base.setTeXclass(prev);\n        this.updateTeXclass(this.core());\n      } else {\n        base.setTeXclass(null);\n        prev = this;\n      }\n    } else {\n      prev = this;\n    }\n    for (const child of this.childNodes.slice(1)) {\n      if (child) {\n        child.setTeXclass(null);\n      }\n    }\n    return prev;\n  }\n}\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode Empty Class (extends AbstractEmptyNode, implements MmlNode)\n *\n *  These have no children and no attributes (TextNode and XMLNode), so we\n *  override all the methods dealing with them, and with the data that usually\n *  goes with an MmlNode.\n */\n\nexport abstract class AbstractMmlEmptyNode extends AbstractEmptyNode implements MmlNode {\n\n  /**\n   *  Parent is an MmlNode\n   */\n  public parent: MmlNode;\n\n  /**\n   * @return {boolean}  Not a token element\n   */\n  public get isToken(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Not embellished\n   */\n  public get isEmbellished(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Not space-like\n   */\n  public get isSpacelike(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Not a container of any kind\n   */\n  public get linebreakContainer(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Does not contain new lines\n   */\n  public get hasNewLine(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {number}  No children\n   */\n  public get arity(): number {\n    return 0;\n  }\n\n  /**\n   * @return {boolean}  Is not an inferred row\n   */\n  public get isInferred(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Is not a container element\n   */\n  public get notParent(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {MmlNode}  Parent is the actual parent\n   */\n  public get Parent(): MmlNode {\n    return this.parent;\n  }\n\n  /**\n   * @return {number}  No TeX class\n   */\n  public get texClass(): number {\n    return TEXCLASS.NONE;\n  }\n\n  /**\n   * @return {number}  No previous element\n   */\n  public get prevClass(): number {\n    return TEXCLASS.NONE;\n  }\n\n  /**\n   * @return {number}  No previous element\n   */\n  public get prevLevel(): number {\n    return 0;\n  }\n\n  /**\n   * @return {boolean}  The core mo element has an explicit 'form' attribute\n   */\n  public hasSpacingAttributes(): boolean {\n    return false;\n  }\n\n  /**\n   * return {Attributes}  No attributes, so don't store one\n   */\n  public get attributes(): Attributes {\n    return null;\n  }\n\n  /**\n   * @override\n   */\n  public core(): MmlNode {\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public coreMO(): MmlNode {\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public coreIndex() {\n    return 0;\n  }\n\n  /**\n   * @override\n   */\n  public childPosition() {\n    return 0;\n  }\n\n  /**\n   * @override\n   */\n  public setTeXclass(prev: MmlNode) {\n    return prev;\n  }\n  /**\n   * @override\n   */\n  public texSpacing() {\n    return '';\n  }\n\n  /**\n   * No children or attributes, so ignore this call.\n   *\n   * @override\n   */\n  public setInheritedAttributes(_attributes: AttributeList, _display: boolean, _level: number, _prime: boolean) {}\n\n  /**\n   * No children or attributes, so ignore this call.\n   *\n   * @override\n   */\n  public inheritAttributesFrom(_node: MmlNode) {}\n\n  /**\n   * No children or attributes, so ignore this call.\n   *\n   * @param {PropertyList} options  The options for the check\n   */\n  public verifyTree(_options: PropertyList) {}\n\n  /**\n   *  @override\n   */\n  public mError(_message: string, _options: PropertyList, _short: boolean = false) {}\n\n}\n\n/*****************************************************************/\n/**\n *  The TextNode Class (extends AbstractMmlEmptyNode)\n */\n\nexport class TextNode extends AbstractMmlEmptyNode {\n  /**\n   * The text for this node\n   */\n  protected text: string = '';\n\n  /**\n   * @override\n   */\n  public get kind() {\n    return 'text';\n  }\n\n  /**\n   * @return {string}  Return the node's text\n   */\n  public getText(): string {\n    return this.text;\n  }\n\n  /**\n   * @param {string} text  The text to use for the node\n   * @return {TextNode}  The text node (for chaining of method calls)\n   */\n  public setText(text: string): TextNode {\n    this.text = text;\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public copy() {\n    return (this.factory.create(this.kind) as TextNode).setText(this.getText());\n  }\n\n  /**\n   * Just use the text\n   */\n  public toString() {\n    return this.text;\n  }\n\n}\n\n\n/*****************************************************************/\n/**\n *  The XMLNode Class (extends AbstractMmlEmptyNode)\n */\n\nexport class XMLNode extends AbstractMmlEmptyNode {\n  /**\n   * The XML content for this node\n   */\n  protected xml: Object = null;\n\n  /**\n   * DOM adaptor for the content\n   */\n  protected adaptor: DOMAdaptor<any, any, any> = null;\n\n  /**\n   * @override\n   */\n  public get kind() {\n    return 'XML';\n  }\n\n  /**\n   * @return {Object}  Return the node's XML content\n   */\n  public getXML(): Object {\n    return this.xml;\n  }\n\n  /**\n   * @param {object} xml  The XML content to be saved\n   * @param {DOMAdaptor} adaptor DOM adaptor for the content\n   * @return {XMLNode}  The XML node (for chaining of method calls)\n   */\n  public setXML(xml: Object, adaptor: DOMAdaptor<any, any, any> = null): XMLNode {\n    this.xml = xml;\n    this.adaptor = adaptor;\n    return this;\n  }\n\n  /**\n   * @return {string}  The serialized XML content\n   */\n  public getSerializedXML(): string {\n    return this.adaptor.serializeXML(this.xml);\n  }\n\n  /**\n   * @override\n   */\n  public copy(): XMLNode {\n    return (this.factory.create(this.kind) as XMLNode).setXML(this.adaptor.clone(this.xml));\n  }\n\n  /**\n   * Just indicate that this is XML data\n   */\n  public toString() {\n    return 'XML data';\n  }\n\n}\n"]},"metadata":{},"sourceType":"script"}