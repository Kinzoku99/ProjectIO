{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractFactory = void 0;\n\nvar AbstractFactory = function () {\n  function AbstractFactory(nodes) {\n    var e_1, _a;\n\n    if (nodes === void 0) {\n      nodes = null;\n    }\n\n    this.defaultKind = 'unknown';\n    this.nodeMap = new Map();\n    this.node = {};\n\n    if (nodes === null) {\n      nodes = this.constructor.defaultNodes;\n    }\n\n    try {\n      for (var _b = __values(Object.keys(nodes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var kind = _c.value;\n        this.setNodeClass(kind, nodes[kind]);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n\n  AbstractFactory.prototype.create = function (kind) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    return (this.node[kind] || this.node[this.defaultKind]).apply(void 0, __spreadArray([], __read(args)));\n  };\n\n  AbstractFactory.prototype.setNodeClass = function (kind, nodeClass) {\n    this.nodeMap.set(kind, nodeClass);\n    var THIS = this;\n    var KIND = this.nodeMap.get(kind);\n\n    this.node[kind] = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return new (KIND.bind.apply(KIND, __spreadArray([void 0, THIS], __read(args))))();\n    };\n  };\n\n  AbstractFactory.prototype.getNodeClass = function (kind) {\n    return this.nodeMap.get(kind);\n  };\n\n  AbstractFactory.prototype.deleteNodeClass = function (kind) {\n    this.nodeMap.delete(kind);\n    delete this.node[kind];\n  };\n\n  AbstractFactory.prototype.nodeIsKind = function (node, kind) {\n    return node instanceof this.getNodeClass(kind);\n  };\n\n  AbstractFactory.prototype.getKinds = function () {\n    return Array.from(this.nodeMap.keys());\n  };\n\n  AbstractFactory.defaultNodes = {};\n  return AbstractFactory;\n}();\n\nexports.AbstractFactory = AbstractFactory;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsHA;AAyBE,2BAAYA,KAAZ,EAA6C;;;AAAjC;AAAAA;AAAiC;;AAftC,uBAAc,SAAd;AAKG,mBAA0B,IAAIC,GAAJ,EAA1B;AAKA,gBAAgD,EAAhD;;AAMR,QAAID,KAAK,KAAK,IAAd,EAAoB;AAClBA,WAAK,GAAI,KAAKE,WAAL,CAAgDC,YAAzD;AACD;;;AACD,WAAmB,wBAAM,CAACC,IAAP,CAAYJ,KAAZ,IAAkBK,cAArC,EAAqC,QAArC,EAAqCA,cAArC,EAAuC;AAAlC,YAAMC,IAAI,WAAV;AACH,aAAKC,YAAL,CAAkBD,IAAlB,EAAwBN,KAAK,CAACM,IAAD,CAA7B;AACD;;;;;;;;;;;;AACF;;AAKME,qCAAP,UAAcF,IAAd,EAA0B;AAAE;;SAAA,yCAAc;AAAdG;;;AAC1B,WAAO,CAAC,KAAKC,IAAL,CAAUJ,IAAV,KAAmB,KAAKI,IAAL,CAAU,KAAKC,WAAf,CAApB,EAAgDC,KAAhD,CAAgD,MAAhD,EAAgDC,yBAAIJ,IAAJ,EAAhD,CAAP;AACD,GAFM;;AAOAD,2CAAP,UAAoBF,IAApB,EAAkCQ,SAAlC,EAA8C;AAC5C,SAAKC,OAAL,CAAaC,GAAb,CAAiBV,IAAjB,EAAuBQ,SAAvB;AACA,QAAIG,IAAI,GAAG,IAAX;AACA,QAAIC,IAAI,GAAG,KAAKH,OAAL,CAAaI,GAAb,CAAiBb,IAAjB,CAAX;;AACA,SAAKI,IAAL,CAAUJ,IAAV,IAAkB;AAAC;;WAAA,yCAAc;AAAdG;;;AACjB,kBAAWS,IAAI,KAAJ,CAAIN,KAAJ,OAAIC,uBAACI,IAAD,GAAKG,OAAKX,IAAL,CAAL,CAAJ,CAAX;AACD,KAFD;AAGD,GAPM;;AAWAD,2CAAP,UAAoBF,IAApB,EAAgC;AAC9B,WAAO,KAAKS,OAAL,CAAaI,GAAb,CAAiBb,IAAjB,CAAP;AACD,GAFM;;AAOAE,8CAAP,UAAuBF,IAAvB,EAAmC;AACjC,SAAKS,OAAL,CAAaM,MAAb,CAAoBf,IAApB;AACA,WAAO,KAAKI,IAAL,CAAUJ,IAAV,CAAP;AACD,GAHM;;AAQAE,yCAAP,UAAkBE,IAAlB,EAA2BJ,IAA3B,EAAuC;AACrC,WAAQI,IAAI,YAAY,KAAKY,YAAL,CAAkBhB,IAAlB,CAAxB;AACD,GAFM;;AAOAE,uCAAP;AACE,WAAOe,KAAK,CAACC,IAAN,CAAW,KAAKT,OAAL,CAAaX,IAAb,EAAX,CAAP;AACD,GAFM;;AAxEOI,iCAAe,EAAf;AA4EhB;AAjFA;;AAAsBiB","names":["nodes","Map","constructor","defaultNodes","keys","_c","kind","setNodeClass","AbstractFactory","args","node","defaultKind","apply","__spreadArray","nodeClass","nodeMap","set","THIS","KIND","get","__read","delete","getNodeClass","Array","from","exports"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/core/Tree/Factory.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  The generic Factory class for creating arbitrary objects\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\n/*****************************************************************/\n/**\n * The Factory node interfaces (one for the node instance, one for the node class)\n */\n\nexport interface FactoryNode {\n  readonly kind: string;\n}\n\n/**\n * @template N  The Node type being created by the factory\n */\nexport interface FactoryNodeClass<N extends FactoryNode> {\n  /**\n   * @param {Factory<N, FactoryNodeClass<N>>} factory  The factory for creating more nodes\n   * @param {any[]} args  Any additional arguments needed by the node\n   * @return {N}  The newly created node\n   */\n  new(factory: Factory<N, FactoryNodeClass<N>>, ...args: any[]): N;\n}\n\n/*****************************************************************/\n/**\n * The Factory interface\n *\n * Factory<N, C> takes a node type N and a node class C, which give\n * the interfaces for the node instance and the node constructors. We\n * need both for two reasons: first, you can't use typeof N to get C,\n * since N is a type not an object, and if N has static members, we\n * may want to access them from the results of getNodeClass(kind)\n * (this is done in MmlNodes, for example).\n *\n * @template N  The node type created by the factory\n * @template C  The class of the node being constructed (for access to static properties)\n */\nexport interface Factory<N extends FactoryNode, C extends FactoryNodeClass<N>> {\n  /**\n   * @param {string} kind  The kind of node to create\n   * @return {N}  The newly created node of the given kind\n   */\n  create(kind: string): N;\n\n  /**\n   * Defines a class for a given node kind\n   *\n   * @param {string} kind  The kind whose class is being defined\n   * @param {C} nodeClass  The class for the given kind\n   */\n  setNodeClass(kind: string, nodeClass: C): void;\n\n  /**\n   * @param {string} kind  The kind of node whose class is to be returned\n   * @return {C}  The class object for the given kind\n   */\n  getNodeClass(kind: string): C;\n\n  /**\n   * @param {string} kind  The kind whose definition is to be deleted\n   */\n  deleteNodeClass(kind: string): void;\n\n  /**\n   * @param {N} node  The node to test if it is of a given kind\n   * @param {string} kind  The kind to test for\n   * @return {boolean}  True if the node is of the given kind, false otherwise\n   */\n  nodeIsKind(node: N, kind: string): boolean;\n\n  /**\n   * @return {string[]}  The names of all the available kinds of nodes\n   */\n  getKinds(): string[];\n}\n\n\n/*****************************************************************/\n/**\n * The generic AbstractFactoryClass interface\n *   (needed for access to defaultNodes via the constructor)\n *\n * @template N  The node type created by the factory\n * @template C  The class of the node being constructed (for access to static properties)\n */\ninterface AbstractFactoryClass<N extends FactoryNode, C extends FactoryNodeClass<N>> extends Function {\n  defaultNodes: {[kind: string]: C};\n}\n\n\n/*****************************************************************/\n/**\n * The generic AbstractFactory class\n *\n * @template N  The node type created by the factory\n * @template C  The class of the node being constructed (for access to static properties)\n */\nexport abstract class AbstractFactory<N extends FactoryNode, C extends FactoryNodeClass<N>> implements Factory<N, C> {\n\n  /**\n   * The default collection of objects to use for the node map\n   */\n  public static defaultNodes = {};\n\n  /**\n   * The default kind\n   */\n  public defaultKind = 'unknown';\n\n  /**\n   * The map of node kinds to node classes\n   */\n  protected nodeMap: Map<string, C> = new Map();\n\n  /**\n   * An object containing functions for creating the various node kinds\n   */\n  protected node: {[kind: string]: (...args: any[]) => N} = {};\n\n  /**\n   * @override\n   */\n  constructor(nodes: {[kind: string]: C} = null) {\n    if (nodes === null) {\n      nodes = (this.constructor as AbstractFactoryClass<N, C>).defaultNodes;\n    }\n    for (const kind of Object.keys(nodes)) {\n      this.setNodeClass(kind, nodes[kind]);\n    }\n  }\n\n  /**\n   * @override\n   */\n  public create(kind: string, ...args: any[]) {\n    return (this.node[kind] || this.node[this.defaultKind])(...args);\n  }\n\n  /**\n   * @override\n   */\n  public setNodeClass(kind: string, nodeClass: C) {\n    this.nodeMap.set(kind, nodeClass);\n    let THIS = this;\n    let KIND = this.nodeMap.get(kind);\n    this.node[kind] = (...args: any[]) => {\n      return new KIND(THIS, ...args);\n    };\n  }\n  /**\n   * @override\n   */\n  public getNodeClass(kind: string): C {\n    return this.nodeMap.get(kind);\n  }\n\n  /**\n   * @override\n   */\n  public deleteNodeClass(kind: string) {\n    this.nodeMap.delete(kind);\n    delete this.node[kind];\n  }\n\n  /**\n   * @override\n   */\n  public nodeIsKind(node: N, kind: string) {\n    return (node instanceof this.getNodeClass(kind));\n  }\n\n  /**\n   * @override\n   */\n  public getKinds() {\n    return Array.from(this.nodeMap.keys());\n  }\n\n}\n"]},"metadata":{},"sourceType":"script"}