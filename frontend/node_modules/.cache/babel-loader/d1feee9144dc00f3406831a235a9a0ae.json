{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Arrow = exports.DiagonalArrow = exports.DiagonalStrike = exports.Border2 = exports.Border = exports.RenderLine = exports.lineOffset = exports.lineData = exports.computeLineData = void 0;\n\nvar Notation = require(\"../common/Notation.js\");\n\n__exportStar(require(\"../common/Notation.js\"), exports);\n\nexports.computeLineData = {\n  top: function (h, _d, w, t) {\n    return [0, h - t, w, h - t];\n  },\n  right: function (h, d, w, t) {\n    return [w - t, -d, w - t, h];\n  },\n  bottom: function (_h, d, w, t) {\n    return [0, t - d, w, t - d];\n  },\n  left: function (h, d, _w, t) {\n    return [t, -d, t, h];\n  },\n  vertical: function (h, d, w, _t) {\n    return [w / 2, h, w / 2, -d];\n  },\n  horizontal: function (h, d, w, _t) {\n    return [0, (h - d) / 2, w, (h - d) / 2];\n  },\n  up: function (h, d, w, t) {\n    return [t, t - d, w - t, h - t];\n  },\n  down: function (h, d, w, t) {\n    return [t, h - t, w - t, t - d];\n  }\n};\n\nvar lineData = function (node, kind, offset) {\n  if (offset === void 0) {\n    offset = '';\n  }\n\n  var _a = node.getBBox(),\n      h = _a.h,\n      d = _a.d,\n      w = _a.w;\n\n  var t = node.thickness / 2;\n  return exports.lineOffset(exports.computeLineData[kind](h, d, w, t), node, offset);\n};\n\nexports.lineData = lineData;\n\nvar lineOffset = function (data, node, offset) {\n  if (offset) {\n    var d = node.getOffset(offset);\n\n    if (d) {\n      if (offset === 'X') {\n        data[0] -= d;\n        data[2] -= d;\n      } else {\n        data[1] -= d;\n        data[3] -= d;\n      }\n    }\n  }\n\n  return data;\n};\n\nexports.lineOffset = lineOffset;\n\nvar RenderLine = function (line, offset) {\n  if (offset === void 0) {\n    offset = '';\n  }\n\n  return function (node, _child) {\n    var L = node.line(exports.lineData(node, line, offset));\n    node.adaptor.append(node.element, L);\n  };\n};\n\nexports.RenderLine = RenderLine;\n\nvar Border = function (side) {\n  return Notation.CommonBorder(function (node, _child) {\n    node.adaptor.append(node.element, node.line(exports.lineData(node, side)));\n  })(side);\n};\n\nexports.Border = Border;\n\nvar Border2 = function (name, side1, side2) {\n  return Notation.CommonBorder2(function (node, _child) {\n    node.adaptor.append(node.element, node.line(exports.lineData(node, side1)));\n    node.adaptor.append(node.element, node.line(exports.lineData(node, side2)));\n  })(name, side1, side2);\n};\n\nexports.Border2 = Border2;\n\nvar DiagonalStrike = function (name) {\n  return Notation.CommonDiagonalStrike(function (_cname) {\n    return function (node, _child) {\n      node.adaptor.append(node.element, node.line(exports.lineData(node, name)));\n    };\n  })(name);\n};\n\nexports.DiagonalStrike = DiagonalStrike;\n\nvar DiagonalArrow = function (name) {\n  return Notation.CommonDiagonalArrow(function (node, arrow) {\n    node.adaptor.append(node.element, arrow);\n  })(name);\n};\n\nexports.DiagonalArrow = DiagonalArrow;\n\nvar Arrow = function (name) {\n  return Notation.CommonArrow(function (node, arrow) {\n    node.adaptor.append(node.element, arrow);\n  })(name);\n};\n\nexports.Arrow = Arrow;","map":{"version":3,"mappings":"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","names":["__exportStar","exports","top","h","_d","w","t","right","d","bottom","_h","left","_w","vertical","_t","horizontal","up","down","lineData","node","kind","offset","getBBox","thickness","lineOffset","data","getOffset","RenderLine","line","_child","L","adaptor","append","element","Border","side","Notation","CommonBorder","Border2","name","side1","side2","CommonBorder2","DiagonalStrike","CommonDiagonalStrike","_cname","DiagonalArrow","CommonDiagonalArrow","arrow","Arrow","CommonArrow"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/output/svg/Notation.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements utilities for notations for menclose elements\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {SVGmenclose} from './Wrappers/menclose.js';\nimport * as Notation from '../common/Notation.js';\nexport * from '../common/Notation.js';\n\n/*******************************************************************/\n\n/**\n * Shorthand for SVGmenclose\n */\nexport type Menclose = SVGmenclose<any, any, any>;\n\n\n/*\n * Shorthands for common types\n */\nexport type RENDERER<N, T, D> = Notation.Renderer<SVGmenclose<N, T, D>, N>;\nexport type DEFPAIR<N, T, D> = Notation.DefPair<SVGmenclose<N, T, D>, N>;\n\n/**\n * The kinds of lines that can be drawn\n */\nexport type LineName = Notation.Side | ('vertical' | 'horizontal' | 'up' | 'down');\n\n/**\n * [x1,y1, x2,y2] endpoints for a line\n */\nexport type LineData = [number, number, number, number];\n\n/**\n * Functions for computing the line data for each type of line\n */\nexport const computeLineData = {\n  top: (h, _d, w, t) => [0, h - t, w, h - t],\n  right: (h, d, w, t) => [w - t, -d, w - t, h],\n  bottom: (_h, d, w, t) => [0, t - d, w, t - d],\n  left: (h, d, _w, t) => [t, -d, t, h],\n  vertical: (h, d, w, _t) => [w / 2, h, w / 2, -d],\n  horizontal: (h, d, w, _t) => [0, (h - d) / 2, w, (h - d) / 2],\n  up: (h, d, w, t) => [t, t - d, w - t, h - t],\n  down: (h, d, w, t) => [t, h - t, w - t, t - d]\n} as {[kind: string]: (h: number, d: number, w: number, t: number) => LineData};\n\n/**\n * The data for a given line as two endpoints: [x1, y1, x2, y1]\n *\n * @param {Menclose} node   The node whose line is to be drawn\n * @param {LineName} kind   The type of line to draw for the node\n * @param {string} offset   The offset direction, if any\n * @return {LineData}       The coordinates of the two endpoints\n */\nexport const lineData = function(node: Menclose, kind: LineName, offset: string = ''): LineData {\n  const {h, d, w} = node.getBBox();\n  const t = node.thickness / 2;\n  return lineOffset(computeLineData[kind](h, d, w, t), node, offset);\n};\n\n/**\n * Recenter the line data for vertical and horizontal lines\n *\n * @param {LineData} data   The line endpoints to adjust\n * @param {Menclose} node   The menclose node\n * @param {string} offset   The direction to offset\n */\nexport const lineOffset = function(data: LineData, node: Menclose, offset: string): LineData {\n  if (offset) {\n    const d = node.getOffset(offset);\n    if (d) {\n      if (offset === 'X') {\n        data[0] -= d;\n        data[2] -= d;\n      } else {\n        data[1] -= d;\n        data[3] -= d;\n      }\n    }\n  }\n  return data;\n};\n\n\n/*******************************************************************/\n\n/**\n * @param {LineName} line  The name of the line to create\n * @return {RENDERER}      The renderer function for the given line\n */\nexport const RenderLine = function<N, T, D>(line: LineName, offset: string = ''): RENDERER<N, T, D> {\n  return ((node, _child) => {\n    const L = node.line(lineData(node, line, offset));\n    node.adaptor.append(node.element, L);\n  });\n};\n\n/*******************************************************************/\n\n/**\n * @param {Notation.Side} side   The kind of line (side, diagonal, etc.)\n * @return {DEFPAIR}      The notation definition for the notation having a line on the given side\n */\nexport const Border = function<N, T, D>(side: Notation.Side): DEFPAIR<N, T, D> {\n  return Notation.CommonBorder<SVGmenclose<N, T, D>, N>((node, _child) => {\n    node.adaptor.append(node.element, node.line(lineData(node, side)));\n  })(side);\n};\n\n\n/**\n * @param {string} name    The name of the notation to define\n * @param {Notation.Side} side1   The first side to get a border\n * @param {Notation.Side} side2   The second side to get a border\n * @return {DEFPAIR}       The notation definition for the notation having lines on two sides\n */\nexport const Border2 = function<N, T, D>(name: string, side1: Notation.Side, side2: Notation.Side): DEFPAIR<N, T, D> {\n  return Notation.CommonBorder2<SVGmenclose<N, T, D>, N>((node, _child) => {\n    node.adaptor.append(node.element, node.line(lineData(node, side1)));\n    node.adaptor.append(node.element, node.line(lineData(node, side2)));\n  })(name, side1, side2);\n};\n\n/*******************************************************************/\n\n/**\n * @param {LineName} name  The name of the diagonal strike to define\n * @return {DEFPAIR}       The notation definition for the diagonal strike\n */\nexport const DiagonalStrike = function<N, T, D>(name: LineName): DEFPAIR<N, T, D> {\n  return Notation.CommonDiagonalStrike<SVGmenclose<N, T, D>, N>((_cname: string) => (node, _child) => {\n    node.adaptor.append(node.element, node.line(lineData(node, name)));\n  })(name);\n};\n\n/*******************************************************************/\n\n/**\n * @param {string} name   The name of the diagonal arrow to define\n * @return {DEFPAIR}      The notation definition for the diagonal arrow\n */\nexport const DiagonalArrow = function<N, T, D>(name: string): DEFPAIR<N, T, D> {\n  return Notation.CommonDiagonalArrow<SVGmenclose<N, T, D>, N>((node, arrow) => {\n    node.adaptor.append(node.element, arrow);\n  })(name);\n};\n\n/**\n * @param {string} name   The name of the horizontal or vertical arrow to define\n * @return {DEFPAIR}      The notation definition for the arrow\n */\nexport const Arrow = function<N, T, D>(name: string): DEFPAIR<N, T, D> {\n  return Notation.CommonArrow<SVGmenclose<N, T, D>, N>((node, arrow) => {\n    node.adaptor.append(node.element, arrow);\n  })(name);\n};\n\n/*******************************************************************/\n"]},"metadata":{},"sourceType":"script"}