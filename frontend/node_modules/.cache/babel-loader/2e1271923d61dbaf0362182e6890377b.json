{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MathMLCompile = void 0;\n\nvar MmlNode_js_1 = require(\"../../core/MmlTree/MmlNode.js\");\n\nvar Options_js_1 = require(\"../../util/Options.js\");\n\nvar Entities = require(\"../../util/Entities.js\");\n\nvar MathMLCompile = function () {\n  function MathMLCompile(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var Class = this.constructor;\n    this.options = Options_js_1.userOptions(Options_js_1.defaultOptions({}, Class.OPTIONS), options);\n  }\n\n  MathMLCompile.prototype.setMmlFactory = function (mmlFactory) {\n    this.factory = mmlFactory;\n  };\n\n  MathMLCompile.prototype.compile = function (node) {\n    var mml = this.makeNode(node);\n    mml.verifyTree(this.options['verify']);\n    mml.setInheritedAttributes({}, false, 0, false);\n    mml.walkTree(this.markMrows);\n    return mml;\n  };\n\n  MathMLCompile.prototype.makeNode = function (node) {\n    var e_1, _a;\n\n    var adaptor = this.adaptor;\n    var limits = false;\n    var kind = adaptor.kind(node).replace(/^.*:/, '');\n    var texClass = adaptor.getAttribute(node, 'data-mjx-texclass') || '';\n\n    if (texClass) {\n      texClass = this.filterAttribute('data-mjx-texclass', texClass) || '';\n    }\n\n    var type = texClass && kind === 'mrow' ? 'TeXAtom' : kind;\n\n    try {\n      for (var _b = __values(this.filterClassList(adaptor.allClasses(node))), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var name_1 = _c.value;\n\n        if (name_1.match(/^MJX-TeXAtom-/)) {\n          texClass = name_1.substr(12);\n          type = 'TeXAtom';\n        } else if (name_1 === 'MJX-fixedlimits') {\n          limits = true;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    this.factory.getNodeClass(type) || this.error('Unknown node type \"' + type + '\"');\n    var mml = this.factory.create(type);\n\n    if (type === 'TeXAtom' && texClass === 'OP' && !limits) {\n      mml.setProperty('movesupsub', true);\n      mml.attributes.setInherited('movablelimits', true);\n    }\n\n    if (texClass) {\n      mml.texClass = MmlNode_js_1.TEXCLASS[texClass];\n      mml.setProperty('texClass', mml.texClass);\n    }\n\n    this.addAttributes(mml, node);\n    this.checkClass(mml, node);\n    this.addChildren(mml, node);\n    return mml;\n  };\n\n  MathMLCompile.prototype.addAttributes = function (mml, node) {\n    var e_2, _a;\n\n    var ignoreVariant = false;\n\n    try {\n      for (var _b = __values(this.adaptor.allAttributes(node)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var attr = _c.value;\n        var name_2 = attr.name;\n        var value = this.filterAttribute(name_2, attr.value);\n\n        if (value === null || name_2 === 'xmlns') {\n          continue;\n        }\n\n        if (name_2.substr(0, 9) === 'data-mjx-') {\n          if (name_2 === 'data-mjx-alternate') {\n            mml.setProperty('variantForm', true);\n          } else if (name_2 === 'data-mjx-variant') {\n            mml.attributes.set('mathvariant', value);\n            ignoreVariant = true;\n          } else if (name_2 === 'data-mjx-smallmatrix') {\n            mml.setProperty('scriptlevel', 1);\n            mml.setProperty('useHeight', false);\n          } else if (name_2 === 'data-mjx-accent') {\n            mml.setProperty('mathaccent', value === 'true');\n          } else if (name_2 === 'data-mjx-auto-op') {\n            mml.setProperty('autoOP', value === 'true');\n          }\n        } else if (name_2 !== 'class') {\n          var val = value.toLowerCase();\n\n          if (val === 'true' || val === 'false') {\n            mml.attributes.set(name_2, val === 'true');\n          } else if (!ignoreVariant || name_2 !== 'mathvariant') {\n            mml.attributes.set(name_2, value);\n          }\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  };\n\n  MathMLCompile.prototype.filterAttribute = function (_name, value) {\n    return value;\n  };\n\n  MathMLCompile.prototype.filterClassList = function (list) {\n    return list;\n  };\n\n  MathMLCompile.prototype.addChildren = function (mml, node) {\n    var e_3, _a;\n\n    if (mml.arity === 0) {\n      return;\n    }\n\n    var adaptor = this.adaptor;\n\n    try {\n      for (var _b = __values(adaptor.childNodes(node)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n        var name_3 = adaptor.kind(child);\n\n        if (name_3 === '#comment') {\n          continue;\n        }\n\n        if (name_3 === '#text') {\n          this.addText(mml, child);\n        } else if (mml.isKind('annotation-xml')) {\n          mml.appendChild(this.factory.create('XML').setXML(child, adaptor));\n        } else {\n          var childMml = mml.appendChild(this.makeNode(child));\n\n          if (childMml.arity === 0 && adaptor.childNodes(child).length) {\n            if (this.options['fixMisplacedChildren']) {\n              this.addChildren(mml, child);\n            } else {\n              childMml.mError('There should not be children for ' + childMml.kind + ' nodes', this.options['verify'], true);\n            }\n          }\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n  };\n\n  MathMLCompile.prototype.addText = function (mml, child) {\n    var text = this.adaptor.value(child);\n\n    if ((mml.isToken || mml.getProperty('isChars')) && mml.arity) {\n      if (mml.isToken) {\n        text = Entities.translate(text);\n        text = this.trimSpace(text);\n      }\n\n      mml.appendChild(this.factory.create('text').setText(text));\n    } else if (text.match(/\\S/)) {\n      this.error('Unexpected text node \"' + text + '\"');\n    }\n  };\n\n  MathMLCompile.prototype.checkClass = function (mml, node) {\n    var e_4, _a;\n\n    var classList = [];\n\n    try {\n      for (var _b = __values(this.filterClassList(this.adaptor.allClasses(node))), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var name_4 = _c.value;\n\n        if (name_4.substr(0, 4) === 'MJX-') {\n          if (name_4 === 'MJX-variant') {\n            mml.setProperty('variantForm', true);\n          } else if (name_4.substr(0, 11) !== 'MJX-TeXAtom') {\n            mml.attributes.set('mathvariant', this.fixCalligraphic(name_4.substr(3)));\n          }\n        } else {\n          classList.push(name_4);\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    if (classList.length) {\n      mml.attributes.set('class', classList.join(' '));\n    }\n  };\n\n  MathMLCompile.prototype.fixCalligraphic = function (variant) {\n    return variant.replace(/caligraphic/, 'calligraphic');\n  };\n\n  MathMLCompile.prototype.markMrows = function (mml) {\n    if (mml.isKind('mrow') && !mml.isInferred && mml.childNodes.length >= 2) {\n      var first = mml.childNodes[0];\n      var last = mml.childNodes[mml.childNodes.length - 1];\n\n      if (first.isKind('mo') && first.attributes.get('fence') && first.attributes.get('stretchy') && last.isKind('mo') && last.attributes.get('fence') && last.attributes.get('stretchy')) {\n        if (first.childNodes.length) {\n          mml.setProperty('open', first.getText());\n        }\n\n        if (last.childNodes.length) {\n          mml.setProperty('close', last.getText());\n        }\n      }\n    }\n  };\n\n  MathMLCompile.prototype.trimSpace = function (text) {\n    return text.replace(/[\\t\\n\\r]/g, ' ').replace(/^ +/, '').replace(/ +$/, '').replace(/  +/g, ' ');\n  };\n\n  MathMLCompile.prototype.error = function (message) {\n    throw new Error(message);\n  };\n\n  MathMLCompile.OPTIONS = {\n    MmlFactory: null,\n    fixMisplacedChildren: true,\n    verify: __assign({}, MmlNode_js_1.AbstractMmlNode.verifyDefaults),\n    translateEntities: true\n  };\n  return MathMLCompile;\n}();\n\nexports.MathMLCompile = MathMLCompile;","map":{"version":3,"mappings":"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","names":["options","Class","constructor","Options_js_1","OPTIONS","MathMLCompile","mmlFactory","factory","node","mml","makeNode","verifyTree","setInheritedAttributes","walkTree","markMrows","adaptor","limits","kind","replace","texClass","getAttribute","filterAttribute","type","filterClassList","allClasses","_c","name_1","match","substr","getNodeClass","error","create","setProperty","attributes","setInherited","MmlNode_js_1","addAttributes","checkClass","addChildren","ignoreVariant","allAttributes","attr","name_2","name","value","set","val","toLowerCase","_name","list","arity","childNodes","child","name_3","addText","isKind","appendChild","setXML","childMml","length","mError","text","isToken","getProperty","Entities","translate","trimSpace","setText","classList","name_4","fixCalligraphic","push","join","variant","isInferred","first","last","get","getText","message","Error","MmlFactory","fixMisplacedChildren","verify","verifyDefaults","translateEntities","exports"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/input/mathml/MathMLCompile.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implementation of the Compile function for the MathML input jax\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {MmlFactory} from '../../core/MmlTree/MmlFactory.js';\nimport {MmlNode, TextNode, XMLNode, AbstractMmlNode, AbstractMmlTokenNode, TEXCLASS}\nfrom '../../core/MmlTree/MmlNode.js';\nimport {userOptions, defaultOptions, OptionList} from '../../util/Options.js';\nimport * as Entities from '../../util/Entities.js';\nimport {DOMAdaptor} from '../../core/DOMAdaptor.js';\n\n/********************************************************************/\n/**\n *  The class for performing the MathML DOM node to\n *  internal MmlNode conversion.\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport class MathMLCompile<N, T, D> {\n\n  /**\n   *  The default options for this object\n   */\n  public static OPTIONS: OptionList = {\n    MmlFactory: null,                   // The MmlFactory to use (defaults to a new MmlFactory)\n    fixMisplacedChildren: true,         // True if we want to use heuristics to try to fix\n                                        //   problems with the tree based on HTML not handling\n                                        //   self-closing tags properly\n    verify: {                           // Options to pass to verifyTree() controlling MathML verification\n      ...AbstractMmlNode.verifyDefaults\n    },\n    translateEntities: true             // True means translate entities in text nodes\n  };\n\n  /**\n   * The DOMAdaptor for the document being processed\n   */\n  public adaptor: DOMAdaptor<N, T, D>;\n\n  /**\n   *  The instance of the MmlFactory object and\n   */\n  protected factory: MmlFactory;\n  /**\n   *  The options (the defaults with the user options merged in)\n   */\n  protected options: OptionList;\n\n  /**\n   *  Merge the user options into the defaults, and save them\n   *  Create the MmlFactory object\n   *\n   * @param {OptionList} options  The options controlling the conversion\n   */\n  constructor(options: OptionList = {}) {\n    const Class = this.constructor as typeof MathMLCompile;\n    this.options = userOptions(defaultOptions({}, Class.OPTIONS), options);\n  }\n\n  /**\n   * @param{MmlFactory} mmlFactory   The MathML factory to use for new nodes\n   */\n  public setMmlFactory(mmlFactory: MmlFactory) {\n    this.factory = mmlFactory;\n  }\n\n  /**\n   * Convert a MathML DOM tree to internal MmlNodes\n   *\n   * @param {N} node     The <math> node to convert to MmlNodes\n   * @return {MmlNode}   The MmlNode at the root of the converted tree\n   */\n  public compile(node: N): MmlNode {\n    let mml = this.makeNode(node);\n    mml.verifyTree(this.options['verify']);\n    mml.setInheritedAttributes({}, false, 0, false);\n    mml.walkTree(this.markMrows);\n    return mml;\n  }\n\n  /**\n   * Recursively convert nodes and their children, taking MathJax classes\n   * into account.\n   *\n   *  FIXME: we should use data-* attributes rather than classes for these\n   *\n   * @param {N} node     The node to convert to an MmlNode\n   * @return {MmlNode}   The converted MmlNode\n   */\n  public makeNode(node: N): MmlNode {\n    const adaptor = this.adaptor;\n    let limits = false;\n    let kind = adaptor.kind(node).replace(/^.*:/, '');\n    let texClass = adaptor.getAttribute(node, 'data-mjx-texclass') || '';\n    if (texClass) {\n      texClass = this.filterAttribute('data-mjx-texclass', texClass) || '';\n    }\n    let type = texClass && kind === 'mrow' ? 'TeXAtom' : kind;\n    for (const name of this.filterClassList(adaptor.allClasses(node))) {\n      if (name.match(/^MJX-TeXAtom-/)) {\n        texClass = name.substr(12);\n        type = 'TeXAtom';\n      } else if (name === 'MJX-fixedlimits') {\n        limits = true;\n      }\n    }\n    this.factory.getNodeClass(type) || this.error('Unknown node type \"' + type + '\"');\n    let mml = this.factory.create(type);\n    if (type === 'TeXAtom' && texClass === 'OP' && !limits) {\n      mml.setProperty('movesupsub', true);\n      mml.attributes.setInherited('movablelimits', true);\n    }\n    if (texClass) {\n      mml.texClass = (TEXCLASS as {[name: string]: number})[texClass];\n      mml.setProperty('texClass', mml.texClass);\n    }\n    this.addAttributes(mml, node);\n    this.checkClass(mml, node);\n    this.addChildren(mml, node);\n    return mml;\n  }\n\n  /**\n   * Copy the attributes from a MathML node to an MmlNode.\n   *\n   * @param {MmlNode} mml       The MmlNode to which attributes will be added\n   * @param {N} node  The MathML node whose attributes to copy\n   */\n  protected addAttributes(mml: MmlNode, node: N) {\n    let ignoreVariant = false;\n    for (const attr of this.adaptor.allAttributes(node)) {\n      let name = attr.name;\n      let value = this.filterAttribute(name, attr.value);\n      if (value === null || name === 'xmlns') {\n        continue;\n      }\n      if (name.substr(0, 9) === 'data-mjx-') {\n        if (name === 'data-mjx-alternate') {\n          mml.setProperty('variantForm', true);\n        } else if (name === 'data-mjx-variant') {\n          mml.attributes.set('mathvariant', value);\n          ignoreVariant = true;\n        } else if (name === 'data-mjx-smallmatrix') {\n          mml.setProperty('scriptlevel', 1);\n          mml.setProperty('useHeight', false);\n        } else if (name === 'data-mjx-accent') {\n          mml.setProperty('mathaccent', value === 'true');\n        } else if (name === 'data-mjx-auto-op') {\n          mml.setProperty('autoOP', value === 'true');\n        }\n      } else if (name !== 'class') {\n        let val = value.toLowerCase();\n        if (val === 'true' || val === 'false') {\n          mml.attributes.set(name, val === 'true');\n        } else if (!ignoreVariant || name !== 'mathvariant') {\n          mml.attributes.set(name, value);\n        }\n      }\n    }\n  }\n\n  /**\n   * Provide a hook for the Safe extension to filter attribute values.\n   *\n   * @param {string} name   The name of an attribute to filter\n   * @param {string} value  The value to filter\n   */\n  protected filterAttribute(_name: string, value: string) {\n    return value;\n  }\n\n  /**\n   * Provide a hook for the Safe extension to filter class names.\n   *\n   * @param {string[]} list   The list of class names to filter\n   */\n  protected filterClassList(list: string[]) {\n    return list;\n  }\n\n  /**\n   * Convert the children of the MathML node and add them to the MmlNode\n   *\n   * @param {MmlNode} mml  The MmlNode to which children will be added\n   * @param {N} node       The MathML node whose children are to be copied\n   */\n  protected addChildren(mml: MmlNode, node: N) {\n    if (mml.arity === 0) {\n      return;\n    }\n    const adaptor = this.adaptor;\n    for (const child of adaptor.childNodes(node) as N[]) {\n      const name = adaptor.kind(child);\n      if (name === '#comment') {\n        continue;\n      }\n      if (name === '#text') {\n        this.addText(mml, child);\n      } else if (mml.isKind('annotation-xml')) {\n        mml.appendChild((this.factory.create('XML') as XMLNode).setXML(child, adaptor));\n      } else {\n        let childMml = mml.appendChild(this.makeNode(child)) as MmlNode;\n        if (childMml.arity === 0 && adaptor.childNodes(child).length) {\n          if (this.options['fixMisplacedChildren']) {\n            this.addChildren(mml, child);\n          } else {\n            childMml.mError('There should not be children for ' + childMml.kind + ' nodes',\n                            this.options['verify'], true);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Add text to a token node\n   *\n   * @param {MmlNode} mml  The MmlNode to which text will be added\n   * @param {N} child      The text node whose contents is to be copied\n   */\n  protected addText(mml: MmlNode, child: N) {\n    let text = this.adaptor.value(child);\n    if ((mml.isToken || mml.getProperty('isChars')) && mml.arity) {\n      if (mml.isToken) {\n        text = Entities.translate(text);\n        text = this.trimSpace(text);\n      }\n      mml.appendChild((this.factory.create('text') as TextNode).setText(text));\n    } else if (text.match(/\\S/)) {\n      this.error('Unexpected text node \"' + text + '\"');\n    }\n  }\n\n  /**\n   * Check for special MJX values in the class and process them\n   *\n   * @param {MmlNode} mml       The MmlNode to be modified according to the class markers\n   * @param {N} node  The MathML node whose class is to be processed\n   */\n  protected checkClass(mml: MmlNode, node: N) {\n    let classList = [];\n    for (const name of this.filterClassList(this.adaptor.allClasses(node))) {\n      if (name.substr(0, 4) === 'MJX-') {\n        if (name === 'MJX-variant') {\n          mml.setProperty('variantForm', true);\n        } else if (name.substr(0, 11) !== 'MJX-TeXAtom') {\n          mml.attributes.set('mathvariant', this.fixCalligraphic(name.substr(3)));\n        }\n      } else {\n        classList.push(name);\n      }\n    }\n    if (classList.length) {\n      mml.attributes.set('class', classList.join(' '));\n    }\n  }\n\n  /**\n   * Fix the old incorrect spelling of calligraphic.\n   *\n   * @param {string} variant  The mathvariant name\n   * @return {string}         The corrected variant\n   */\n  protected fixCalligraphic(variant: string): string {\n    return variant.replace(/caligraphic/, 'calligraphic');\n  }\n\n  /**\n   * Check to see if an mrow has delimiters at both ends (so looks like an mfenced structure).\n   *\n   * @param {MmlNode} mml  The node to check for mfenced structure\n   */\n  protected markMrows(mml: MmlNode) {\n    if (mml.isKind('mrow') && !mml.isInferred && mml.childNodes.length >= 2) {\n      let first = mml.childNodes[0] as MmlNode;\n      let last = mml.childNodes[mml.childNodes.length - 1] as MmlNode;\n      if (first.isKind('mo') && first.attributes.get('fence') && first.attributes.get('stretchy') &&\n          last.isKind('mo') && last.attributes.get('fence') && last.attributes.get('stretchy')) {\n        if (first.childNodes.length) {\n          mml.setProperty('open', (first as AbstractMmlTokenNode).getText());\n        }\n        if (last.childNodes.length) {\n          mml.setProperty('close', (last as AbstractMmlTokenNode).getText());\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {string} text  The text to have leading/trailing spaced removed\n   * @return {string}      The trimmed text\n   */\n  protected trimSpace(text: string): string {\n    return text.replace(/[\\t\\n\\r]/g, ' ')    // whitespace to spaces\n               .replace(/^ +/, '')           // initial whitespace\n               .replace(/ +$/, '')           // trailing whitespace\n               .replace(/  +/g, ' ');        // internal multiple whitespace\n  }\n\n  /**\n   * @param {string} message  The error message to produce\n   */\n  protected error(message: string) {\n    throw new Error(message);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}