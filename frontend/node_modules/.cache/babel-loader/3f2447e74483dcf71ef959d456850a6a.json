{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommonScriptbaseMixin = void 0;\n\nfunction CommonScriptbaseMixin(Base) {\n  var _a;\n\n  return _a = function (_super) {\n    __extends(class_1, _super);\n\n    function class_1() {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var _this = _super.apply(this, __spreadArray([], __read(args))) || this;\n\n      _this.baseScale = 1;\n      _this.baseIc = 0;\n      _this.baseRemoveIc = false;\n      _this.baseIsChar = false;\n      _this.baseHasAccentOver = null;\n      _this.baseHasAccentUnder = null;\n      _this.isLineAbove = false;\n      _this.isLineBelow = false;\n      _this.isMathAccent = false;\n\n      var core = _this.baseCore = _this.getBaseCore();\n\n      if (!core) return _this;\n\n      _this.setBaseAccentsFor(core);\n\n      _this.baseScale = _this.getBaseScale();\n      _this.baseIc = _this.getBaseIc();\n      _this.baseIsChar = _this.isCharBase();\n      _this.isMathAccent = _this.baseIsChar && _this.scriptChild && !!_this.scriptChild.coreMO().node.getProperty('mathaccent');\n\n      _this.checkLineAccents();\n\n      _this.baseRemoveIc = !_this.isLineAbove && !_this.isLineBelow && (!_this.constructor.useIC || _this.isMathAccent);\n      return _this;\n    }\n\n    Object.defineProperty(class_1.prototype, \"baseChild\", {\n      get: function () {\n        return this.childNodes[this.node.base];\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(class_1.prototype, \"scriptChild\", {\n      get: function () {\n        return this.childNodes[1];\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    class_1.prototype.getBaseCore = function () {\n      var core = this.getSemanticBase() || this.childNodes[0];\n\n      while (core && (core.childNodes.length === 1 && (core.node.isKind('mrow') || core.node.isKind('TeXAtom') || core.node.isKind('mstyle') || core.node.isKind('mpadded') || core.node.isKind('mphantom') || core.node.isKind('semantics')) || core.node.isKind('munderover') && core.isMathAccent)) {\n        this.setBaseAccentsFor(core);\n        core = core.childNodes[0];\n      }\n\n      if (!core) {\n        this.baseHasAccentOver = this.baseHasAccentUnder = false;\n      }\n\n      return core || this.childNodes[0];\n    };\n\n    class_1.prototype.setBaseAccentsFor = function (core) {\n      if (core.node.isKind('munderover')) {\n        if (this.baseHasAccentOver === null) {\n          this.baseHasAccentOver = !!core.node.attributes.get('accent');\n        }\n\n        if (this.baseHasAccentUnder === null) {\n          this.baseHasAccentUnder = !!core.node.attributes.get('accentunder');\n        }\n      }\n    };\n\n    class_1.prototype.getSemanticBase = function () {\n      var fence = this.node.attributes.getExplicit('data-semantic-fencepointer');\n      return this.getBaseFence(this.baseChild, fence);\n    };\n\n    class_1.prototype.getBaseFence = function (fence, id) {\n      var e_1, _a;\n\n      if (!fence || !fence.node.attributes || !id) {\n        return null;\n      }\n\n      if (fence.node.attributes.getExplicit('data-semantic-id') === id) {\n        return fence;\n      }\n\n      try {\n        for (var _b = __values(fence.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var child = _c.value;\n          var result = this.getBaseFence(child, id);\n\n          if (result) {\n            return result;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return null;\n    };\n\n    class_1.prototype.getBaseScale = function () {\n      var child = this.baseCore;\n      var scale = 1;\n\n      while (child && child !== this) {\n        var bbox = child.getBBox();\n        scale *= bbox.rscale;\n        child = child.parent;\n      }\n\n      return scale;\n    };\n\n    class_1.prototype.getBaseIc = function () {\n      return this.baseCore.getBBox().ic * this.baseScale;\n    };\n\n    class_1.prototype.getAdjustedIc = function () {\n      var bbox = this.baseCore.getBBox();\n      return (bbox.ic ? 1.05 * bbox.ic + .05 : 0) * this.baseScale;\n    };\n\n    class_1.prototype.isCharBase = function () {\n      var base = this.baseCore;\n      return (base.node.isKind('mo') && base.size === null || base.node.isKind('mi') || base.node.isKind('mn')) && base.bbox.rscale === 1 && Array.from(base.getText()).length === 1;\n    };\n\n    class_1.prototype.checkLineAccents = function () {\n      if (!this.node.isKind('munderover')) return;\n\n      if (this.node.isKind('mover')) {\n        this.isLineAbove = this.isLineAccent(this.scriptChild);\n      } else if (this.node.isKind('munder')) {\n        this.isLineBelow = this.isLineAccent(this.scriptChild);\n      } else {\n        var mml = this;\n        this.isLineAbove = this.isLineAccent(mml.overChild);\n        this.isLineBelow = this.isLineAccent(mml.underChild);\n      }\n    };\n\n    class_1.prototype.isLineAccent = function (script) {\n      var node = script.coreMO().node;\n      return node.isToken && node.getText() === '\\u2015';\n    };\n\n    class_1.prototype.getBaseWidth = function () {\n      var bbox = this.baseChild.getBBox();\n      return bbox.w * bbox.rscale - (this.baseRemoveIc ? this.baseIc : 0) + this.font.params.extra_ic;\n    };\n\n    class_1.prototype.computeBBox = function (bbox, recompute) {\n      if (recompute === void 0) {\n        recompute = false;\n      }\n\n      var w = this.getBaseWidth();\n\n      var _a = __read(this.getOffset(), 2),\n          x = _a[0],\n          y = _a[1];\n\n      bbox.append(this.baseChild.getBBox());\n      bbox.combine(this.scriptChild.getBBox(), w + x, y);\n      bbox.w += this.font.params.scriptspace;\n      bbox.clean();\n      this.setChildPWidths(recompute);\n    };\n\n    class_1.prototype.getOffset = function () {\n      return [0, 0];\n    };\n\n    class_1.prototype.baseCharZero = function (n) {\n      var largeop = !!this.baseCore.node.attributes.get('largeop');\n      var scale = this.baseScale;\n      return this.baseIsChar && !largeop && scale === 1 ? 0 : n;\n    };\n\n    class_1.prototype.getV = function () {\n      var bbox = this.baseCore.getBBox();\n      var sbox = this.scriptChild.getBBox();\n      var tex = this.font.params;\n      var subscriptshift = this.length2em(this.node.attributes.get('subscriptshift'), tex.sub1);\n      return Math.max(this.baseCharZero(bbox.d * this.baseScale + tex.sub_drop * sbox.rscale), subscriptshift, sbox.h * sbox.rscale - 4 / 5 * tex.x_height);\n    };\n\n    class_1.prototype.getU = function () {\n      var bbox = this.baseCore.getBBox();\n      var sbox = this.scriptChild.getBBox();\n      var tex = this.font.params;\n      var attr = this.node.attributes.getList('displaystyle', 'superscriptshift');\n      var prime = this.node.getProperty('texprimestyle');\n      var p = prime ? tex.sup3 : attr.displaystyle ? tex.sup1 : tex.sup2;\n      var superscriptshift = this.length2em(attr.superscriptshift, p);\n      return Math.max(this.baseCharZero(bbox.h * this.baseScale - tex.sup_drop * sbox.rscale), superscriptshift, sbox.d * sbox.rscale + 1 / 4 * tex.x_height);\n    };\n\n    class_1.prototype.hasMovableLimits = function () {\n      var display = this.node.attributes.get('displaystyle');\n      var mo = this.baseChild.coreMO().node;\n      return !display && !!mo.attributes.get('movablelimits');\n    };\n\n    class_1.prototype.getOverKU = function (basebox, overbox) {\n      var accent = this.node.attributes.get('accent');\n      var tex = this.font.params;\n      var d = overbox.d * overbox.rscale;\n      var t = tex.rule_thickness * tex.separation_factor;\n      var delta = this.baseHasAccentOver ? t : 0;\n      var T = this.isLineAbove ? 3 * tex.rule_thickness : t;\n      var k = (accent ? T : Math.max(tex.big_op_spacing1, tex.big_op_spacing3 - Math.max(0, d))) - delta;\n      return [k, basebox.h * basebox.rscale + k + d];\n    };\n\n    class_1.prototype.getUnderKV = function (basebox, underbox) {\n      var accent = this.node.attributes.get('accentunder');\n      var tex = this.font.params;\n      var h = underbox.h * underbox.rscale;\n      var t = tex.rule_thickness * tex.separation_factor;\n      var delta = this.baseHasAccentUnder ? t : 0;\n      var T = this.isLineBelow ? 3 * tex.rule_thickness : t;\n      var k = (accent ? T : Math.max(tex.big_op_spacing2, tex.big_op_spacing4 - h)) - delta;\n      return [k, -(basebox.d * basebox.rscale + k + h)];\n    };\n\n    class_1.prototype.getDeltaW = function (boxes, delta) {\n      var e_2, _a, e_3, _b;\n\n      if (delta === void 0) {\n        delta = [0, 0, 0];\n      }\n\n      var align = this.node.attributes.get('align');\n      var widths = boxes.map(function (box) {\n        return box.w * box.rscale;\n      });\n      widths[0] -= this.baseRemoveIc && !this.baseCore.node.attributes.get('largeop') ? this.baseIc : 0;\n      var w = Math.max.apply(Math, __spreadArray([], __read(widths)));\n      var dw = [];\n      var m = 0;\n\n      try {\n        for (var _c = __values(widths.keys()), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var i = _d.value;\n          dw[i] = (align === 'center' ? (w - widths[i]) / 2 : align === 'right' ? w - widths[i] : 0) + delta[i];\n\n          if (dw[i] < m) {\n            m = -dw[i];\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      if (m) {\n        try {\n          for (var _e = __values(dw.keys()), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var i = _f.value;\n            dw[i] += m;\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n      }\n\n      [1, 2].map(function (i) {\n        return dw[i] += boxes[i] ? boxes[i].dx * boxes[0].scale : 0;\n      });\n      return dw;\n    };\n\n    class_1.prototype.getDelta = function (noskew) {\n      if (noskew === void 0) {\n        noskew = false;\n      }\n\n      var accent = this.node.attributes.get('accent');\n\n      var _a = this.baseCore.getBBox(),\n          sk = _a.sk,\n          ic = _a.ic;\n\n      return ((accent && !noskew ? sk : 0) + this.font.skewIcFactor * ic) * this.baseScale;\n    };\n\n    class_1.prototype.stretchChildren = function () {\n      var e_4, _a, e_5, _b, e_6, _c;\n\n      var stretchy = [];\n\n      try {\n        for (var _d = __values(this.childNodes), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var child = _e.value;\n\n          if (child.canStretch(2)) {\n            stretchy.push(child);\n          }\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n\n      var count = stretchy.length;\n      var nodeCount = this.childNodes.length;\n\n      if (count && nodeCount > 1) {\n        var W = 0;\n        var all = count > 1 && count === nodeCount;\n\n        try {\n          for (var _f = __values(this.childNodes), _g = _f.next(); !_g.done; _g = _f.next()) {\n            var child = _g.value;\n            var noStretch = child.stretch.dir === 0;\n\n            if (all || noStretch) {\n              var _h = child.getBBox(noStretch),\n                  w = _h.w,\n                  rscale = _h.rscale;\n\n              if (w * rscale > W) W = w * rscale;\n            }\n          }\n        } catch (e_5_1) {\n          e_5 = {\n            error: e_5_1\n          };\n        } finally {\n          try {\n            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n          } finally {\n            if (e_5) throw e_5.error;\n          }\n        }\n\n        try {\n          for (var stretchy_1 = __values(stretchy), stretchy_1_1 = stretchy_1.next(); !stretchy_1_1.done; stretchy_1_1 = stretchy_1.next()) {\n            var child = stretchy_1_1.value;\n            child.coreMO().getStretchedVariant([W / child.bbox.rscale]);\n          }\n        } catch (e_6_1) {\n          e_6 = {\n            error: e_6_1\n          };\n        } finally {\n          try {\n            if (stretchy_1_1 && !stretchy_1_1.done && (_c = stretchy_1.return)) _c.call(stretchy_1);\n          } finally {\n            if (e_6) throw e_6.error;\n          }\n        }\n      }\n    };\n\n    return class_1;\n  }(Base), _a.useIC = true, _a;\n}\n\nexports.CommonScriptbaseMixin = CommonScriptbaseMixin;","map":{"version":3,"mappings":"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","names":["CommonScriptbaseMixin","Base","__extends","args","_this","core","baseCore","getBaseCore","setBaseAccentsFor","baseScale","getBaseScale","baseIc","getBaseIc","baseIsChar","isCharBase","isMathAccent","scriptChild","coreMO","node","getProperty","checkLineAccents","baseRemoveIc","isLineAbove","isLineBelow","constructor","useIC","Object","class_1","childNodes","base","getSemanticBase","length","isKind","baseHasAccentOver","baseHasAccentUnder","attributes","get","fence","getExplicit","getBaseFence","baseChild","id","_c","child","result","scale","bbox","getBBox","rscale","parent","ic","size","Array","from","getText","isLineAccent","mml","overChild","underChild","script","isToken","w","font","params","extra_ic","recompute","getBaseWidth","getOffset","x","y","append","combine","scriptspace","clean","setChildPWidths","n","largeop","sbox","tex","subscriptshift","length2em","sub1","Math","max","baseCharZero","d","sub_drop","h","x_height","attr","getList","prime","p","sup3","displaystyle","sup1","sup2","superscriptshift","sup_drop","display","mo","basebox","overbox","accent","t","rule_thickness","separation_factor","delta","T","k","big_op_spacing1","big_op_spacing3","underbox","big_op_spacing2","big_op_spacing4","boxes","align","widths","map","box","apply","__spreadArray","dw","m","keys","_d","i","_f","dx","noskew","sk","skewIcFactor","stretchy","_e","canStretch","push","count","nodeCount","W","all","_g","noStretch","stretch","dir","stretchy_1_1","getStretchedVariant","_a","exports"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/output/common/Wrappers/scriptbase.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the a base mixin for CommonMsubsup, CommonMunderover\n *                and their relatives.  (Since munderover can become msubsup\n *                when movablelimits is set, munderover needs to be able to\n *                do the same thing as msubsup in some cases.)\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AnyWrapper, WrapperConstructor, Constructor, AnyWrapperClass} from '../Wrapper.js';\nimport {CommonMo} from './mo.js';\nimport {CommonMunderover} from './munderover.js';\nimport {MmlMsubsup} from '../../../core/MmlTree/MmlNodes/msubsup.js';\nimport {MmlMo} from '../../../core/MmlTree/MmlNodes/mo.js';\nimport {BBox} from '../../../util/BBox.js';\nimport {DIRECTION} from '../FontData.js';\n\n/*****************************************************************/\n/**\n * The CommonScriptbase interface\n *\n * @template W  The child-node Wrapper class\n */\nexport interface CommonScriptbase<W extends AnyWrapper> extends AnyWrapper {\n\n  /**\n   * The core mi or mo of the base (or the base itself if there isn't one)\n   */\n  readonly baseCore: W;\n\n  /**\n   * The base element's wrapper\n   */\n  readonly baseChild: W;\n\n  /**\n   * The relative scaling of the base compared to the munderover/msubsup\n   */\n  readonly baseScale: number;\n\n  /**\n   * The italic correction of the base (if any)\n   */\n  readonly baseIc: number;\n\n  /**\n   * True if base italic correction should be removed (msub and msubsup or mathaccents)\n   */\n  readonly baseRemoveIc: boolean;\n\n  /**\n   * True if the base is a single character\n   */\n  readonly baseIsChar: boolean;\n\n  /**\n   * True if the base has an accent under or over\n   */\n  readonly baseHasAccentOver: boolean;\n  readonly baseHasAccentUnder: boolean;\n\n  /**\n   * True if this is an overline or underline\n   */\n  readonly isLineAbove: boolean;\n  readonly isLineBelow: boolean;\n\n  /**\n   * True if this is an msup with script that is a math accent\n   */\n  readonly isMathAccent: boolean;\n\n  /**\n   * The script element's wrapper (overridden in subclasses)\n   */\n  readonly scriptChild: W;\n\n  /***************************************************************************/\n  /*\n   *  Methods for information about the core element for the base\n   */\n\n  /**\n   * @return {W}    The wrapper for the base core mi or mo (or whatever)\n   */\n  getBaseCore(): W;\n\n  /**\n   * @return {W}    The base fence item or null\n   */\n  getSemanticBase(): W;\n\n  /**\n   * Recursively retrieves an element for a given fencepointer.\n   *\n   * @param {W} fence The potential fence.\n   * @param {string} id The fencepointer id.\n   * @return {W} The original fence the scripts belong to.\n   */\n  getBaseFence(fence: W, id: string): W;\n\n  /**\n   * @return {number}   The scaling factor for the base core relative to the munderover/msubsup\n   */\n  getBaseScale(): number;\n\n  /**\n   * The base's italic correction (properly scaled)\n   */\n  getBaseIc(): number;\n\n  /**\n   * An adjusted italic correction (for slightly better results)\n   */\n  getAdjustedIc(): number;\n\n  /**\n   * @return {boolean}  True if the base is an mi, mn, or mo (not a largeop) consisting of\n   *                    a single unstretched character\n   */\n  isCharBase(): boolean;\n\n  /**\n   * Determine if the under- and overscripts are under- or overlines.\n   */\n  checkLineAccents(): void;\n\n  /**\n   * @param {W} script   The script node to check for being a line\n   */\n  isLineAccent(script: W): boolean;\n\n  /***************************************************************************/\n  /*\n   *  Methods for sub-sup nodes\n   */\n\n  /**\n   * @return {number}    The base child's width without the base italic correction (if not needed)\n   */\n  getBaseWidth(): number;\n\n  /**\n   * Get the shift for the script (implemented in subclasses)\n   *\n   * @return {number[]}   The horizontal and vertical offsets for the script\n   */\n  getOffset(): number[];\n\n  /**\n   * @param {number} n    The value to use if the base isn't a (non-large-op, unstretched) char\n   * @return {number}     Either n or 0\n   */\n  baseCharZero(n: number): number;\n\n  /**\n   * Get the shift for a subscript (TeXBook Appendix G 18ab)\n   *\n   * @return {number}     The vertical offset for the script\n   */\n  getV(): number;\n\n  /**\n   * Get the shift for a superscript (TeXBook Appendix G 18acd)\n   *\n   * @return {number}     The vertical offset for the script\n   */\n  getU(): number;\n\n  /***************************************************************************/\n  /*\n   *  Methods for under-over nodes\n   */\n\n  /**\n   * @return {boolean}  True if the base has movablelimits (needed by munderover)\n   */\n  hasMovableLimits(): boolean;\n\n  /**\n   * Get the separation and offset for overscripts (TeXBoox Appendix G 13, 13a)\n   *\n   * @param {BBox} basebox  The bounding box of the base\n   * @param {BBox} overbox  The bounding box of the overscript\n   * @return {number[]}     The separation between their boxes, and the offset of the overscript\n   */\n  getOverKU(basebox: BBox, overbox: BBox): number[];\n\n  /**\n   * Get the separation and offset for underscripts (TeXBoox Appendix G 13, 13a)\n   *\n   * @param {BBox} basebox   The bounding box of the base\n   * @param {BBox} underbox  The bounding box of the underscript\n   * @return {number[]}      The separation between their boxes, and the offset of the underscript\n   */\n  getUnderKV(basebox: BBox, underbox: BBox): number[];\n\n  /**\n   * @param {BBox[]} boxes     The bounding boxes whose offsets are to be computed\n   * @param {number[]=} delta  The initial x offsets of the boxes\n   * @return {number[]}        The actual offsets needed to center the boxes in the stack\n   */\n  getDeltaW(boxes: BBox[], delta?: number[]): number[];\n\n  /**\n   * @param {boolean=} noskew   Whether to ignore the skew amount\n   * @return {number}           The offset for under and over\n   */\n  getDelta(noskew?: boolean): number;\n\n  /**\n   * Handle horizontal stretching of children to match greatest width\n   *  of all children\n   */\n  stretchChildren(): void;\n\n}\n\nexport interface CommonScriptbaseClass extends AnyWrapperClass {\n  /**\n   * Set to true for munderover/munder/mover/msup (Appendix G 13)\n   */\n  useIC: boolean;\n}\n\n/**\n * Shorthand for the CommonScriptbase constructor\n *\n * @template W  The child-node Wrapper class\n */\nexport type ScriptbaseConstructor<W extends AnyWrapper> = Constructor<CommonScriptbase<W>>;\n\n/*****************************************************************/\n/**\n * A base class for msup/msub/msubsup and munder/mover/munderover\n * wrapper mixin implementations\n *\n * @template W  The child-node Wrapper class\n * @template T  The Wrapper class constructor type\n */\nexport function CommonScriptbaseMixin<\n  W extends AnyWrapper,\n  T extends WrapperConstructor\n>(Base: T): ScriptbaseConstructor<W> & T {\n\n  return class extends Base {\n\n    /**\n     * Set to false for msubsup/msub (Appendix G 13)\n     */\n    public static useIC: boolean = true;\n\n    /**\n     * The core mi or mo of the base (or the base itself if there isn't one)\n     */\n    public baseCore: W;\n\n    /**\n     * The base element's wrapper\n     */\n    public baseScale: number = 1;\n\n    /**\n     * The relative scaling of the base compared to the munderover/msubsup\n     */\n    public baseIc: number = 0;\n\n    /**\n     * True if base italic correction should be removed (msub and msubsup or mathaccents)\n     */\n    public baseRemoveIc: boolean = false;\n\n    /**\n     * True if the base is a single character\n     */\n    public baseIsChar: boolean = false;\n\n    /**\n     * True if the base has an accent under or over\n     */\n    public baseHasAccentOver: boolean = null;\n    public baseHasAccentUnder: boolean = null;\n\n    /**\n     * True if this is an overline or underline\n     */\n    public isLineAbove: boolean = false;\n    public isLineBelow: boolean = false;\n\n    /**\n     * True if this is an msup with script that is a math accent\n     */\n    public isMathAccent: boolean = false;\n\n    /**\n     * @return {W}  The base element's wrapper\n     */\n    public get baseChild(): W {\n      return this.childNodes[(this.node as MmlMsubsup).base];\n    }\n\n    /**\n     * @return {W}  The script element's wrapper (overridden in subclasses)\n     */\n    public get scriptChild(): W {\n      return this.childNodes[1];\n    }\n\n    /**\n     * @override\n     */\n    constructor(...args: any[]) {\n      super(...args);\n      //\n      //  Find the base core\n      //\n      const core = this.baseCore = this.getBaseCore();\n      if (!core) return;\n      //\n      // Get information about the base element\n      //\n      this.setBaseAccentsFor(core);\n      this.baseScale = this.getBaseScale();\n      this.baseIc = this.getBaseIc();\n      this.baseIsChar = this.isCharBase();\n      //\n      //  Determine if we are setting a mathaccent\n      //\n      this.isMathAccent = this.baseIsChar &&\n        (this.scriptChild && !!this.scriptChild.coreMO().node.getProperty('mathaccent')) as boolean;\n      //\n      // Check for overline/underline accents\n      //\n      this.checkLineAccents();\n      //\n      //  Check if the base is a mi or mo that needs italic correction removed\n      //\n      this.baseRemoveIc = !this.isLineAbove && !this.isLineBelow &&\n        (!(this.constructor as CommonScriptbaseClass).useIC || this.isMathAccent);\n    }\n\n    /***************************************************************************/\n    /*\n     *  Methods for information about the core element for the base\n     */\n\n    /**\n     * @return {W}    The wrapper for the base core mi or mo (or whatever)\n     */\n    public getBaseCore(): W {\n      let core = this.getSemanticBase() || this.childNodes[0];\n      while (core &&\n             ((core.childNodes.length === 1 &&\n               (core.node.isKind('mrow') || core.node.isKind('TeXAtom') ||\n                core.node.isKind('mstyle') || core.node.isKind('mpadded') ||\n                core.node.isKind('mphantom') || core.node.isKind('semantics'))) ||\n              (core.node.isKind('munderover') && core.isMathAccent)))  {\n        this.setBaseAccentsFor(core);\n        core = core.childNodes[0];\n      }\n      if (!core) {\n        this.baseHasAccentOver = this.baseHasAccentUnder = false;\n      }\n      return core || this.childNodes[0];\n    }\n\n    /**\n     * @param {W} core   The element to check for accents\n     */\n    public setBaseAccentsFor(core: W) {\n      if (core.node.isKind('munderover')) {\n        if (this.baseHasAccentOver === null) {\n          this.baseHasAccentOver = !!core.node.attributes.get('accent');\n        }\n        if (this.baseHasAccentUnder === null) {\n          this.baseHasAccentUnder = !!core.node.attributes.get('accentunder');\n        }\n      }\n    }\n\n    /**\n     * @return {W}    The base fence item or null\n     */\n    public getSemanticBase(): W {\n      let fence = this.node.attributes.getExplicit('data-semantic-fencepointer') as string;\n      return this.getBaseFence(this.baseChild, fence);\n    }\n\n    /**\n     * Recursively retrieves an element for a given fencepointer.\n     *\n     * @param {W} fence The potential fence.\n     * @param {string} id The fencepointer id.\n     * @return {W} The original fence the scripts belong to.\n     */\n    public getBaseFence(fence: W, id: string): W {\n      if (!fence || !fence.node.attributes || !id) {\n        return null;\n      }\n      if (fence.node.attributes.getExplicit('data-semantic-id') === id) {\n        return fence;\n      }\n      for (const child of fence.childNodes) {\n        const result = this.getBaseFence(child, id);\n        if (result) {\n          return result;\n        }\n      }\n      return null;\n    }\n\n    /**\n     * @return {number}   The scaling factor for the base core relative to the munderover/msubsup\n     */\n    public getBaseScale(): number {\n      let child = this.baseCore as any;\n      let scale = 1;\n      while (child && child !== this) {\n        const bbox = child.getBBox();\n        scale *= bbox.rscale;\n        child = child.parent;\n      }\n      return scale;\n    }\n\n    /**\n     * The base's italic correction (properly scaled)\n     */\n    public getBaseIc(): number {\n      return this.baseCore.getBBox().ic * this.baseScale;\n    }\n\n    /**\n     * An adjusted italic correction (for slightly better results)\n     */\n    public getAdjustedIc(): number {\n      const bbox = this.baseCore.getBBox();\n      return (bbox.ic ? 1.05 * bbox.ic + .05 : 0) * this.baseScale;\n    }\n\n    /**\n     * @return {boolean}  True if the base is an mi, mn, or mo consisting of a single character\n     */\n    public isCharBase(): boolean {\n      let base = this.baseCore;\n      return (((base.node.isKind('mo') && (base as any).size === null) ||\n               base.node.isKind('mi') || base.node.isKind('mn')) &&\n              base.bbox.rscale === 1 && Array.from(base.getText()).length === 1);\n    }\n\n    /**\n     * Determine if the under- and overscripts are under- or overlines.\n     */\n    public checkLineAccents() {\n      if (!this.node.isKind('munderover')) return;\n      if (this.node.isKind('mover')) {\n        this.isLineAbove = this.isLineAccent(this.scriptChild);\n      } else if (this.node.isKind('munder')) {\n        this.isLineBelow = this.isLineAccent(this.scriptChild);\n      } else {\n        const mml = this as unknown as CommonMunderover<W>;\n        this.isLineAbove = this.isLineAccent(mml.overChild);\n        this.isLineBelow = this.isLineAccent(mml.underChild);\n      }\n    }\n\n    /**\n     * @param {W} script   The script node to check for being a line\n     * @return {boolean}   True if the script is U+2015\n     */\n    public isLineAccent(script: W): boolean {\n      const node = script.coreMO().node;\n      return (node.isToken && (node as MmlMo).getText() === '\\u2015');\n    }\n\n    /***************************************************************************/\n    /*\n     *  Methods for sub-sup nodes\n     */\n\n    /**\n     * @return {number}    The base child's width without the base italic correction (if not needed)\n     */\n    public getBaseWidth(): number {\n      const bbox = this.baseChild.getBBox();\n      return bbox.w * bbox.rscale - (this.baseRemoveIc ? this.baseIc : 0) + this.font.params.extra_ic;\n    }\n\n    /**\n     * This gives the common bbox for msub and msup.  It is overridden\n     * for all the others (msubsup, munder, mover, munderover).\n     *\n     * @override\n     */\n    public computeBBox(bbox: BBox, recompute: boolean = false) {\n      const w = this.getBaseWidth();\n      const [x, y] = this.getOffset();\n      bbox.append(this.baseChild.getBBox());\n      bbox.combine(this.scriptChild.getBBox(), w + x, y);\n      bbox.w += this.font.params.scriptspace;\n      bbox.clean();\n      this.setChildPWidths(recompute);\n    }\n\n    /**\n     * Get the shift for the script (implemented in subclasses)\n     *\n     * @return {[number, number]}   The horizontal and vertical offsets for the script\n     */\n    public getOffset(): [number, number] {\n      return [0, 0];\n    }\n\n    /**\n     * @param {number} n    The value to use if the base isn't a (non-large-op, unstretched) char\n     * @return {number}     Either n or 0\n     */\n    public baseCharZero(n: number): number {\n      const largeop = !!this.baseCore.node.attributes.get('largeop');\n      const scale = this.baseScale;\n      return (this.baseIsChar && !largeop && scale === 1 ? 0 : n);\n    }\n\n    /**\n     * Get the shift for a subscript (TeXBook Appendix G 18ab)\n     *\n     * @return {number}     The vertical offset for the script\n     */\n    public getV(): number {\n      const bbox = this.baseCore.getBBox();\n      const sbox = this.scriptChild.getBBox();\n      const tex = this.font.params;\n      const subscriptshift = this.length2em(this.node.attributes.get('subscriptshift'), tex.sub1);\n      return Math.max(\n        this.baseCharZero(bbox.d * this.baseScale + tex.sub_drop * sbox.rscale),\n        subscriptshift,\n        sbox.h * sbox.rscale - (4 / 5) * tex.x_height\n      );\n    }\n\n    /**\n     * Get the shift for a superscript (TeXBook Appendix G 18acd)\n     *\n     * @return {number}     The vertical offset for the script\n     */\n    public getU(): number {\n      const bbox = this.baseCore.getBBox();\n      const sbox = this.scriptChild.getBBox();\n      const tex = this.font.params;\n      const attr = this.node.attributes.getList('displaystyle', 'superscriptshift');\n      const prime = this.node.getProperty('texprimestyle');\n      const p = prime ? tex.sup3 : (attr.displaystyle ? tex.sup1 : tex.sup2);\n      const superscriptshift = this.length2em(attr.superscriptshift, p);\n      return Math.max(\n        this.baseCharZero(bbox.h * this.baseScale - tex.sup_drop * sbox.rscale),\n        superscriptshift,\n        sbox.d * sbox.rscale + (1 / 4) * tex.x_height\n      );\n    }\n\n    /***************************************************************************/\n    /*\n     *  Methods for under-over nodes\n     */\n\n    /**\n     * @return {boolean}  True if the base has movablelimits (needed by munderover)\n     */\n    public hasMovableLimits(): boolean {\n      const display = this.node.attributes.get('displaystyle');\n      const mo = this.baseChild.coreMO().node;\n      return (!display && !!mo.attributes.get('movablelimits'));\n    }\n\n    /**\n     * Get the separation and offset for overscripts (TeXBoox Appendix G 13, 13a)\n     *\n     * @param {BBox} basebox  The bounding box of the base\n     * @param {BBox} overbox  The bounding box of the overscript\n     * @return {[number, number]}     The separation between their boxes, and the offset of the overscript\n     */\n    public getOverKU(basebox: BBox, overbox: BBox): [number, number] {\n      const accent = this.node.attributes.get('accent') as boolean;\n      const tex = this.font.params;\n      const d = overbox.d * overbox.rscale;\n      const t = tex.rule_thickness * tex.separation_factor;\n      const delta = (this.baseHasAccentOver ? t : 0);\n      const T = (this.isLineAbove ? 3 * tex.rule_thickness : t);\n      const k = (accent ? T : Math.max(tex.big_op_spacing1, tex.big_op_spacing3 - Math.max(0, d))) - delta;\n      return [k, basebox.h * basebox.rscale + k + d];\n    }\n\n    /**\n     * Get the separation and offset for underscripts (TeXBoox Appendix G 13, 13a)\n     *\n     * @param {BBox} basebox   The bounding box of the base\n     * @param {BBox} underbox  The bounding box of the underscript\n     * @return {[number, number]}      The separation between their boxes, and the offset of the underscript\n     */\n    public getUnderKV(basebox: BBox, underbox: BBox): [number, number] {\n      const accent = this.node.attributes.get('accentunder') as boolean;\n      const tex = this.font.params;\n      const h = underbox.h * underbox.rscale;\n      const t = tex.rule_thickness * tex.separation_factor;\n      const delta = (this.baseHasAccentUnder ? t : 0);\n      const T = (this.isLineBelow ? 3 * tex.rule_thickness : t);\n      const k = (accent ? T : Math.max(tex.big_op_spacing2, tex.big_op_spacing4 - h)) - delta;\n      return [k, -(basebox.d * basebox.rscale + k + h)];\n    }\n\n    /**\n     * @param {BBox[]} boxes     The bounding boxes whose offsets are to be computed\n     * @param {number[]=} delta  The initial x offsets of the boxes\n     * @return {number[]}        The actual offsets needed to center the boxes in the stack\n     */\n    public getDeltaW(boxes: BBox[], delta: number[] = [0, 0, 0]): number[] {\n      const align = this.node.attributes.get('align');\n      const widths = boxes.map(box => box.w * box.rscale);\n      widths[0] -= (this.baseRemoveIc && !this.baseCore.node.attributes.get('largeop') ? this.baseIc : 0);\n      const w = Math.max(...widths);\n      const dw = [] as number[];\n      let m = 0;\n      for (const i of widths.keys()) {\n        dw[i] = (align === 'center' ? (w - widths[i]) / 2 :\n                 align === 'right' ? w - widths[i] : 0) + delta[i];\n        if (dw[i] < m) {\n          m = -dw[i];\n        }\n      }\n      if (m) {\n        for (const i of dw.keys()) {\n          dw[i] += m;\n        }\n      }\n      [1, 2].map(i => dw[i] += (boxes[i] ? boxes[i].dx * boxes[0].scale : 0));\n      return dw;\n    }\n\n    /**\n     * @param {boolean=} noskew   Whether to ignore the skew amount\n     * @return {number}           The offset for under and over\n     */\n    public getDelta(noskew: boolean = false): number {\n      const accent = this.node.attributes.get('accent');\n      const {sk, ic} = this.baseCore.getBBox();\n      return ((accent && !noskew ? sk : 0) + this.font.skewIcFactor * ic) * this.baseScale;\n    }\n\n    /**\n     * Handle horizontal stretching of children to match greatest width\n     *  of all children\n     */\n    public stretchChildren() {\n      let stretchy: AnyWrapper[] = [];\n      //\n      //  Locate and count the stretchy children\n      //\n      for (const child of this.childNodes) {\n        if (child.canStretch(DIRECTION.Horizontal)) {\n          stretchy.push(child);\n        }\n      }\n      let count = stretchy.length;\n      let nodeCount = this.childNodes.length;\n      if (count && nodeCount > 1) {\n        let W = 0;\n        //\n        //  If all the children are stretchy, find the largest one,\n        //  otherwise, find the width of the non-stretchy children.\n        //\n        let all = (count > 1 && count === nodeCount);\n        for (const child of this.childNodes) {\n          const noStretch = (child.stretch.dir === DIRECTION.None);\n          if (all || noStretch) {\n            const {w, rscale} = child.getBBox(noStretch);\n            if (w * rscale > W) W = w * rscale;\n          }\n        }\n        //\n        //  Stretch the stretchable children\n        //\n        for (const child of stretchy) {\n          (child.coreMO() as CommonMo).getStretchedVariant([W / child.bbox.rscale]);\n        }\n      }\n    }\n\n  };\n\n}\n"]},"metadata":{},"sourceType":"script"}