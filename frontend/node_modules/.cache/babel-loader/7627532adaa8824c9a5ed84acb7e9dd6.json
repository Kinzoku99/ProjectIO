{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ParseUtil_js_1 = require(\"./ParseUtil.js\");\n\nvar Stack_js_1 = require(\"./Stack.js\");\n\nvar TexError_js_1 = require(\"./TexError.js\");\n\nvar MmlNode_js_1 = require(\"../../core/MmlTree/MmlNode.js\");\n\nvar TexParser = function () {\n  function TexParser(_string, env, configuration) {\n    var e_1, _a;\n\n    this._string = _string;\n    this.configuration = configuration;\n    this.macroCount = 0;\n    this.i = 0;\n    this.currentCS = '';\n    var inner = env.hasOwnProperty('isInner');\n    var isInner = env['isInner'];\n    delete env['isInner'];\n    var ENV;\n\n    if (env) {\n      ENV = {};\n\n      try {\n        for (var _b = __values(Object.keys(env)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var id = _c.value;\n          ENV[id] = env[id];\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    this.configuration.pushParser(this);\n    this.stack = new Stack_js_1.default(this.itemFactory, ENV, inner ? isInner : true);\n    this.Parse();\n    this.Push(this.itemFactory.create('stop'));\n  }\n\n  Object.defineProperty(TexParser.prototype, \"options\", {\n    get: function () {\n      return this.configuration.options;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TexParser.prototype, \"itemFactory\", {\n    get: function () {\n      return this.configuration.itemFactory;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TexParser.prototype, \"tags\", {\n    get: function () {\n      return this.configuration.tags;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TexParser.prototype, \"string\", {\n    get: function () {\n      return this._string;\n    },\n    set: function (str) {\n      this._string = str;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  TexParser.prototype.parse = function (kind, input) {\n    return this.configuration.handlers.get(kind).parse(input);\n  };\n\n  TexParser.prototype.lookup = function (kind, symbol) {\n    return this.configuration.handlers.get(kind).lookup(symbol);\n  };\n\n  TexParser.prototype.contains = function (kind, symbol) {\n    return this.configuration.handlers.get(kind).contains(symbol);\n  };\n\n  TexParser.prototype.toString = function () {\n    var e_2, _a;\n\n    var str = '';\n\n    try {\n      for (var _b = __values(Array.from(this.configuration.handlers.keys())), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var config = _c.value;\n        str += config + ': ' + this.configuration.handlers.get(config) + '\\n';\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return str;\n  };\n\n  TexParser.prototype.Parse = function () {\n    var c;\n\n    while (this.i < this.string.length) {\n      c = this.getCodePoint();\n      this.i += c.length;\n      this.parse('character', [this, c]);\n    }\n  };\n\n  TexParser.prototype.Push = function (arg) {\n    if (arg instanceof MmlNode_js_1.AbstractMmlNode && arg.isInferred) {\n      this.PushAll(arg.childNodes);\n    } else {\n      this.stack.Push(arg);\n    }\n  };\n\n  TexParser.prototype.PushAll = function (args) {\n    var e_3, _a;\n\n    try {\n      for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {\n        var arg = args_1_1.value;\n        this.stack.Push(arg);\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n  };\n\n  TexParser.prototype.mml = function () {\n    if (!this.stack.Top().isKind('mml')) {\n      return null;\n    }\n\n    var node = this.stack.Top().First;\n    this.configuration.popParser();\n    return node;\n  };\n\n  TexParser.prototype.convertDelimiter = function (c) {\n    var symbol = this.lookup('delimiter', c);\n    return symbol ? symbol.char : null;\n  };\n\n  TexParser.prototype.getCodePoint = function () {\n    var code = this.string.codePointAt(this.i);\n    return code === undefined ? '' : String.fromCodePoint(code);\n  };\n\n  TexParser.prototype.nextIsSpace = function () {\n    return !!this.string.charAt(this.i).match(/\\s/);\n  };\n\n  TexParser.prototype.GetNext = function () {\n    while (this.nextIsSpace()) {\n      this.i++;\n    }\n\n    return this.getCodePoint();\n  };\n\n  TexParser.prototype.GetCS = function () {\n    var CS = this.string.slice(this.i).match(/^(([a-z]+) ?|[\\uD800-\\uDBFF].|.)/i);\n\n    if (CS) {\n      this.i += CS[0].length;\n      return CS[2] || CS[1];\n    } else {\n      this.i++;\n      return ' ';\n    }\n  };\n\n  TexParser.prototype.GetArgument = function (_name, noneOK) {\n    switch (this.GetNext()) {\n      case '':\n        if (!noneOK) {\n          throw new TexError_js_1.default('MissingArgFor', 'Missing argument for %1', this.currentCS);\n        }\n\n        return null;\n\n      case '}':\n        if (!noneOK) {\n          throw new TexError_js_1.default('ExtraCloseMissingOpen', 'Extra close brace or missing open brace');\n        }\n\n        return null;\n\n      case '\\\\':\n        this.i++;\n        return '\\\\' + this.GetCS();\n\n      case '{':\n        var j = ++this.i,\n            parens = 1;\n\n        while (this.i < this.string.length) {\n          switch (this.string.charAt(this.i++)) {\n            case '\\\\':\n              this.i++;\n              break;\n\n            case '{':\n              parens++;\n              break;\n\n            case '}':\n              if (--parens === 0) {\n                return this.string.slice(j, this.i - 1);\n              }\n\n              break;\n          }\n        }\n\n        throw new TexError_js_1.default('MissingCloseBrace', 'Missing close brace');\n    }\n\n    var c = this.getCodePoint();\n    this.i += c.length;\n    return c;\n  };\n\n  TexParser.prototype.GetBrackets = function (_name, def) {\n    if (this.GetNext() !== '[') {\n      return def;\n    }\n\n    var j = ++this.i,\n        parens = 0;\n\n    while (this.i < this.string.length) {\n      switch (this.string.charAt(this.i++)) {\n        case '{':\n          parens++;\n          break;\n\n        case '\\\\':\n          this.i++;\n          break;\n\n        case '}':\n          if (parens-- <= 0) {\n            throw new TexError_js_1.default('ExtraCloseLooking', 'Extra close brace while looking for %1', '\\']\\'');\n          }\n\n          break;\n\n        case ']':\n          if (parens === 0) {\n            return this.string.slice(j, this.i - 1);\n          }\n\n          break;\n      }\n    }\n\n    throw new TexError_js_1.default('MissingCloseBracket', 'Could not find closing \\']\\' for argument to %1', this.currentCS);\n  };\n\n  TexParser.prototype.GetDelimiter = function (name, braceOK) {\n    var c = this.GetNext();\n    this.i += c.length;\n\n    if (this.i <= this.string.length) {\n      if (c === '\\\\') {\n        c += this.GetCS();\n      } else if (c === '{' && braceOK) {\n        this.i--;\n        c = this.GetArgument(name).trim();\n      }\n\n      if (this.contains('delimiter', c)) {\n        return this.convertDelimiter(c);\n      }\n    }\n\n    throw new TexError_js_1.default('MissingOrUnrecognizedDelim', 'Missing or unrecognized delimiter for %1', this.currentCS);\n  };\n\n  TexParser.prototype.GetDimen = function (name) {\n    if (this.GetNext() === '{') {\n      var dimen = this.GetArgument(name);\n\n      var _a = __read(ParseUtil_js_1.default.matchDimen(dimen), 2),\n          value = _a[0],\n          unit = _a[1];\n\n      if (value) {\n        return value + unit;\n      }\n    } else {\n      var dimen = this.string.slice(this.i);\n\n      var _b = __read(ParseUtil_js_1.default.matchDimen(dimen, true), 3),\n          value = _b[0],\n          unit = _b[1],\n          length_1 = _b[2];\n\n      if (value) {\n        this.i += length_1;\n        return value + unit;\n      }\n    }\n\n    throw new TexError_js_1.default('MissingDimOrUnits', 'Missing dimension or its units for %1', this.currentCS);\n  };\n\n  TexParser.prototype.GetUpTo = function (_name, token) {\n    while (this.nextIsSpace()) {\n      this.i++;\n    }\n\n    var j = this.i;\n    var parens = 0;\n\n    while (this.i < this.string.length) {\n      var k = this.i;\n      var c = this.GetNext();\n      this.i += c.length;\n\n      switch (c) {\n        case '\\\\':\n          c += this.GetCS();\n          break;\n\n        case '{':\n          parens++;\n          break;\n\n        case '}':\n          if (parens === 0) {\n            throw new TexError_js_1.default('ExtraCloseLooking', 'Extra close brace while looking for %1', token);\n          }\n\n          parens--;\n          break;\n      }\n\n      if (parens === 0 && c === token) {\n        return this.string.slice(j, k);\n      }\n    }\n\n    throw new TexError_js_1.default('TokenNotFoundForCommand', 'Could not find %1 for %2', token, this.currentCS);\n  };\n\n  TexParser.prototype.ParseArg = function (name) {\n    return new TexParser(this.GetArgument(name), this.stack.env, this.configuration).mml();\n  };\n\n  TexParser.prototype.ParseUpTo = function (name, token) {\n    return new TexParser(this.GetUpTo(name, token), this.stack.env, this.configuration).mml();\n  };\n\n  TexParser.prototype.GetDelimiterArg = function (name) {\n    var c = ParseUtil_js_1.default.trimSpaces(this.GetArgument(name));\n\n    if (c === '') {\n      return null;\n    }\n\n    if (this.contains('delimiter', c)) {\n      return c;\n    }\n\n    throw new TexError_js_1.default('MissingOrUnrecognizedDelim', 'Missing or unrecognized delimiter for %1', this.currentCS);\n  };\n\n  TexParser.prototype.GetStar = function () {\n    var star = this.GetNext() === '*';\n\n    if (star) {\n      this.i++;\n    }\n\n    return star;\n  };\n\n  TexParser.prototype.create = function (kind) {\n    var _a;\n\n    var rest = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n\n    return (_a = this.configuration.nodeFactory).create.apply(_a, __spreadArray([kind], __read(rest)));\n  };\n\n  return TexParser;\n}();\n\nexports.default = TexParser;","map":{"version":3,"mappings":"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","names":["_string","env","configuration","inner","hasOwnProperty","isInner","ENV","keys","_c","id","pushParser","stack","Stack_js_1","itemFactory","Parse","Push","create","Object","TexParser","options","tags","str","kind","input","handlers","get","parse","symbol","lookup","contains","from","config","c","i","string","length","getCodePoint","arg","MmlNode_js_1","isInferred","PushAll","childNodes","args","args_1_1","Top","isKind","node","First","popParser","char","code","codePointAt","undefined","String","fromCodePoint","charAt","match","nextIsSpace","CS","slice","_name","noneOK","GetNext","TexError_js_1","currentCS","GetCS","j","parens","def","name","braceOK","GetArgument","trim","convertDelimiter","dimen","ParseUtil_js_1","matchDimen","value","unit","length_1","token","k","mml","GetUpTo","trimSpaces","star","rest","nodeFactory","apply","_a","__spreadArray","__read"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/input/tex/TexParser.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview The TexParser. Implements the basic parsing functionality and\n *     administers the global stack and tree objects.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport ParseUtil from './ParseUtil.js';\nimport {HandlerType} from './MapHandler.js';\nimport Stack from './Stack.js';\nimport StackItemFactory from './StackItemFactory.js';\nimport {Tags} from './Tags.js';\nimport TexError from './TexError.js';\nimport {MmlNode, AbstractMmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {ParseInput, ParseResult} from './Types.js';\nimport ParseOptions from './ParseOptions.js';\nimport {StackItem, EnvList} from './StackItem.js';\nimport {Symbol} from './Symbol.js';\nimport {OptionList} from '../../util/Options.js';\n\n\n/**\n * The main Tex Parser class.\n */\nexport default class TexParser {\n\n  /**\n   * Counter for recursive macros.\n   * @type {number}\n   */\n  public macroCount: number = 0;\n\n  /**\n   * The stack for items and created nodes.\n   * @type {Stack}\n   */\n  public stack: Stack;\n\n  /**\n   * Current position in the string that is parsed.\n   * @type {number}\n   */\n  public i: number = 0;\n\n  /**\n   * The last command sequence\n   * @type {string}\n   */\n  public currentCS: string = '';\n\n  /**\n   * @constructor\n   * @param {string} string The string to parse.\n   * @param {EnvList} env The intial environment representing the current parse\n   *     state of the overall expression translation.\n   * @param {ParseOptions} configuration A parser configuration.\n   */\n  constructor(private _string: string, env: EnvList, public configuration: ParseOptions) {\n    const inner = env.hasOwnProperty('isInner');\n    const isInner = env['isInner'] as boolean;\n    delete env['isInner'];\n    let ENV: EnvList;\n    if (env) {\n      ENV = {};\n      for (const id of Object.keys(env)) {\n        ENV[id] = env[id];\n      }\n    }\n    this.configuration.pushParser(this);\n    this.stack = new Stack(this.itemFactory, ENV, inner ? isInner : true);\n    this.Parse();\n    this.Push(this.itemFactory.create('stop'));\n  }\n\n  /**\n   * @return {OptionList} The configuration options.\n   */\n  get options(): OptionList {\n    return this.configuration.options;\n  }\n\n  /**\n   * @return {StackItemFactory} The factory for stack items.\n   */\n  get itemFactory(): StackItemFactory {\n    return this.configuration.itemFactory;\n  }\n\n  /**\n   * @return {Tags} The tags style of this configuration.\n   */\n  get tags(): Tags {\n    return this.configuration.tags;\n  }\n\n  /**\n   * Sets the string that should be parsed.\n   * @param {string} str The new string to parse.\n   */\n  set string(str: string) {\n    this._string = str;\n  }\n\n  /**\n   * @return {string} The string that is currently parsed.\n   */\n  get string(): string {\n    return this._string;\n  }\n\n\n  /**\n   * Parses the input with the specified kind of map.\n   * @param {HandlerType} kind Configuration name.\n   * @param {ParseInput} input Input to be parsed.\n   * @return {ParseResult} The output of the parsing function.\n   */\n  public parse(kind: HandlerType, input: ParseInput): ParseResult {\n    return this.configuration.handlers.get(kind).parse(input);\n  }\n\n\n  /**\n   * Maps a symbol to its \"parse value\" if it exists.\n   * @param {HandlerType} kind Configuration name.\n   * @param {string} symbol The symbol to parse.\n   * @return {any} A boolean, Character, or Macro.\n   */\n  public lookup(kind: HandlerType, symbol: string): any {\n    return this.configuration.handlers.get(kind).lookup(symbol);\n  }\n\n\n  /**\n   * Checks if a symbol is contained in one of the symbol mappings of the\n   * specified kind.\n   * @param {HandlerType} kind Configuration name.\n   * @param {string} symbol The symbol to parse.\n   * @return {boolean} True if the symbol is contained in the given types of\n   *     symbol mapping.\n   */\n  public contains(kind: HandlerType, symbol: string): boolean {\n    return this.configuration.handlers.get(kind).contains(symbol);\n  }\n\n\n  /**\n   * @override\n   */\n  public toString(): string {\n    let str = '';\n    for (const config of Array.from(this.configuration.handlers.keys())) {\n      str += config + ': ' +\n        this.configuration.handlers.get(config as HandlerType) + '\\n';\n    }\n    return str;\n  }\n\n\n  /**\n   * Parses the current input string.\n   */\n  public Parse() {\n    let c: string;\n    while (this.i < this.string.length) {\n      c = this.getCodePoint();\n      this.i += c.length;\n      this.parse('character', [this, c]);\n    }\n  }\n\n\n  /**\n   * Pushes a new item onto the stack. The item can also be a Mml node,\n   *   but if the mml item is an inferred row, push its children instead.\n   * @param {StackItem|MmlNode} arg The new item.\n   */\n  public Push(arg: StackItem | MmlNode) {\n    if (arg instanceof AbstractMmlNode && arg.isInferred) {\n      this.PushAll(arg.childNodes);\n    } else {\n      this.stack.Push(arg);\n    }\n  }\n\n\n  /**\n   * Pushes a list of new items onto the stack.\n   * @param {StackItem|MmlNode[]} args The new items.\n   */\n  public PushAll(args: (StackItem | MmlNode)[]) {\n    for (const arg of args) {\n      this.stack.Push(arg);\n    }\n  }\n\n\n  /**\n   * @return {MmlNode} The internal Mathml structure.\n   */\n  public mml(): MmlNode {\n    if (!this.stack.Top().isKind('mml')) {\n      return null;\n    }\n    let node = this.stack.Top().First;\n    this.configuration.popParser();\n    return node;\n  }\n\n  /************************************************************************\n   *\n   *   String handling routines\n   */\n\n  /**\n   * Convert delimiter to character.\n   * @param {string} c The delimiter name.\n   * @return {string} The corresponding character.\n   */\n  public convertDelimiter(c: string): string {\n    const symbol = this.lookup('delimiter', c) as Symbol;\n    return symbol ? symbol.char : null;\n  }\n\n  /**\n   * @return {string}   Get the next unicode character in the string\n   */\n  public getCodePoint(): string {\n    const code = this.string.codePointAt(this.i);\n    return code === undefined ? '' : String.fromCodePoint(code);\n  }\n\n  /**\n   * @return {boolean} True if the next character to parse is a space.\n   */\n  public nextIsSpace(): boolean {\n    return !!this.string.charAt(this.i).match(/\\s/);\n  }\n\n  /**\n   * @return {string} Get the next non-space character.\n   */\n  public GetNext(): string {\n    while (this.nextIsSpace()) {\n      this.i++;\n    }\n    return this.getCodePoint();\n  }\n\n  /**\n   * @return {string} Get and return a control-sequence name\n   */\n  public GetCS(): string {\n    let CS = this.string.slice(this.i).match(/^(([a-z]+) ?|[\\uD800-\\uDBFF].|.)/i);\n    if (CS) {\n      this.i += CS[0].length;\n      return CS[2] || CS[1];\n    } else {\n      this.i++;\n      return ' ';\n    }\n  }\n\n  /**\n   * Get and return a TeX argument (either a single character or control\n   *     sequence, or the contents of the next set of braces).\n   * @param {string} name Name of the current control sequence.\n   * @param {boolean} noneOK? True if no argument is OK.\n   * @return {string} The next argument.\n   */\n  public GetArgument(_name: string, noneOK?: boolean): string {\n    switch (this.GetNext()) {\n    case '':\n      if (!noneOK) {\n        // @test MissingArgFor\n        throw new TexError('MissingArgFor', 'Missing argument for %1', this.currentCS);\n      }\n      return null;\n    case '}':\n      if (!noneOK) {\n        // @test ExtraCloseMissingOpen\n        throw new TexError('ExtraCloseMissingOpen',\n                            'Extra close brace or missing open brace');\n      }\n      return null;\n    case '\\\\':\n      this.i++;\n      return '\\\\' + this.GetCS();\n    case '{':\n      let j = ++this.i, parens = 1;\n      while (this.i < this.string.length) {\n        switch (this.string.charAt(this.i++)) {\n        case '\\\\':  this.i++; break;\n        case '{':   parens++; break;\n        case '}':\n          if (--parens === 0) {\n            return this.string.slice(j, this.i - 1);\n          }\n          break;\n        }\n      }\n      // @test MissingCloseBrace\n      throw new TexError('MissingCloseBrace', 'Missing close brace');\n    }\n    const c = this.getCodePoint();\n    this.i += c.length;\n    return c;\n  }\n\n\n  /**\n   * Get an optional LaTeX argument in brackets.\n   * @param {string} name Name of the current control sequence.\n   * @param {string} def? The default value for the optional argument.\n   * @return {string} The optional argument.\n   */\n  public GetBrackets(_name: string, def?: string): string {\n    if (this.GetNext() !== '[') {\n      return def;\n    }\n    let j = ++this.i, parens = 0;\n    while (this.i < this.string.length) {\n      switch (this.string.charAt(this.i++)) {\n      case '{':   parens++; break;\n      case '\\\\':  this.i++; break;\n      case '}':\n        if (parens-- <= 0) {\n          // @test ExtraCloseLooking1\n          throw new TexError('ExtraCloseLooking',\n                              'Extra close brace while looking for %1', '\\']\\'');\n        }\n        break;\n      case ']':\n        if (parens === 0) {\n          return this.string.slice(j, this.i - 1);\n        }\n        break;\n      }\n    }\n    // @test MissingCloseBracket\n    throw new TexError('MissingCloseBracket',\n                        'Could not find closing \\']\\' for argument to %1', this.currentCS);\n  }\n\n  /**\n   *  Get the name of a delimiter (check it in the delimiter list).\n   * @param {string} name Name of the current control sequence.\n   * @param {boolean} braceOK? Are braces around the delimiter OK.\n   * @return {string} The delimiter name.\n   */\n  public GetDelimiter(name: string, braceOK?: boolean): string {\n    let c = this.GetNext(); this.i += c.length;\n    if (this.i <= this.string.length) {\n      if (c === '\\\\') {\n        c += this.GetCS();\n      } else if (c === '{' && braceOK) {\n        this.i--;\n        c = this.GetArgument(name).trim();\n      }\n      if (this.contains('delimiter', c)) {\n        return this.convertDelimiter(c);\n      }\n    }\n    // @test MissingOrUnrecognizedDelim1, MissingOrUnrecognizedDelim2\n    throw new TexError('MissingOrUnrecognizedDelim',\n                        'Missing or unrecognized delimiter for %1', this.currentCS);\n  }\n\n  /**\n   * Get a dimension (including its units).\n   * @param {string} name Name of the current control sequence.\n   * @return {string} The dimension string.\n   */\n  public GetDimen(name: string): string {\n    if (this.GetNext() === '{') {\n      let dimen = this.GetArgument(name);\n      let [value, unit] = ParseUtil.matchDimen(dimen);\n      if (value) {\n        // @test Raise In Line, Lower 2, (Raise|Lower) Negative\n        return value + unit;\n      }\n    } else {\n      // @test Above, Raise, Lower, Modulo, Above With Delims\n      let dimen = this.string.slice(this.i);\n      let [value, unit, length] = ParseUtil.matchDimen(dimen, true);\n      if (value) {\n        this.i += length;\n        return value + unit;\n      }\n    }\n    // @test MissingDimOrUnits\n    throw new TexError('MissingDimOrUnits',\n                        'Missing dimension or its units for %1', this.currentCS);\n  }\n\n  /**\n   *  Get everything up to the given control sequence (token)\n   * @param {string} name Name of the current control sequence.\n   * @param {string} token The element until where to parse.\n   * @return {string} The text between the current position and the given token.\n   */\n  public GetUpTo(_name: string, token: string): string {\n    while (this.nextIsSpace()) {\n      this.i++;\n    }\n    let j = this.i;\n    let parens = 0;\n    while (this.i < this.string.length) {\n      let k = this.i;\n      let c = this.GetNext(); this.i += c.length;\n      switch (c) {\n      case '\\\\':  c += this.GetCS(); break;\n      case '{':   parens++; break;\n      case '}':\n        if (parens === 0) {\n          // @test ExtraCloseLooking2\n          throw new TexError('ExtraCloseLooking',\n                              'Extra close brace while looking for %1', token);\n        }\n        parens--;\n        break;\n      }\n      if (parens === 0 && c === token) {\n        return this.string.slice(j, k);\n      }\n    }\n    // @test TokenNotFoundForCommand\n    throw new TexError('TokenNotFoundForCommand',\n                        'Could not find %1 for %2', token, this.currentCS);\n  }\n\n  /**\n   * Parse the arguments of a control sequence in a new parser instance.\n   * @param {string} name Name of the current control sequence.\n   * @return {MmlNode} The parsed node.\n   */\n  public ParseArg(name: string): MmlNode  {\n    return new TexParser(this.GetArgument(name), this.stack.env,\n                         this.configuration).mml();\n  }\n\n  /**\n   * Parses a given string up to a given token in a new parser instance.\n   * @param {string} name Name of the current control sequence.\n   * @param {string} token A Token at which to end parsing.\n   * @return {MmlNode} The parsed node.\n   */\n  public ParseUpTo(name: string, token: string): MmlNode {\n    return new TexParser(this.GetUpTo(name, token), this.stack.env,\n                         this.configuration).mml();\n  }\n\n\n  /**\n   * Get a delimiter or empty argument\n   * @param {string} name Name of the current control sequence.\n   * @return {string} The delimiter.\n   */\n  public GetDelimiterArg(name: string): string {\n    let c = ParseUtil.trimSpaces(this.GetArgument(name));\n    if (c === '') {\n      return null;\n    }\n    if (this.contains('delimiter', c)) {\n      return c;\n    }\n    // @test MissingOrUnrecognizedDelim\n    throw new TexError('MissingOrUnrecognizedDelim',\n                        'Missing or unrecognized delimiter for %1', this.currentCS);\n  }\n\n  /**\n   * @return {boolean} True if a star follows the control sequence name.\n   */\n  public GetStar(): boolean {\n    let star = (this.GetNext() === '*');\n    if (star) {\n      this.i++;\n    }\n    return star;\n  }\n\n\n  /**\n   * Convenience method to create nodes with the node factory of the current\n   * configuration.\n   * @param {string} kind The kind of node to create.\n   * @param {any[]} ...rest The remaining arguments for the creation method.\n   * @return {MmlNode} The newly created node.\n   */\n  public create(kind: string, ...rest: any[]): MmlNode {\n    return this.configuration.nodeFactory.create(kind, ...rest);\n  }\n\n\n}\n"]},"metadata":{},"sourceType":"script"}