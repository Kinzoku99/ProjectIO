{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FindMathML = void 0;\n\nvar FindMath_js_1 = require(\"../../core/FindMath.js\");\n\nvar NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\nvar FindMathML = function (_super) {\n  __extends(FindMathML, _super);\n\n  function FindMathML() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  FindMathML.prototype.findMath = function (node) {\n    var set = new Set();\n    this.findMathNodes(node, set);\n    this.findMathPrefixed(node, set);\n    var html = this.adaptor.root(this.adaptor.document);\n\n    if (this.adaptor.kind(html) === 'html' && set.size === 0) {\n      this.findMathNS(node, set);\n    }\n\n    return this.processMath(set);\n  };\n\n  FindMathML.prototype.findMathNodes = function (node, set) {\n    var e_1, _a;\n\n    try {\n      for (var _b = __values(this.adaptor.tags(node, 'math')), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var math = _c.value;\n        set.add(math);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n\n  FindMathML.prototype.findMathPrefixed = function (node, set) {\n    var e_2, _a, e_3, _b;\n\n    var html = this.adaptor.root(this.adaptor.document);\n\n    try {\n      for (var _c = __values(this.adaptor.allAttributes(html)), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var attr = _d.value;\n\n        if (attr.name.substr(0, 6) === 'xmlns:' && attr.value === NAMESPACE) {\n          var prefix = attr.name.substr(6);\n\n          try {\n            for (var _e = (e_3 = void 0, __values(this.adaptor.tags(node, prefix + ':math'))), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var math = _f.value;\n              set.add(math);\n            }\n          } catch (e_3_1) {\n            e_3 = {\n              error: e_3_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_3) throw e_3.error;\n            }\n          }\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  };\n\n  FindMathML.prototype.findMathNS = function (node, set) {\n    var e_4, _a;\n\n    try {\n      for (var _b = __values(this.adaptor.tags(node, 'math', NAMESPACE)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var math = _c.value;\n        set.add(math);\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n  };\n\n  FindMathML.prototype.processMath = function (set) {\n    var e_5, _a;\n\n    var math = [];\n\n    try {\n      for (var _b = __values(Array.from(set)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var mml = _c.value;\n        var display = this.adaptor.getAttribute(mml, 'display') === 'block' || this.adaptor.getAttribute(mml, 'mode') === 'display';\n        var start = {\n          node: mml,\n          n: 0,\n          delim: ''\n        };\n        var end = {\n          node: mml,\n          n: 0,\n          delim: ''\n        };\n        math.push({\n          math: this.adaptor.outerHTML(mml),\n          start: start,\n          end: end,\n          display: display\n        });\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    return math;\n  };\n\n  FindMathML.OPTIONS = {};\n  return FindMathML;\n}(FindMath_js_1.AbstractFindMath);\n\nexports.FindMathML = FindMathML;","map":{"version":3,"mappings":"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","names":["NAMESPACE","__extends","FindMathML","node","set","Set","findMathNodes","findMathPrefixed","html","adaptor","root","document","kind","size","findMathNS","processMath","tags","_c","math","add","allAttributes","_d","attr","name","substr","value","prefix","_f","from","mml","display","getAttribute","start","n","delim","end","push","outerHTML","FindMath_js_1","exports"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/input/mathml/FindMathML.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the MathML version of the FindMath object\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AbstractFindMath} from '../../core/FindMath.js';\nimport {DOMAdaptor} from '../../core/DOMAdaptor.js';\nimport {OptionList} from '../../util/Options.js';\nimport {ProtoItem} from '../../core/MathItem.js';\n\n/**\n * The MathML namespace\n */\nconst NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\n\n/*****************************************************************/\n/**\n *  Implements the FindMathML object (extends AbstractFindMath)\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport class FindMathML<N, T, D> extends AbstractFindMath<N, T, D> {\n\n  /**\n   * @override\n   */\n  public static OPTIONS: OptionList = {};\n\n  /**\n   * The DOMAdaptor for the document being processed\n   */\n  public adaptor: DOMAdaptor<N, T, D>;\n\n  /**\n   * Locates math nodes, possibly with namespace prefixes.\n   *  Store them in a set so that if found more than once, they will only\n   *  appear in the list once.\n   *\n   * @override\n   */\n  public findMath(node: N) {\n    let set = new Set<N>();\n    this.findMathNodes(node, set);\n    this.findMathPrefixed(node, set);\n    const html = this.adaptor.root(this.adaptor.document);\n    if (this.adaptor.kind(html) === 'html' &&  set.size === 0) {\n      this.findMathNS(node, set);\n    }\n    return this.processMath(set);\n  }\n\n  /**\n   * Find plain <math> tags\n   *\n   * @param {N} node       The container to seaerch for math\n   * @param {Set<N>} set   The set in which to store the math nodes\n   */\n  protected findMathNodes(node: N, set: Set<N>) {\n    for (const math of this.adaptor.tags(node, 'math')) {\n      set.add(math);\n    }\n  }\n\n  /**\n   * Find <m:math> tags (or whatever prefixes there are)\n   *\n   * @param {N} node  The container to seaerch for math\n   * @param {NodeSet} set   The set in which to store the math nodes\n   */\n  protected findMathPrefixed(node: N, set: Set<N>) {\n    let html = this.adaptor.root(this.adaptor.document);\n    for (const attr of this.adaptor.allAttributes(html)) {\n      if (attr.name.substr(0, 6) === 'xmlns:' && attr.value === NAMESPACE) {\n        let prefix = attr.name.substr(6);\n        for (const math of this.adaptor.tags(node, prefix + ':math')) {\n          set.add(math);\n        }\n      }\n    }\n  }\n\n  /**\n   * Find namespaced math in XHTML documents (is this really needed?)\n   *\n   * @param {N} node  The container to seaerch for math\n   * @param {NodeSet} set   The set in which to store the math nodes\n   */\n  protected findMathNS(node: N, set: Set<N>) {\n    for (const math of this.adaptor.tags(node, 'math', NAMESPACE)) {\n      set.add(math);\n    }\n  }\n\n  /**\n   *  Produce the array of proto math items from the node set\n   */\n  protected processMath(set: Set<N>) {\n    let math: ProtoItem<N, T>[] = [];\n    for (const mml of Array.from(set)) {\n      let display = (this.adaptor.getAttribute(mml, 'display') === 'block' ||\n                     this.adaptor.getAttribute(mml, 'mode') === 'display');\n      let start = {node: mml, n: 0, delim: ''};\n      let end   = {node: mml, n: 0, delim: ''};\n      math.push({math: this.adaptor.outerHTML(mml), start, end, display});\n    }\n    return math;\n  }\n\n}\n"]},"metadata":{},"sourceType":"script"}