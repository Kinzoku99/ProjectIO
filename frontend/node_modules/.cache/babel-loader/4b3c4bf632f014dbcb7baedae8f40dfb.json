{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractWrapper = void 0;\n\nvar AbstractWrapper = function () {\n  function AbstractWrapper(factory, node) {\n    this.factory = factory;\n    this.node = node;\n  }\n\n  Object.defineProperty(AbstractWrapper.prototype, \"kind\", {\n    get: function () {\n      return this.node.kind;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractWrapper.prototype.wrap = function (node) {\n    return this.factory.wrap(node);\n  };\n\n  return AbstractWrapper;\n}();\n\nexports.AbstractWrapper = AbstractWrapper;","map":{"version":3,"mappings":";;;;;;;AAuEA;AAyBE,2BAAYA,OAAZ,EAA+DC,IAA/D,EAAsE;AACpE,SAAKD,OAAL,GAAeA,OAAf;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACD;;AAdDC,wBAAIC,yBAAJ,EAAI,MAAJ,EAAQ;SAAR;AACE,aAAO,KAAKF,IAAL,CAAUG,IAAjB;AACD,KAFO;qBAAA;;AAAA,GAAR;;AAmBOD,mCAAP,UAAYF,IAAZ,EAAmB;AACjB,WAAO,KAAKD,OAAL,CAAaK,IAAb,CAAkBJ,IAAlB,CAAP;AACD,GAFM;;AAIT;AAAC,CArCD;;AAAaK","names":["factory","node","Object","AbstractWrapper","kind","wrap","exports"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/core/Tree/Wrapper.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview Generic Wrapper class for adding methods to a Node class for visitors\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {Node} from './Node.js';\nimport {WrapperFactory} from './WrapperFactory.js';\n\n/*********************************************************/\n/**\n *  The Wrapper interface\n *\n *  It points to a Node object.  Subclasses add methods for the visitor to call.\n *\n * @template N  The Node type being wrapped\n * @template W  The Wrapper type being produced\n */\nexport interface Wrapper<N extends Node, W extends Wrapper<N, W>> {\n  node: N;\n  readonly kind: string;\n\n  /**\n   * @param {Node} node  A node to be wrapped\n   * @param {any[]} args  Any additional arguments needed when creating the wrapper\n   * @return {Wrapper}   The wrapped node\n   */\n  wrap(node: N, ...args: any[]): W;\n}\n\n/*********************************************************/\n/**\n *  The Wrapper class interface\n *\n * @template N  The Node type being wrapped\n * @template W  The Wrapper type being produced\n */\nexport interface WrapperClass<N extends Node, W extends Wrapper<N, W>> {\n  /**\n   * @param {WrapperFactory} factory  The factory used to create more wrappers\n   * @param {N} node  The node to be wrapped\n   * @param {any[]} args  Any additional arguments needed when creating the wrapper\n   * @return {W}  The wrapped node\n   */\n  new(factory: WrapperFactory<N, W, WrapperClass<N, W>>, node: N, ...args: any[]): W;\n}\n\n/*********************************************************/\n/**\n *  The abstract Wrapper class\n *\n * @template N  The Node type being created by the factory\n * @template W  The Wrapper type being produced\n */\nexport class AbstractWrapper<N extends Node, W extends Wrapper<N, W>> implements Wrapper<N, W> {\n  /**\n   * The Node object associated with this instance\n   */\n  public node: N;\n\n  /**\n   * The WrapperFactory to use to wrap child nodes, as needed\n   */\n  protected factory: WrapperFactory<N, W, WrapperClass<N, W>>;\n\n  /**\n   * The kind of this wrapper\n   */\n  get kind() {\n    return this.node.kind;\n  }\n\n  /**\n   * @param {WrapperFactory} factory  The WrapperFactory to use to wrap child nodes when needed\n   * @param {Node} node               The node to wrap\n   *\n   * @constructor\n   * @implements {Wrapper}\n   */\n  constructor(factory: WrapperFactory<N, W, WrapperClass<N, W>>, node: N) {\n    this.factory = factory;\n    this.node = node;\n  }\n\n  /**\n   * @override\n   */\n  public wrap(node: N) {\n    return this.factory.wrap(node);\n  }\n\n}\n"]},"metadata":{},"sourceType":"script"}