{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractEmptyNode = exports.AbstractNode = void 0;\n\nvar AbstractNode = function () {\n  function AbstractNode(factory, properties, children) {\n    var e_1, _a;\n\n    if (properties === void 0) {\n      properties = {};\n    }\n\n    if (children === void 0) {\n      children = [];\n    }\n\n    this.factory = factory;\n    this.parent = null;\n    this.properties = {};\n    this.childNodes = [];\n\n    try {\n      for (var _b = __values(Object.keys(properties)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var name_1 = _c.value;\n        this.setProperty(name_1, properties[name_1]);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    if (children.length) {\n      this.setChildren(children);\n    }\n  }\n\n  Object.defineProperty(AbstractNode.prototype, \"kind\", {\n    get: function () {\n      return 'unknown';\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractNode.prototype.setProperty = function (name, value) {\n    this.properties[name] = value;\n  };\n\n  AbstractNode.prototype.getProperty = function (name) {\n    return this.properties[name];\n  };\n\n  AbstractNode.prototype.getPropertyNames = function () {\n    return Object.keys(this.properties);\n  };\n\n  AbstractNode.prototype.getAllProperties = function () {\n    return this.properties;\n  };\n\n  AbstractNode.prototype.removeProperty = function () {\n    var e_2, _a;\n\n    var names = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      names[_i] = arguments[_i];\n    }\n\n    try {\n      for (var names_1 = __values(names), names_1_1 = names_1.next(); !names_1_1.done; names_1_1 = names_1.next()) {\n        var name_2 = names_1_1.value;\n        delete this.properties[name_2];\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (names_1_1 && !names_1_1.done && (_a = names_1.return)) _a.call(names_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  };\n\n  AbstractNode.prototype.isKind = function (kind) {\n    return this.factory.nodeIsKind(this, kind);\n  };\n\n  AbstractNode.prototype.setChildren = function (children) {\n    var e_3, _a;\n\n    this.childNodes = [];\n\n    try {\n      for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {\n        var child = children_1_1.value;\n        this.appendChild(child);\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n  };\n\n  AbstractNode.prototype.appendChild = function (child) {\n    this.childNodes.push(child);\n    child.parent = this;\n    return child;\n  };\n\n  AbstractNode.prototype.replaceChild = function (newChild, oldChild) {\n    var i = this.childIndex(oldChild);\n\n    if (i !== null) {\n      this.childNodes[i] = newChild;\n      newChild.parent = this;\n    }\n\n    return newChild;\n  };\n\n  AbstractNode.prototype.childIndex = function (node) {\n    var i = this.childNodes.indexOf(node);\n    return i === -1 ? null : i;\n  };\n\n  AbstractNode.prototype.copy = function () {\n    var e_4, _a;\n\n    var node = this.factory.create(this.kind);\n    node.properties = __assign({}, this.properties);\n\n    try {\n      for (var _b = __values(this.childNodes || []), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n\n        if (child) {\n          node.appendChild(child.copy());\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    return node;\n  };\n\n  AbstractNode.prototype.findNodes = function (kind) {\n    var nodes = [];\n    this.walkTree(function (node) {\n      if (node.isKind(kind)) {\n        nodes.push(node);\n      }\n    });\n    return nodes;\n  };\n\n  AbstractNode.prototype.walkTree = function (func, data) {\n    var e_5, _a;\n\n    func(this, data);\n\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n\n        if (child) {\n          child.walkTree(func, data);\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    return data;\n  };\n\n  AbstractNode.prototype.toString = function () {\n    return this.kind + '(' + this.childNodes.join(',') + ')';\n  };\n\n  return AbstractNode;\n}();\n\nexports.AbstractNode = AbstractNode;\n\nvar AbstractEmptyNode = function (_super) {\n  __extends(AbstractEmptyNode, _super);\n\n  function AbstractEmptyNode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  AbstractEmptyNode.prototype.setChildren = function (_children) {};\n\n  AbstractEmptyNode.prototype.appendChild = function (child) {\n    return child;\n  };\n\n  AbstractEmptyNode.prototype.replaceChild = function (_newChild, oldChild) {\n    return oldChild;\n  };\n\n  AbstractEmptyNode.prototype.childIndex = function (_node) {\n    return null;\n  };\n\n  AbstractEmptyNode.prototype.walkTree = function (func, data) {\n    func(this, data);\n    return data;\n  };\n\n  AbstractEmptyNode.prototype.toString = function () {\n    return this.kind;\n  };\n\n  return AbstractEmptyNode;\n}(AbstractNode);\n\nexports.AbstractEmptyNode = AbstractEmptyNode;","map":{"version":3,"mappings":"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","names":["factory","properties","children","keys","_c","name_1","setProperty","length","setChildren","Object","AbstractNode","name","value","names","names_1_1","name_2","kind","nodeIsKind","childNodes","children_1_1","child","appendChild","push","parent","newChild","oldChild","i","childIndex","node","indexOf","create","__assign","copy","nodes","walkTree","isKind","func","data","join","exports","__extends","AbstractEmptyNode","_children","_newChild","_node"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/core/Tree/Node.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview Generic Node classes for node trees\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {NodeFactory} from './NodeFactory.js';\n\n/**\n *  PropertyList and Property are for string data like\n *  attributes and other properties\n */\nexport type Property = string | number | boolean;\nexport type PropertyList = {[key: string]: Property};\n\n/*********************************************************/\n/**\n *  The generic Node interface\n */\n\nexport interface Node {\n  readonly kind: string;\n  /**\n   * The NodeFactory to use to create additional nodes, as needed\n   */\n  readonly factory: NodeFactory<Node, NodeClass>;\n  parent: Node;\n  childNodes: Node[];\n\n  /**\n   * @param {string} name     The name of the property to set\n   * @param {Property} value  The value to which the property will be set\n   */\n  setProperty(name: string, value: Property): void;\n\n  /**\n   * @param {string} name  The name of the property to get\n   * @return {Property}   The value of the named property\n   */\n  getProperty(name: string): Property;\n\n  /**\n   * @return {string[]}  An array of the names of every property currently defined\n   */\n  getPropertyNames(): string[];\n\n  /**\n   * @return {PropertyList}  The propery list containing all the properties of the node\n   */\n  getAllProperties(): PropertyList;\n\n  /**\n   * @param {string[]} names  The names of the properties to be removed\n   */\n  removeProperty(...names: string[]): void;\n\n\n  /**\n   * @param {string} kind  The type of node to test for\n   * @return {boolean}     True when the node is of the given type\n   */\n  isKind(kind: string): boolean;\n\n  /**\n   * @param {Node[]} children  The child nodes to add to this node\n   */\n  setChildren(children: Node[]): void;\n\n  /**\n   * @param {Node} child  A node to add to this node's children\n   * @return {Node}       The child node that was added\n   */\n  appendChild(child: Node): Node;\n\n  /**\n   * @param {Node} newChild  A child node to be inserted\n   * @param {Node} oldChild  A child node to be replaced\n   * @return {Node}          The old child node that was removed\n   */\n  replaceChild(newChild: Node, oldChild: Node): Node;\n\n  /**\n   * @param {Node} child  A child node whose index in childNodes is desired\n   * @return {number}     The index of the child in childNodes, or null if not found\n   */\n  childIndex(child: Node): number;\n\n  /**\n   * Make a deep copy of the node (but with no parent).\n   */\n  copy(): Node;\n\n  /**\n   * @param {string} kind  The kind of nodes to be located in the tree\n   * @return {Node[]}      An array of nodes that are children (at any depth) of the given kind\n   */\n  findNodes(kind: string): Node[];\n\n  /**\n   * @param {Function} func  A function to apply to each node in the tree rooted at this node\n   * @param {any} data       Data to pass to the function (as state information)\n   */\n  walkTree(func: (node: Node, data?: any) => void, data?: any): void;\n}\n\n/*********************************************************/\n/**\n *  The generic Node class interface\n */\n\nexport interface NodeClass {\n  /**\n   * @param {NodeFactory} factory  The NodeFactory to use to create new nodes when needed\n   * @param {PropertyList} properties  Any properties to be added to the node, if any\n   * @param {Node[]} children  The initial child nodes, if any\n   * @return {Node}  The newly created node\n   */\n  new (factory: NodeFactory<Node, NodeClass>, properties?: PropertyList, children?: Node[]): Node;\n}\n\n/*********************************************************/\n/**\n *  The abstract Node class\n */\n\nexport abstract class AbstractNode implements Node {\n\n  /**\n   * The parent node for this one\n   */\n  public parent: Node = null;\n\n  /**\n   * The properties for this node\n   */\n  protected properties: PropertyList = {};\n\n  /**\n   * The children for this node\n   */\n  public childNodes: Node[] = [];\n\n  /**\n   * @param {NodeFactory} factory  The NodeFactory to use to create new nodes when needed\n   * @param {PropertyList} properties  Any properties to be added to the node, if any\n   * @param {Node[]} children  The initial child nodes, if any\n   *\n   * @constructor\n   * @implements {Node}\n   */\n  constructor(readonly factory: NodeFactory<Node, NodeClass>, properties: PropertyList = {}, children: Node[] = []) {\n    for (const name of Object.keys(properties)) {\n      this.setProperty(name, properties[name]);\n    }\n    if (children.length) {\n      this.setChildren(children);\n    }\n  }\n\n  /**\n   * @override\n   */\n  public get kind() {\n    return 'unknown';\n  }\n\n  /**\n   * @override\n   */\n  public setProperty(name: string, value: Property) {\n    this.properties[name] = value;\n  }\n\n  /**\n   * @override\n   */\n  public getProperty(name: string) {\n    return this.properties[name];\n  }\n\n  /**\n   * @override\n   */\n  public getPropertyNames() {\n    return Object.keys(this.properties);\n  }\n\n  /**\n   * @override\n   */\n  public getAllProperties() {\n    return this.properties;\n  }\n\n  /**\n   * @override\n   */\n  public removeProperty(...names: string[]) {\n    for (const name of names) {\n      delete this.properties[name];\n    }\n  }\n\n\n  /**\n   * @override\n   */\n  public isKind(kind: string): boolean {\n    return this.factory.nodeIsKind(this, kind);\n  }\n\n\n  /**\n   * @override\n   */\n  public setChildren(children: Node[]) {\n    this.childNodes = [];\n    for (let child of children) {\n      this.appendChild(child);\n    }\n  }\n\n  /**\n   * @override\n   */\n  public appendChild(child: Node) {\n    this.childNodes.push(child);\n    child.parent = this;\n    return child;\n  }\n\n  /**\n   * @override\n   */\n  public replaceChild(newChild: Node, oldChild: Node) {\n    let i = this.childIndex(oldChild);\n    // If i === null should we error?  return null?  silently fail?\n    if (i !== null) {\n      this.childNodes[i] = newChild;\n      newChild.parent = this;\n    }\n    return newChild;\n  }\n\n\n  /**\n   * @override\n   */\n  public childIndex(node: Node) {\n    let i = this.childNodes.indexOf(node);\n    return (i === -1 ? null : i);\n  }\n\n\n  /**\n   * @override\n   */\n  public copy() {\n    const node = (this as AbstractNode).factory.create(this.kind) as AbstractNode;\n    node.properties = {...this.properties};\n    for (const child of this.childNodes || []) {\n      if (child) {\n        node.appendChild(child.copy());\n      }\n    }\n    return node;\n  }\n\n  /**\n   * @override\n   */\n  public findNodes(kind: string) {\n    let nodes: Node[] = [];\n    this.walkTree((node: Node) => {\n      if (node.isKind(kind)) {\n        nodes.push(node);\n      }\n    });\n    return nodes;\n  }\n\n\n  /**\n   * @override\n   */\n  public walkTree(func: (node: Node, data?: any) => void, data?: any) {\n    func(this, data);\n    for (const child of this.childNodes) {\n      if (child) {\n        child.walkTree(func, data);\n      }\n    }\n    return data;\n  }\n\n  /**\n   * Simple string version for debugging, just to get the structure.\n   */\n  public toString() {\n    return this.kind + '(' + this.childNodes.join(',') + ')';\n  }\n\n}\n\n/*********************************************************/\n/**\n *  The abstract EmptyNode class\n */\n\nexport abstract class AbstractEmptyNode extends AbstractNode {\n  /**\n   *  We don't have children, so ignore these methods\n   */\n\n  /**\n   * @override\n   */\n  public setChildren(_children: Node[]) {\n  }\n\n  /**\n   * @override\n   */\n  public appendChild(child: Node) {\n    return child;\n  }\n\n  /**\n   * @override\n   */\n  public replaceChild(_newChild: Node, oldChild: Node) {\n    return oldChild;\n  }\n\n  /**\n   * @override\n   */\n  public childIndex(_node: Node) {\n    return null as number;\n  }\n\n  /**\n   * Don't step into children (there aren't any)\n   *\n   * @override\n   */\n  public walkTree(func: (node: Node, data?: any) => void, data?: any) {\n    func(this, data);\n    return data;\n  }\n\n  /**\n   * Simple string version for debugging, just to get the structure.\n   */\n  public toString() {\n    return this.kind;\n  }\n\n}\n"]},"metadata":{},"sourceType":"script"}