{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.retryAfter = exports.handleRetriesFor = void 0;\n\nfunction handleRetriesFor(code) {\n  return new Promise(function run(ok, fail) {\n    try {\n      ok(code());\n    } catch (err) {\n      if (err.retry && err.retry instanceof Promise) {\n        err.retry.then(function () {\n          return run(ok, fail);\n        }).catch(function (perr) {\n          return fail(perr);\n        });\n      } else if (err.restart && err.restart.isCallback) {\n        MathJax.Callback.After(function () {\n          return run(ok, fail);\n        }, err.restart);\n      } else {\n        fail(err);\n      }\n    }\n  });\n}\n\nexports.handleRetriesFor = handleRetriesFor;\n\nfunction retryAfter(promise) {\n  var err = new Error('MathJax retry');\n  err.retry = promise;\n  throw err;\n}\n\nexports.retryAfter = retryAfter;","map":{"version":3,"mappings":";;;;;;;AAqEA,SAAgBA,gBAAhB,CAAiCC,IAAjC,EAA+C;AAC7C,SAAO,IAAIC,OAAJ,CAAY,SAASC,GAAT,CAAaC,EAAb,EAA2BC,IAA3B,EAAyC;AAC1D,QAAI;AACFD,QAAE,CAACH,IAAI,EAAL,CAAF;AACD,KAFD,CAEE,OAAOK,GAAP,EAAY;AACZ,UAAIA,GAAG,CAACC,KAAJ,IAAaD,GAAG,CAACC,KAAJ,YAAqBL,OAAtC,EAA+C;AAC7CI,WAAG,CAACC,KAAJ,CAAUC,IAAV,CAAe;AAAM,oBAAG,CAACJ,EAAD,EAAKC,IAAL,CAAH;AAAa,SAAlC,EACUI,KADV,CACgB,UAACC,IAAD,EAAY;AAAK,qBAAI,CAACA,IAAD,CAAJ;AAAU,SAD3C;AAED,OAHD,MAGO,IAAIJ,GAAG,CAACK,OAAJ,IAAeL,GAAG,CAACK,OAAJ,CAAYC,UAA/B,EAA2C;AAEhDC,eAAO,CAACC,QAAR,CAAiBC,KAAjB,CAAuB;AAAM,oBAAG,CAACX,EAAD,EAAKC,IAAL,CAAH;AAAa,SAA1C,EAA4CC,GAAG,CAACK,OAAhD;AACD,OAHM,MAGA;AACLN,YAAI,CAACC,GAAD,CAAJ;AACD;AACF;AACF,GAdM,CAAP;AAeD;;AAhBDU;;AA4BA,SAAgBC,UAAhB,CAA2BC,OAA3B,EAAgD;AAC9C,MAAIZ,GAAG,GAAG,IAAIa,KAAJ,CAAU,eAAV,CAAV;AACAb,KAAG,CAACC,KAAJ,GAAYW,OAAZ;AACA,QAAMZ,GAAN;AACD;;AAJDU","names":["handleRetriesFor","code","Promise","run","ok","fail","err","retry","then","catch","perr","restart","isCallback","MathJax","Callback","After","exports","retryAfter","promise","Error"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/util/Retries.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements methods for handling asynchronous actions\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\n\n/*****************************************************************/\n/*\n *  The legacy MathJax object  (FIXME: remove this after all v2 code is gone)\n */\n\ndeclare var MathJax: {Callback: {After: Function}};\n\n\n/*****************************************************************/\n/**\n *  Allow us to pass a promise as part of an Error object\n */\n\nexport interface RetryError extends Error {\n  retry: Promise<any>;\n}\n\n/*****************************************************************/\n/**\n * A wrapper for actions that may be asynchronous.  This will\n *   rerun the action after the asychronous action completes.\n *   Usually, this is for dynamic loading of files.  Legacy\n *   MathJax does that a lot, so we still need it for now, but\n *   may be able to go without it in the future.\n *\n *   Example:\n *\n *     HandleRetriesFor(() => {\n *\n *         html.findMath()\n *             .compile()\n *             .getMetrics()\n *             .typeset()\n *             .updateDocument();\n *\n *     }).catch(err => {\n *       console.log(err.message);\n *     });\n *\n * @param {Function} code  The code to run that might cause retries\n * @return {Promise}       A promise that is satisfied when the code\n *                         runs completely, and fails if the code\n *                         generates an error (that is not a retry).\n */\n\nexport function handleRetriesFor(code: Function): Promise<any> {\n  return new Promise(function run(ok: Function, fail: Function) {\n    try {\n      ok(code());\n    } catch (err) {\n      if (err.retry && err.retry instanceof Promise) {\n        err.retry.then(() => run(ok, fail))\n                 .catch((perr: Error) => fail(perr));\n      } else if (err.restart && err.restart.isCallback) {\n        // FIXME: Remove this branch when all legacy code is gone\n        MathJax.Callback.After(() => run(ok, fail), err.restart);\n      } else {\n        fail(err);\n      }\n    }\n  });\n}\n\n/*****************************************************************/\n/**\n * Tells HandleRetriesFor() to wait for this promise to be fulfilled\n *   before rerunning the code.  Causes an error to be thrown, so\n *   calling this terminates the code at that point.\n *\n * @param {Promise} promise  The promise that must be satisfied before\n *                            actions will continue\n */\n\nexport function retryAfter(promise: Promise<any>) {\n  let err = new Error('MathJax retry') as RetryError;\n  err.retry = promise;\n  throw err;\n}\n"]},"metadata":{},"sourceType":"script"}