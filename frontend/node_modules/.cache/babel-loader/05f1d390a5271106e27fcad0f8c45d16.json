{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractDOMAdaptor = void 0;\n\nvar AbstractDOMAdaptor = function () {\n  function AbstractDOMAdaptor(document) {\n    if (document === void 0) {\n      document = null;\n    }\n\n    this.document = document;\n  }\n\n  AbstractDOMAdaptor.prototype.node = function (kind, def, children, ns) {\n    var e_1, _a;\n\n    if (def === void 0) {\n      def = {};\n    }\n\n    if (children === void 0) {\n      children = [];\n    }\n\n    var node = this.create(kind, ns);\n    this.setAttributes(node, def);\n\n    try {\n      for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {\n        var child = children_1_1.value;\n        this.append(node, child);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return node;\n  };\n\n  AbstractDOMAdaptor.prototype.setAttributes = function (node, def) {\n    var e_2, _a, e_3, _b, e_4, _c;\n\n    if (def.style && typeof def.style !== 'string') {\n      try {\n        for (var _d = __values(Object.keys(def.style)), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var key = _e.value;\n          this.setStyle(node, key.replace(/-([a-z])/g, function (_m, c) {\n            return c.toUpperCase();\n          }), def.style[key]);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n\n    if (def.properties) {\n      try {\n        for (var _f = __values(Object.keys(def.properties)), _g = _f.next(); !_g.done; _g = _f.next()) {\n          var key = _g.value;\n          node[key] = def.properties[key];\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    }\n\n    try {\n      for (var _h = __values(Object.keys(def)), _j = _h.next(); !_j.done; _j = _h.next()) {\n        var key = _j.value;\n\n        if ((key !== 'style' || typeof def.style === 'string') && key !== 'properties') {\n          this.setAttribute(node, key, def[key]);\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n  };\n\n  AbstractDOMAdaptor.prototype.replace = function (nnode, onode) {\n    this.insert(nnode, onode);\n    this.remove(onode);\n    return onode;\n  };\n\n  AbstractDOMAdaptor.prototype.childNode = function (node, i) {\n    return this.childNodes(node)[i];\n  };\n\n  AbstractDOMAdaptor.prototype.allClasses = function (node) {\n    var classes = this.getAttribute(node, 'class');\n    return !classes ? [] : classes.replace(/  +/g, ' ').replace(/^ /, '').replace(/ $/, '').split(/ /);\n  };\n\n  return AbstractDOMAdaptor;\n}();\n\nexports.AbstractDOMAdaptor = AbstractDOMAdaptor;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAuXA;AAWE,8BAAYA,QAAZ,EAA8B;AAAlB;AAAAA;AAAkB;;AAC5B,SAAKA,QAAL,GAAgBA,QAAhB;AACD;;AAUMC,sCAAP,UAAYC,IAAZ,EAA0BC,GAA1B,EAAgDC,QAAhD,EAA0EC,EAA1E,EAAqF;;;AAA3D;AAAAF;AAAoB;;AAAE;AAAAC;AAAwB;;AACtE,QAAME,IAAI,GAAG,KAAKC,MAAL,CAAYL,IAAZ,EAAkBG,EAAlB,CAAb;AACA,SAAKG,aAAL,CAAmBF,IAAnB,EAAyBH,GAAzB;;;AACA,WAAoB,qCAAQM,gCAA5B,EAA4B,kBAA5B,EAA4BA,gCAA5B,EAA8B;AAAzB,YAAMC,KAAK,qBAAX;AACH,aAAKC,MAAL,CAAYL,IAAZ,EAAkBI,KAAlB;AACD;;;;;;;;;;;;;AACD,WAAOJ,IAAP;AACD,GAPM;;AAyBAL,+CAAP,UAAqBK,IAArB,EAA8BH,GAA9B,EAA6C;;;AAC3C,QAAIA,GAAG,CAACS,KAAJ,IAAa,OAAOT,GAAG,CAACS,KAAX,KAAsB,QAAvC,EAAiD;;AAC/C,aAAgB,wBAAM,CAACC,IAAP,CAAYV,GAAG,CAACS,KAAhB,IAAsBE,cAAtC,EAAsC,QAAtC,EAAsCA,cAAtC,EAAwC;AAAnC,cAAIC,GAAG,WAAP;AACH,eAAKC,QAAL,CAAcV,IAAd,EAAoBS,GAAG,CAACE,OAAJ,CAAY,WAAZ,EAAyB,UAACC,EAAD,EAAKC,CAAL,EAAM;AAAK,oBAAC,CAACC,WAAF;AAAe,WAAnD,CAApB,EAA0EjB,GAAG,CAACS,KAAJ,CAAUG,GAAV,CAA1E;AACD;;;;;;;;;;;;AACF;;AACD,QAAIZ,GAAG,CAACkB,UAAR,EAAoB;;AAClB,aAAgB,wBAAM,CAACR,IAAP,CAAYV,GAAG,CAACkB,UAAhB,IAA2BC,cAA3C,EAA2C,QAA3C,EAA2CA,cAA3C,EAA6C;AAAxC,cAAIP,GAAG,WAAP;AACFT,cAAmB,CAACS,GAAD,CAAnB,GAA2BZ,GAAG,CAACkB,UAAJ,CAAeN,GAAf,CAA3B;AACF;;;;;;;;;;;;AACF;;;AACD,WAAgB,wBAAM,CAACF,IAAP,CAAYV,GAAZ,IAAgBoB,cAAhC,EAAgC,QAAhC,EAAgCA,cAAhC,EAAkC;AAA7B,YAAIR,GAAG,WAAP;;AACH,YAAI,CAACA,GAAG,KAAK,OAAR,IAAmB,OAAOZ,GAAG,CAACS,KAAX,KAAsB,QAA1C,KAAuDG,GAAG,KAAK,YAAnE,EAAiF;AAC/E,eAAKS,YAAL,CAAkBlB,IAAlB,EAAwBS,GAAxB,EAA6BZ,GAAG,CAACY,GAAD,CAAhC;AACD;AACF;;;;;;;;;;;;AACF,GAhBM;;AA4EAd,yCAAP,UAAewB,KAAf,EAA6BC,KAA7B,EAAyC;AACvC,SAAKC,MAAL,CAAYF,KAAZ,EAAmBC,KAAnB;AACA,SAAKE,MAAL,CAAYF,KAAZ;AACA,WAAOA,KAAP;AACD,GAJM;;AA4CAzB,2CAAP,UAAiBK,IAAjB,EAA0BuB,CAA1B,EAAmC;AACjC,WAAO,KAAKC,UAAL,CAAgBxB,IAAhB,EAAsBuB,CAAtB,CAAP;AACD,GAFM;;AA8EA5B,4CAAP,UAAkBK,IAAlB,EAAyB;AACvB,QAAMyB,OAAO,GAAG,KAAKC,YAAL,CAAkB1B,IAAlB,EAAwB,OAAxB,CAAhB;AACA,WAAQ,CAACyB,OAAD,GAAW,EAAX,GACAA,OAAO,CAACd,OAAR,CAAgB,MAAhB,EAAwB,GAAxB,EAA6BA,OAA7B,CAAqC,IAArC,EAA2C,EAA3C,EAA+CA,OAA/C,CAAuD,IAAvD,EAA6D,EAA7D,EAAiEgB,KAAjE,CAAuE,GAAvE,CADR;AAED,GAJM;;AA8CT;AAAC,CApSD;;AAAsBC","names":["document","AbstractDOMAdaptor","kind","def","children","ns","node","create","setAttributes","children_1_1","child","append","style","keys","_e","key","setStyle","replace","_m","c","toUpperCase","properties","_g","_j","setAttribute","nnode","onode","insert","remove","i","childNodes","classes","getAttribute","split","exports"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/core/DOMAdaptor.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  The DOMAdaptor interface and abstract class\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {OptionList} from '../util/Options.js';\n\n/**\n * The data for an attribute\n */\nexport type AttributeData = {\n  name: string,\n  value: string\n};\n\n/**\n * The data for an elements page-based bounding box\n */\nexport type PageBBox = {\n  left: number,\n  right: number,\n  top: number,\n  bottom: number\n};\n\n\n/*****************************************************************/\n/**\n *  The interface for the DOMAdaptor\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport interface DOMAdaptor<N, T, D> {\n  /**\n   * Document in which the nodes are to be created\n   */\n  document: D;\n\n  /**\n   * @param {string} text    The serialized document to be parsed\n   * @param {string} format  The format (e.g., 'text/html' or 'text/xhtml')\n   * @return {D}             The parsed document\n   */\n  parse(text: string, format?: string): D;\n\n  /**\n   * @param {string} kind      The tag name of the HTML node to be created\n   * @param {OptionList} def   The properties to set for the created node\n   * @param {(N|T)[]} children The child nodes for the created HTML node\n   * @param {string} ns        The namespace in which to create the node\n   * @return {N}               The generated HTML tree\n   */\n  node(kind: string, def?: OptionList, children?: (N | T)[], ns?: string): N;\n\n  /**\n   * @param {string} text   The text from which to create an HTML text node\n   * @return {T}            The generated text node with the given text\n   */\n  text(text: string): T;\n\n  /**\n   * @param {D} doc   The document whose head is to be obtained\n   * @return {N}      The document.head element\n   */\n  head(doc: D): N;\n\n  /**\n   * @param {D} doc   The document whose body is to be obtained\n   * @return {N}      The document.body element\n   */\n  body(doc: D): N;\n\n  /**\n   * @param {D} doc   The document whose documentElement is to be obtained\n   * @return {N}      The documentElement\n   */\n  root(doc: D): N;\n\n  /**\n   * @param {D} doc     The document whose doctype is to be obtained\n   * @return {string}   The DOCTYPE comment\n   */\n  doctype(doc: D): string;\n\n  /**\n   * @param {N} node        The node to search for tags\n   * @param {string} name   The name of the tag to search for\n   * @param {string} ns     The namespace to search in (or null for no namespace)\n   * @return {N[]}          The list of tags found\n   */\n  tags(node: N, name: string, ns?: string): N[];\n\n  /**\n   * Get a list of containers (to be searched for math).  These can be\n   *  specified by CSS selector, or as actual DOM elements or arrays of such.\n   *\n   * @param {(string | N | N[])[]} nodes  The array of items to make into a container list\n   * @param {D} document                  The document in which to search\n   * @return {N[]}                        The array of containers to search\n   */\n  getElements(nodes: (string | N | N[])[], document: D): N[];\n\n  /**\n   * Determine if a container node contains a given node is somewhere in its DOM tree\n   *\n   * @param {N} container  The container to search\n   * @param {N|T} node     The node to look for\n   * @return {boolean}     True if the node is in the container's DOM tree\n   */\n  contains(container: N, node: N | T): boolean;\n\n  /**\n   * @param {N|T} node  The HTML node whose parent is to be obtained\n   * @return {N}        The parent node of the given one\n   */\n  parent(node: N | T): N;\n\n  /**\n   * @param {N} node     The HTML node to be appended to\n   * @param {N|T} child  The node or text to be appended\n   * @return {N|T}       The appended node\n   */\n  append(node: N, child: N | T): N | T;\n\n  /**\n   * @param {N|T} nchild  The node or text to be inserted\n   * @param {N|T} ochild  The node or text where the new child is to be added before it\n   */\n  insert(nchild: N | T, ochild: N | T): void;\n\n  /**\n   * @param {N|T} child  The node or text to be removed from its parent\n   * @return {N|T}       The removed node\n   */\n  remove(child: N | T): N | T;\n\n  /**\n   * @param {N|T} nnode  The node to replace with\n   * @param {N|T} onode  The child to be replaced\n   * @return {N|T}       The removed node\n   */\n  replace(nnode: N | T, onode: N | T): N | T;\n\n  /**\n   * @param {N} node   The HTML node to be cloned\n   * @return {N}       The copied node\n   */\n  clone(node: N): N;\n\n  /**\n   * @param {T} node    The HTML text node to be split\n   * @param {number} n  The index of the character where the split will occur\n   */\n  split(node: T, n: number): T;\n\n  /**\n   * @param {N|T} node   The HTML node whose sibling is to be obtained\n   * @return {N|T}       The node following the given one (or null)\n   */\n  next(node: N | T): N | T;\n\n  /**\n   * @param {N|T} node   The HTML node whose sibling is to be obtained\n   * @return {N|T}       The node preceding the given one (or null)\n   */\n  previous(node: N | T): N | T;\n\n  /**\n   * @param {N} node   The HTML node whose child is to be obtained\n   * @return {N|T}     The first child of the given node (or null)\n   */\n  firstChild(node: N): N | T;\n\n  /**\n   * @param {N} node   The HTML node whose child is to be obtained\n   * @return {N}       The last child of the given node (or null)\n   */\n  lastChild(node: N): N | T;\n\n  /**\n   * @param {N} node    The HTML node whose children are to be obtained\n   * @return {(N|T)[]}  Array of children for the given node (not a live list)\n   */\n  childNodes(node: N): (N | T)[];\n\n  /**\n   * @param {N} node    The HTML node whose child is to be obtained\n   * @param {number} i  The index of the child to return\n   * @return {N|T}      The i-th child node of the given node (or null)\n   */\n  childNode(node: N, i: number): N | T;\n\n  /**\n   * @param {N | T} node   The HTML node whose tag or node name is to be obtained\n   * @return {string}      The tag or node name of the given node\n   */\n  kind(node: N | T): string;\n\n  /**\n   * @param {N|T} node  The HTML node whose value is to be obtained\n   * @return {string}   The value of the given node\n   */\n  value(node: N | T): string;\n\n  /**\n   * @param {N} node    The HTML node whose text content is to be obtained\n   * @return {string}   The text content of the given node\n   */\n  textContent(node: N): string;\n\n  /**\n   * @param {N} node   The HTML node whose inner HTML string is to be obtained\n   * @return {string}  The serialized content of the node\n   */\n  innerHTML(node: N): string;\n\n  /**\n   * @param {N} node   The HTML node whose outer HTML string is to be obtained\n   * @return {string}  The serialized node and its content\n   */\n  outerHTML(node: N): string;\n\n  /**\n   * @param {N} node   The HTML node whose serialized string is to be obtained\n   * @return {string}  The serialized node and its content\n   */\n  serializeXML(node: N): string;\n\n  /**\n   * @param {N} node               The HTML node whose attribute is to be set\n   * @param {string|number} name   The name of the attribute to set\n   * @param {string} value         The new value of the attribute\n   * @param {string=} ns           The namespace to use for the attribute\n   */\n  setAttribute(node: N, name: string, value: string | number, ns?: string): void;\n\n  /**\n   * @param {N} node           The HTML element whose attributes are to be set\n   * @param {OptionList} def   The attributes to set on that node\n   */\n  setAttributes(node: N, def: OptionList): void;\n\n  /**\n   * @param {N} node        The HTML node whose attribute is to be obtained\n   * @param {string} name   The name of the attribute to get\n   * @return {string}       The value of the given attribute of the given node\n   */\n  getAttribute(node: N, name: string): string;\n\n  /**\n   * @param {N} node        The HTML node whose attribute is to be removed\n   * @param {string} name   The name of the attribute to remove\n   */\n  removeAttribute(node: N, name: string): void;\n\n  /**\n   * @param {N} node        The HTML node whose attribute is to be tested\n   * @param {string} name   The name of the attribute to test\n   * @return {boolean}      True of the node has the given attribute defined\n   */\n  hasAttribute(node: N, name: string): boolean;\n\n  /**\n   * @param {N} node           The HTML node whose attributes are to be returned\n   * @return {AttributeData[]} The list of attributes\n   */\n  allAttributes(node: N): AttributeData[];\n\n  /**\n   * @param {N} node        The HTML node whose class is to be augmented\n   * @param {string} name   The class to be added\n   */\n  addClass(node: N, name: string): void;\n\n  /**\n   * @param {N} node        The HTML node whose class is to be changed\n   * @param {string} name   The class to be removed\n   */\n  removeClass(node: N, name: string): void;\n\n  /**\n   * @param {N} node        The HTML node whose class is to be tested\n   * @param {string} name   The class to test\n   * @return {boolean}      True if the node has the given class\n   */\n  hasClass(node: N, name: string): boolean;\n\n  /**\n   * @param {N} node        The HTML node whose class list is needed\n   * @return {string[]}     An array of the class names for this node\n   */\n  allClasses(node: N): string[];\n\n  /**\n   * @param {N} node        The HTML node whose style is to be changed\n   * @param {string} name   The style to be set\n   * @param {string} value  The new value of the style\n   */\n  setStyle(node: N, name: string, value: string): void;\n\n  /**\n   * @param {N} node        The HTML node whose style is to be obtained\n   * @param {string} name   The style to be obtained\n   * @return {string}       The value of the style\n   */\n  getStyle(node: N, name: string): string;\n\n  /**\n   * @param {N} node        The HTML node whose styles are to be returned\n   * @return {string}       The cssText for the styles\n   */\n  allStyles(node: N): string;\n\n  /**\n   * @param {N} node           The stylesheet node where the rule will be added\n   * @param {string[]} rules   The rule to add at the beginning of the stylesheet\n   */\n  insertRules(node: N, rules: string[]): void;\n\n  /**\n   * @param {N} node        The HTML node whose font size is to be determined\n   * @return {number}       The font size (in pixels) of the node\n   */\n  fontSize(node: N): number;\n\n  /**\n   * @param {N} node        The HTML node whose font family is to be determined\n   * @return {string}       The font family\n   */\n  fontFamily(node: N): string;\n\n  /**\n   * @param {N} node            The HTML node whose dimensions are to be determined\n   * @param {number} em         The number of pixels in an em\n   * @param {boolean} local     True if local coordinates are to be used in SVG elements\n   * @return {[number, number]} The width and height (in ems) of the element\n   */\n  nodeSize(node: N, em?: number, local?: boolean): [number, number];\n\n\n  /**\n   * @param {N} node            The HTML node whose BBox is to be determined\n   * @return {PageBBox}         BBox as {left, right, top, bottom} position on the page (in pixels)\n   */\n  nodeBBox(node: N): PageBBox;\n}\n\n/*****************************************************************/\n/**\n *  Abstract DOMAdaptor class for creating HTML elements\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport abstract class AbstractDOMAdaptor<N, T, D> implements DOMAdaptor<N, T, D> {\n\n  /**\n   * The document in which the HTML nodes will be created\n   */\n  public document: D;\n\n  /**\n   * @param {D} document  The document in which the nodes will be created\n   * @constructor\n   */\n  constructor(document: D = null) {\n    this.document = document;\n  }\n\n  /**\n   * @override\n   */\n  public abstract parse(text: string, format?: string): D;\n\n  /**\n   * @override\n   */\n  public node(kind: string, def: OptionList = {}, children: (N | T)[] = [], ns?: string) {\n    const node = this.create(kind, ns);\n    this.setAttributes(node, def);\n    for (const child of children) {\n      this.append(node, child);\n    }\n    return node as N;\n  }\n\n  /**\n   * @param {string} kind  The type of the node to create\n   * @param {string} ns    The optional namespace in which to create the node\n   * @return {N}           The created node\n   */\n  protected abstract create(kind: string, ns?: string): N;\n\n  /**\n   * @override\n   */\n  public abstract text(text: string): T;\n\n  /**\n   * @param {N} node           The HTML element whose attributes are to be set\n   * @param {OptionList} def   The attributes to set on that node\n   */\n  public setAttributes(node: N, def: OptionList) {\n    if (def.style && typeof(def.style) !== 'string') {\n      for (let key of Object.keys(def.style)) {\n        this.setStyle(node, key.replace(/-([a-z])/g, (_m, c) => c.toUpperCase()), def.style[key]);\n      }\n    }\n    if (def.properties) {\n      for (let key of Object.keys(def.properties)) {\n        (node as OptionList)[key] = def.properties[key];\n      }\n    }\n    for (let key of Object.keys(def)) {\n      if ((key !== 'style' || typeof(def.style) === 'string') && key !== 'properties') {\n        this.setAttribute(node, key, def[key]);\n      }\n    }\n  }\n\n  /**\n   * @override\n   */\n  public abstract head(doc: D): N;\n\n  /**\n   * @override\n   */\n  public abstract body(doc: D): N;\n\n  /**\n   * @override\n   */\n  public abstract root(doc: D): N;\n\n  /**\n   * @override\n   */\n  public abstract doctype(doc: D): string;\n\n  /**\n   * @override\n   */\n  public abstract tags(node: N, name: string, ns?: string): N[];\n\n  /**\n   * @override\n   */\n  public abstract getElements(nodes: (string | N | N[])[], document: D): N[];\n\n  /**\n   * @override\n   */\n  public abstract contains(container: N, node: N | T): boolean;\n\n  /**\n   * @override\n   */\n  public abstract parent(node: N | T): N;\n\n  /**\n   * @override\n   */\n  public abstract append(node: N, child: N | T): N | T;\n\n  /**\n   * @override\n   */\n  public abstract insert(nchild: N | T, ochild: N | T): void;\n\n  /**\n   * @override\n   */\n  public abstract remove(child: N | T): N | T;\n\n  /**\n   * @override\n   */\n  public replace(nnode: N | T, onode: N | T) {\n    this.insert(nnode, onode);\n    this.remove(onode);\n    return onode;\n  }\n\n  /**\n   * @override\n   */\n  public abstract clone(node: N):  N;\n\n  /**\n   * @override\n   */\n  public abstract split(node: T, n: number): T;\n\n  /**\n   * @override\n   */\n  public abstract next(node: N | T): N | T;\n\n  /**\n   * @override\n   */\n  public abstract previous(node: N | T): N | T;\n\n  /**\n   * @override\n   */\n  public abstract firstChild(node: N): N | T;\n\n  /**\n   * @override\n   */\n  public abstract lastChild(node: N): N | T;\n\n  /**\n   * @override\n   */\n  public abstract childNodes(node: N): (N | T)[];\n\n  /**\n   * @override\n   */\n  public childNode(node: N, i: number) {\n    return this.childNodes(node)[i];\n  }\n\n  /**\n   * @override\n   */\n  public abstract kind(node: N | T): string;\n\n  /**\n   * @override\n   */\n  public abstract value(node: N | T): string;\n\n  /**\n   * @override\n   */\n  public abstract textContent(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract innerHTML(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract outerHTML(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract serializeXML(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract setAttribute(node: N, name: string, value: string, ns?: string): void;\n\n  /**\n   * @override\n   */\n  public abstract getAttribute(node: N, name: string): string;\n\n  /**\n   * @override\n   */\n  public abstract removeAttribute(node: N, name: string): void;\n\n  /**\n   * @override\n   */\n  public abstract hasAttribute(node: N, name: string): boolean;\n\n\n  /**\n   * @override\n   */\n  public abstract allAttributes(node: N): AttributeData[];\n\n  /**\n   * @override\n   */\n  public abstract addClass(node: N, name: string): void;\n\n  /**\n   * @override\n   */\n  public abstract removeClass(node: N, name: string): void;\n\n  /**\n   * @override\n   */\n  public abstract hasClass(node: N, name: string): boolean;\n\n  /**\n   * @override\n   */\n  public allClasses(node: N) {\n    const classes = this.getAttribute(node, 'class');\n    return (!classes ? [] as string[] :\n            classes.replace(/  +/g, ' ').replace(/^ /, '').replace(/ $/, '').split(/ /));\n  }\n\n  /**\n   * @override\n   */\n  public abstract setStyle(node: N, name: string, value: string): void;\n\n  /**\n   * @override\n   */\n  public abstract getStyle(node: N, name: string): string;\n\n  /**\n   * @override\n   */\n  public abstract allStyles(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract insertRules(node: N, rules: string[]): void;\n\n  /**\n   * @override\n   */\n  public abstract fontSize(node: N): number;\n\n  /**\n   * @override\n   */\n  public abstract fontFamily(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract nodeSize(node: N, em?: number, local?: boolean): [number, number];\n\n  /**\n   * @override\n   */\n  public abstract nodeBBox(node: N): PageBBox;\n\n}\n"]},"metadata":{},"sourceType":"script"}