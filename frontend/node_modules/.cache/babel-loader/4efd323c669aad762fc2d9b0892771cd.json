{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NodeFactory = void 0;\n\nvar NodeUtil_js_1 = require(\"./NodeUtil.js\");\n\nvar NodeFactory = function () {\n  function NodeFactory() {\n    this.mmlFactory = null;\n    this.factory = {\n      'node': NodeFactory.createNode,\n      'token': NodeFactory.createToken,\n      'text': NodeFactory.createText,\n      'error': NodeFactory.createError\n    };\n  }\n\n  NodeFactory.createNode = function (factory, kind, children, def, text) {\n    if (children === void 0) {\n      children = [];\n    }\n\n    if (def === void 0) {\n      def = {};\n    }\n\n    var node = factory.mmlFactory.create(kind);\n    node.setChildren(children);\n\n    if (text) {\n      node.appendChild(text);\n    }\n\n    NodeUtil_js_1.default.setProperties(node, def);\n    return node;\n  };\n\n  NodeFactory.createToken = function (factory, kind, def, text) {\n    if (def === void 0) {\n      def = {};\n    }\n\n    if (text === void 0) {\n      text = '';\n    }\n\n    var textNode = factory.create('text', text);\n    return factory.create('node', kind, [], def, textNode);\n  };\n\n  NodeFactory.createText = function (factory, text) {\n    if (text == null) {\n      return null;\n    }\n\n    return factory.mmlFactory.create('text').setText(text);\n  };\n\n  NodeFactory.createError = function (factory, message) {\n    var text = factory.create('text', message);\n    var mtext = factory.create('node', 'mtext', [], {}, text);\n    var error = factory.create('node', 'merror', [mtext], {\n      'data-mjx-error': message\n    });\n    return error;\n  };\n\n  NodeFactory.prototype.setMmlFactory = function (mmlFactory) {\n    this.mmlFactory = mmlFactory;\n  };\n\n  NodeFactory.prototype.set = function (kind, func) {\n    this.factory[kind] = func;\n  };\n\n  NodeFactory.prototype.setCreators = function (maps) {\n    for (var kind in maps) {\n      this.set(kind, maps[kind]);\n    }\n  };\n\n  NodeFactory.prototype.create = function (kind) {\n    var rest = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n\n    var func = this.factory[kind] || this.factory['node'];\n    var node = func.apply(void 0, __spreadArray([this, rest[0]], __read(rest.slice(1))));\n\n    if (kind === 'node') {\n      this.configuration.addNode(rest[0], node);\n    }\n\n    return node;\n  };\n\n  NodeFactory.prototype.get = function (kind) {\n    return this.factory[kind];\n  };\n\n  return NodeFactory;\n}();\n\nexports.NodeFactory = NodeFactory;","map":{"version":3,"mappings":"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","names":["NodeFactory","createNode","createToken","createText","createError","factory","kind","children","def","text","node","mmlFactory","create","setChildren","appendChild","NodeUtil_js_1","setProperties","textNode","setText","message","mtext","error","func","maps","set","rest","__spreadArray","__read","slice","configuration","addNode","exports"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/input/tex/NodeFactory.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2009-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Node factory for creating MmlNodes. This allows extension\n *     packages to add node constructors or overwrite existing ones.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {TextNode, MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {MmlFactory} from '../../core/MmlTree/MmlFactory.js';\nimport ParseOptions from './ParseOptions.js';\nimport NodeUtil from './NodeUtil.js';\n\n\nexport type NodeFactoryMethod = (factory: NodeFactory, kind: string, ...rest: any[]) => MmlNode;\n\nexport class NodeFactory {\n\n  /**\n   * Parser configuration that can be used to pass information between node methods.\n   * @type {ParseOption}\n   */\n  public configuration: ParseOptions;\n\n\n  /**\n   * The external node factory.\n   * @type {MmlFactory}\n   */\n  protected mmlFactory: MmlFactory = null;\n\n\n  /**\n   * The factory table populated with some default methods.\n   */\n  private factory: {[kind: string]: NodeFactoryMethod} =\n    {'node': NodeFactory.createNode,\n     'token': NodeFactory.createToken,\n     'text': NodeFactory.createText,\n     'error': NodeFactory.createError\n    };\n\n  /**\n   * Default node generation function.\n   * @param {NodeFactory} factory The current node factory.\n   * @param {string} kind The type of node to create.\n   * @param {MmlNode[]} children Its children.\n   * @param {any=} def Its properties.\n   * @param {TextNode=} text An optional text node if this is a token.\n   * @return {MmlNode} The newly created Mml node.\n   */\n  public static createNode(factory: NodeFactory, kind: string,\n                           children: MmlNode[] = [], def: any = {},\n                           text?: TextNode): MmlNode {\n    const node = factory.mmlFactory.create(kind);\n    node.setChildren(children);\n    if (text) {\n      node.appendChild(text);\n    }\n    NodeUtil.setProperties(node, def);\n    return node;\n  }\n\n\n  /**\n   * Default token generation function.\n   * @param {NodeFactory} factory The current node factory.\n   * @param {string} kind The type of node to create.\n   * @param {any} def Its properties.\n   * @param {string} text Text of the token.\n   * @return {MmlNode} The newly created token node.\n   */\n  public static createToken(factory: NodeFactory, kind: string,\n                            def: any = {}, text: string = ''): MmlNode  {\n    const textNode = factory.create('text', text);\n    return factory.create('node', kind, [], def, textNode);\n  }\n\n\n  /**\n   * Default text node generation function.\n   * @param {NodeFactory} factory The current node factory.\n   * @param {string} text The text for the new node.\n   * @return {TextNode} The newly created text node.\n   */\n  public static createText(factory: NodeFactory, text: string): TextNode  {\n    if (text == null) {\n      return null;\n    }\n    return (factory.mmlFactory.create('text') as TextNode).setText(text);\n  }\n\n\n  /**\n   * Default error node generation function.\n   * @param {NodeFactory} factory The current node factory.\n   * @param {string} message The error message.\n   * @return {MmlNode} The newly created error node.\n   */\n  public static createError(factory: NodeFactory, message: string): MmlNode  {\n    let text = factory.create('text', message);\n    let mtext = factory.create('node', 'mtext', [], {}, text);\n    let error = factory.create('node', 'merror', [mtext], {'data-mjx-error': message});\n    return error;\n  }\n\n\n  /**\n   * @param {MmlFactory} mmlFactory   The MmlFactory for the TeX jax to use\n   */\n  public setMmlFactory(mmlFactory: MmlFactory) {\n    this.mmlFactory = mmlFactory;\n  }\n\n  /**\n   * Adds a method to the factory.\n   * @param {string} kind The type of node the method creates.\n   * @param {NodeFactoryMethod} func The node creator.\n   */\n  public set(kind: string, func: NodeFactoryMethod) {\n    this.factory[kind] = func;\n  }\n\n\n  /**\n   * Adds a set of node creators to the factory.\n   * @param {Object.<NodeFactoryMethod>} maps The set of functions.\n   */\n  public setCreators(maps: {[kind: string]: NodeFactoryMethod}) {\n    for (let kind in maps) {\n      this.set(kind, maps[kind]);\n    }\n  }\n\n\n  /**\n   * Creates a node for the internal data structure from the factory.\n   * @param {string} kind The type of node to be created.\n   * @param {any[]} ...rest The arguments for the node.\n   * @return {MmlNode} The created node.\n   */\n  public create(kind: string, ...rest: any[]): MmlNode {\n    const func = this.factory[kind] || this.factory['node'];\n    const node = func(this, rest[0], ...rest.slice(1));\n    if (kind === 'node') {\n      this.configuration.addNode(rest[0], node);\n    }\n    return node;\n  }\n\n\n  /**\n   * @param {string} kind The method for generating a node of given kind.\n   */\n  public get(kind: string) {\n    return this.factory[kind];\n  }\n\n}\n"]},"metadata":{},"sourceType":"script"}