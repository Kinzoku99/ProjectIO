{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar MmlNode_js_1 = require(\"../../core/MmlTree/MmlNode.js\");\n\nvar NodeUtil_js_1 = require(\"./NodeUtil.js\");\n\nvar TexParser_js_1 = require(\"./TexParser.js\");\n\nvar TexError_js_1 = require(\"./TexError.js\");\n\nvar Entities_js_1 = require(\"../../util/Entities.js\");\n\nvar ParseUtil;\n\n(function (ParseUtil) {\n  var emPerInch = 7.2;\n  var pxPerInch = 72;\n  var UNIT_CASES = {\n    'em': function (m) {\n      return m;\n    },\n    'ex': function (m) {\n      return m * .43;\n    },\n    'pt': function (m) {\n      return m / 10;\n    },\n    'pc': function (m) {\n      return m * 1.2;\n    },\n    'px': function (m) {\n      return m * emPerInch / pxPerInch;\n    },\n    'in': function (m) {\n      return m * emPerInch;\n    },\n    'cm': function (m) {\n      return m * emPerInch / 2.54;\n    },\n    'mm': function (m) {\n      return m * emPerInch / 25.4;\n    },\n    'mu': function (m) {\n      return m / 18;\n    }\n  };\n  var num = '([-+]?([.,]\\\\d+|\\\\d+([.,]\\\\d*)?))';\n  var unit = '(pt|em|ex|mu|px|mm|cm|in|pc)';\n  var dimenEnd = RegExp('^\\\\s*' + num + '\\\\s*' + unit + '\\\\s*$');\n  var dimenRest = RegExp('^\\\\s*' + num + '\\\\s*' + unit + ' ?');\n\n  function matchDimen(dim, rest) {\n    if (rest === void 0) {\n      rest = false;\n    }\n\n    var match = dim.match(rest ? dimenRest : dimenEnd);\n    return match ? muReplace([match[1].replace(/,/, '.'), match[4], match[0].length]) : [null, null, 0];\n  }\n\n  ParseUtil.matchDimen = matchDimen;\n\n  function muReplace(_a) {\n    var _b = __read(_a, 3),\n        value = _b[0],\n        unit = _b[1],\n        length = _b[2];\n\n    if (unit !== 'mu') {\n      return [value, unit, length];\n    }\n\n    var em = Em(UNIT_CASES[unit](parseFloat(value || '1')));\n    return [em.slice(0, -2), 'em', length];\n  }\n\n  function dimen2em(dim) {\n    var _a = __read(matchDimen(dim), 2),\n        value = _a[0],\n        unit = _a[1];\n\n    var m = parseFloat(value || '1');\n    var func = UNIT_CASES[unit];\n    return func ? func(m) : 0;\n  }\n\n  ParseUtil.dimen2em = dimen2em;\n\n  function Em(m) {\n    if (Math.abs(m) < .0006) {\n      return '0em';\n    }\n\n    return m.toFixed(3).replace(/\\.?0+$/, '') + 'em';\n  }\n\n  ParseUtil.Em = Em;\n\n  function cols() {\n    var W = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      W[_i] = arguments[_i];\n    }\n\n    return W.map(function (n) {\n      return Em(n);\n    }).join(' ');\n  }\n\n  ParseUtil.cols = cols;\n\n  function fenced(configuration, open, mml, close, big, color) {\n    if (big === void 0) {\n      big = '';\n    }\n\n    if (color === void 0) {\n      color = '';\n    }\n\n    var nf = configuration.nodeFactory;\n    var mrow = nf.create('node', 'mrow', [], {\n      open: open,\n      close: close,\n      texClass: MmlNode_js_1.TEXCLASS.INNER\n    });\n    var mo;\n\n    if (big) {\n      mo = new TexParser_js_1.default('\\\\' + big + 'l' + open, configuration.parser.stack.env, configuration).mml();\n    } else {\n      var openNode = nf.create('text', open);\n      mo = nf.create('node', 'mo', [], {\n        fence: true,\n        stretchy: true,\n        symmetric: true,\n        texClass: MmlNode_js_1.TEXCLASS.OPEN\n      }, openNode);\n    }\n\n    NodeUtil_js_1.default.appendChildren(mrow, [mo, mml]);\n\n    if (big) {\n      mo = new TexParser_js_1.default('\\\\' + big + 'r' + close, configuration.parser.stack.env, configuration).mml();\n    } else {\n      var closeNode = nf.create('text', close);\n      mo = nf.create('node', 'mo', [], {\n        fence: true,\n        stretchy: true,\n        symmetric: true,\n        texClass: MmlNode_js_1.TEXCLASS.CLOSE\n      }, closeNode);\n    }\n\n    color && mo.attributes.set('mathcolor', color);\n    NodeUtil_js_1.default.appendChildren(mrow, [mo]);\n    return mrow;\n  }\n\n  ParseUtil.fenced = fenced;\n\n  function fixedFence(configuration, open, mml, close) {\n    var mrow = configuration.nodeFactory.create('node', 'mrow', [], {\n      open: open,\n      close: close,\n      texClass: MmlNode_js_1.TEXCLASS.ORD\n    });\n\n    if (open) {\n      NodeUtil_js_1.default.appendChildren(mrow, [mathPalette(configuration, open, 'l')]);\n    }\n\n    if (NodeUtil_js_1.default.isType(mml, 'mrow')) {\n      NodeUtil_js_1.default.appendChildren(mrow, NodeUtil_js_1.default.getChildren(mml));\n    } else {\n      NodeUtil_js_1.default.appendChildren(mrow, [mml]);\n    }\n\n    if (close) {\n      NodeUtil_js_1.default.appendChildren(mrow, [mathPalette(configuration, close, 'r')]);\n    }\n\n    return mrow;\n  }\n\n  ParseUtil.fixedFence = fixedFence;\n\n  function mathPalette(configuration, fence, side) {\n    if (fence === '{' || fence === '}') {\n      fence = '\\\\' + fence;\n    }\n\n    var D = '{\\\\bigg' + side + ' ' + fence + '}';\n    var T = '{\\\\big' + side + ' ' + fence + '}';\n    return new TexParser_js_1.default('\\\\mathchoice' + D + T + T + T, {}, configuration).mml();\n  }\n\n  ParseUtil.mathPalette = mathPalette;\n\n  function fixInitialMO(configuration, nodes) {\n    for (var i = 0, m = nodes.length; i < m; i++) {\n      var child = nodes[i];\n\n      if (child && !NodeUtil_js_1.default.isType(child, 'mspace') && (!NodeUtil_js_1.default.isType(child, 'TeXAtom') || NodeUtil_js_1.default.getChildren(child)[0] && NodeUtil_js_1.default.getChildren(NodeUtil_js_1.default.getChildren(child)[0]).length)) {\n        if (NodeUtil_js_1.default.isEmbellished(child) || NodeUtil_js_1.default.isType(child, 'TeXAtom') && NodeUtil_js_1.default.getTexClass(child) === MmlNode_js_1.TEXCLASS.REL) {\n          var mi = configuration.nodeFactory.create('node', 'mi');\n          nodes.unshift(mi);\n        }\n\n        break;\n      }\n    }\n  }\n\n  ParseUtil.fixInitialMO = fixInitialMO;\n\n  function internalMath(parser, text, level, font) {\n    if (parser.configuration.options.internalMath) {\n      return parser.configuration.options.internalMath(parser, text, level, font);\n    }\n\n    var mathvariant = font || parser.stack.env.font;\n    var def = mathvariant ? {\n      mathvariant: mathvariant\n    } : {};\n    var mml = [],\n        i = 0,\n        k = 0,\n        c,\n        node,\n        match = '',\n        braces = 0;\n\n    if (text.match(/\\\\?[${}\\\\]|\\\\\\(|\\\\(eq)?ref\\s*\\{/)) {\n      while (i < text.length) {\n        c = text.charAt(i++);\n\n        if (c === '$') {\n          if (match === '$' && braces === 0) {\n            node = parser.create('node', 'TeXAtom', [new TexParser_js_1.default(text.slice(k, i - 1), {}, parser.configuration).mml()]);\n            mml.push(node);\n            match = '';\n            k = i;\n          } else if (match === '') {\n            if (k < i - 1) {\n              mml.push(internalText(parser, text.slice(k, i - 1), def));\n            }\n\n            match = '$';\n            k = i;\n          }\n        } else if (c === '{' && match !== '') {\n          braces++;\n        } else if (c === '}') {\n          if (match === '}' && braces === 0) {\n            var atom = new TexParser_js_1.default(text.slice(k, i), {}, parser.configuration).mml();\n            node = parser.create('node', 'TeXAtom', [atom], def);\n            mml.push(node);\n            match = '';\n            k = i;\n          } else if (match !== '') {\n            if (braces) {\n              braces--;\n            }\n          }\n        } else if (c === '\\\\') {\n          if (match === '' && text.substr(i).match(/^(eq)?ref\\s*\\{/)) {\n            var len = RegExp['$&'].length;\n\n            if (k < i - 1) {\n              mml.push(internalText(parser, text.slice(k, i - 1), def));\n            }\n\n            match = '}';\n            k = i - 1;\n            i += len;\n          } else {\n            c = text.charAt(i++);\n\n            if (c === '(' && match === '') {\n              if (k < i - 2) {\n                mml.push(internalText(parser, text.slice(k, i - 2), def));\n              }\n\n              match = ')';\n              k = i;\n            } else if (c === ')' && match === ')' && braces === 0) {\n              node = parser.create('node', 'TeXAtom', [new TexParser_js_1.default(text.slice(k, i - 2), {}, parser.configuration).mml()]);\n              mml.push(node);\n              match = '';\n              k = i;\n            } else if (c.match(/[${}\\\\]/) && match === '') {\n              i--;\n              text = text.substr(0, i - 1) + text.substr(i);\n            }\n          }\n        }\n      }\n\n      if (match !== '') {\n        throw new TexError_js_1.default('MathNotTerminated', 'Math not terminated in text box');\n      }\n    }\n\n    if (k < text.length) {\n      mml.push(internalText(parser, text.slice(k), def));\n    }\n\n    if (level != null) {\n      mml = [parser.create('node', 'mstyle', mml, {\n        displaystyle: false,\n        scriptlevel: level\n      })];\n    } else if (mml.length > 1) {\n      mml = [parser.create('node', 'mrow', mml)];\n    }\n\n    return mml;\n  }\n\n  ParseUtil.internalMath = internalMath;\n\n  function internalText(parser, text, def) {\n    text = text.replace(/^\\s+/, Entities_js_1.entities.nbsp).replace(/\\s+$/, Entities_js_1.entities.nbsp);\n    var textNode = parser.create('text', text);\n    return parser.create('node', 'mtext', [], def, textNode);\n  }\n\n  ParseUtil.internalText = internalText;\n\n  function underOver(parser, base, script, pos, stack) {\n    ParseUtil.checkMovableLimits(base);\n\n    if (NodeUtil_js_1.default.isType(base, 'munderover') && NodeUtil_js_1.default.isEmbellished(base)) {\n      NodeUtil_js_1.default.setProperties(NodeUtil_js_1.default.getCoreMO(base), {\n        lspace: 0,\n        rspace: 0\n      });\n      var mo = parser.create('node', 'mo', [], {\n        rspace: 0\n      });\n      base = parser.create('node', 'mrow', [mo, base]);\n    }\n\n    var mml = parser.create('node', 'munderover', [base]);\n    NodeUtil_js_1.default.setChild(mml, pos === 'over' ? mml.over : mml.under, script);\n    var node = mml;\n\n    if (stack) {\n      node = parser.create('node', 'TeXAtom', [mml], {\n        texClass: MmlNode_js_1.TEXCLASS.OP,\n        movesupsub: true\n      });\n    }\n\n    NodeUtil_js_1.default.setProperty(node, 'subsupOK', true);\n    return node;\n  }\n\n  ParseUtil.underOver = underOver;\n\n  function checkMovableLimits(base) {\n    var symbol = NodeUtil_js_1.default.isType(base, 'mo') ? NodeUtil_js_1.default.getForm(base) : null;\n\n    if (NodeUtil_js_1.default.getProperty(base, 'movablelimits') || symbol && symbol[3] && symbol[3].movablelimits) {\n      NodeUtil_js_1.default.setProperties(base, {\n        movablelimits: false\n      });\n    }\n  }\n\n  ParseUtil.checkMovableLimits = checkMovableLimits;\n\n  function trimSpaces(text) {\n    if (typeof text !== 'string') {\n      return text;\n    }\n\n    var TEXT = text.trim();\n\n    if (TEXT.match(/\\\\$/) && text.match(/ $/)) {\n      TEXT += ' ';\n    }\n\n    return TEXT;\n  }\n\n  ParseUtil.trimSpaces = trimSpaces;\n\n  function setArrayAlign(array, align) {\n    align = ParseUtil.trimSpaces(align || '');\n\n    if (align === 't') {\n      array.arraydef.align = 'baseline 1';\n    } else if (align === 'b') {\n      array.arraydef.align = 'baseline -1';\n    } else if (align === 'c') {\n      array.arraydef.align = 'axis';\n    } else if (align) {\n      array.arraydef.align = align;\n    }\n\n    return array;\n  }\n\n  ParseUtil.setArrayAlign = setArrayAlign;\n\n  function substituteArgs(parser, args, str) {\n    var text = '';\n    var newstring = '';\n    var i = 0;\n\n    while (i < str.length) {\n      var c = str.charAt(i++);\n\n      if (c === '\\\\') {\n        text += c + str.charAt(i++);\n      } else if (c === '#') {\n        c = str.charAt(i++);\n\n        if (c === '#') {\n          text += c;\n        } else {\n          if (!c.match(/[1-9]/) || parseInt(c, 10) > args.length) {\n            throw new TexError_js_1.default('IllegalMacroParam', 'Illegal macro parameter reference');\n          }\n\n          newstring = addArgs(parser, addArgs(parser, newstring, text), args[parseInt(c, 10) - 1]);\n          text = '';\n        }\n      } else {\n        text += c;\n      }\n    }\n\n    return addArgs(parser, newstring, text);\n  }\n\n  ParseUtil.substituteArgs = substituteArgs;\n\n  function addArgs(parser, s1, s2) {\n    if (s2.match(/^[a-z]/i) && s1.match(/(^|[^\\\\])(\\\\\\\\)*\\\\[a-z]+$/i)) {\n      s1 += ' ';\n    }\n\n    if (s1.length + s2.length > parser.configuration.options['maxBuffer']) {\n      throw new TexError_js_1.default('MaxBufferSize', 'MathJax internal buffer size exceeded; is there a' + ' recursive macro call?');\n    }\n\n    return s1 + s2;\n  }\n\n  ParseUtil.addArgs = addArgs;\n\n  function checkMaxMacros(parser, isMacro) {\n    if (isMacro === void 0) {\n      isMacro = true;\n    }\n\n    if (++parser.macroCount <= parser.configuration.options['maxMacros']) {\n      return;\n    }\n\n    if (isMacro) {\n      throw new TexError_js_1.default('MaxMacroSub1', 'MathJax maximum macro substitution count exceeded; ' + 'is here a recursive macro call?');\n    } else {\n      throw new TexError_js_1.default('MaxMacroSub2', 'MathJax maximum substitution count exceeded; ' + 'is there a recursive latex environment?');\n    }\n  }\n\n  ParseUtil.checkMaxMacros = checkMaxMacros;\n\n  function checkEqnEnv(parser) {\n    if (parser.stack.global.eqnenv) {\n      throw new TexError_js_1.default('ErroneousNestingEq', 'Erroneous nesting of equation structures');\n    }\n\n    parser.stack.global.eqnenv = true;\n  }\n\n  ParseUtil.checkEqnEnv = checkEqnEnv;\n\n  function copyNode(node, parser) {\n    var tree = node.copy();\n    var options = parser.configuration;\n    tree.walkTree(function (n) {\n      var e_1, _a;\n\n      options.addNode(n.kind, n);\n      var lists = (n.getProperty('in-lists') || '').split(/,/);\n\n      try {\n        for (var lists_1 = __values(lists), lists_1_1 = lists_1.next(); !lists_1_1.done; lists_1_1 = lists_1.next()) {\n          var list = lists_1_1.value;\n          options.addNode(list, n);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (lists_1_1 && !lists_1_1.done && (_a = lists_1.return)) _a.call(lists_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n    return tree;\n  }\n\n  ParseUtil.copyNode = copyNode;\n\n  function MmlFilterAttribute(_parser, _name, value) {\n    return value;\n  }\n\n  ParseUtil.MmlFilterAttribute = MmlFilterAttribute;\n\n  function getFontDef(parser) {\n    var font = parser.stack.env['font'];\n    return font ? {\n      mathvariant: font\n    } : {};\n  }\n\n  ParseUtil.getFontDef = getFontDef;\n\n  function keyvalOptions(attrib, allowed, error) {\n    var e_2, _a;\n\n    if (allowed === void 0) {\n      allowed = null;\n    }\n\n    if (error === void 0) {\n      error = false;\n    }\n\n    var def = readKeyval(attrib);\n\n    if (allowed) {\n      try {\n        for (var _b = __values(Object.keys(def)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var key = _c.value;\n\n          if (!allowed.hasOwnProperty(key)) {\n            if (error) {\n              throw new TexError_js_1.default('InvalidOption', 'Invalid option: %1', key);\n            }\n\n            delete def[key];\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n\n    return def;\n  }\n\n  ParseUtil.keyvalOptions = keyvalOptions;\n\n  function readKeyval(text) {\n    var _a, _b;\n\n    var options = {};\n    var rest = text;\n    var end, key, val;\n\n    while (rest) {\n      _a = __read(readValue(rest, ['=', ',']), 3), key = _a[0], end = _a[1], rest = _a[2];\n\n      if (end === '=') {\n        _b = __read(readValue(rest, [',']), 3), val = _b[0], end = _b[1], rest = _b[2];\n        val = val === 'false' || val === 'true' ? JSON.parse(val) : val;\n        options[key] = val;\n      } else if (key) {\n        options[key] = true;\n      }\n    }\n\n    return options;\n  }\n\n  function removeBraces(text, count) {\n    while (count > 0) {\n      text = text.trim().slice(1, -1);\n      count--;\n    }\n\n    return text.trim();\n  }\n\n  function readValue(text, end) {\n    var length = text.length;\n    var braces = 0;\n    var value = '';\n    var index = 0;\n    var start = 0;\n    var startCount = true;\n    var stopCount = false;\n\n    while (index < length) {\n      var c = text[index++];\n\n      switch (c) {\n        case ' ':\n          break;\n\n        case '{':\n          if (startCount) {\n            start++;\n          } else {\n            stopCount = false;\n\n            if (start > braces) {\n              start = braces;\n            }\n          }\n\n          braces++;\n          break;\n\n        case '}':\n          if (braces) {\n            braces--;\n          }\n\n          if (startCount || stopCount) {\n            start--;\n            stopCount = true;\n          }\n\n          startCount = false;\n          break;\n\n        default:\n          if (!braces && end.indexOf(c) !== -1) {\n            return [stopCount ? 'true' : removeBraces(value, start), c, text.slice(index)];\n          }\n\n          startCount = false;\n          stopCount = false;\n      }\n\n      value += c;\n    }\n\n    if (braces) {\n      throw new TexError_js_1.default('ExtraOpenMissingClose', 'Extra open brace or missing close brace');\n    }\n\n    return [stopCount ? 'true' : removeBraces(value, start), '', text.slice(index)];\n  }\n})(ParseUtil || (ParseUtil = {}));\n\nexports.default = ParseUtil;","map":{"version":3,"mappings":"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","names":["ParseUtil","emPerInch","pxPerInch","UNIT_CASES","num","unit","dimenEnd","RegExp","dimenRest","matchDimen","dim","rest","match","muReplace","replace","length","_a","_b","value","em","Em","parseFloat","slice","dimen2em","m","func","Math","abs","toFixed","cols","W","map","n","join","fenced","configuration","open","mml","close","big","color","nf","nodeFactory","mrow","create","texClass","MmlNode_js_1","INNER","mo","TexParser_js_1","parser","stack","env","openNode","fence","stretchy","symmetric","OPEN","NodeUtil_js_1","appendChildren","closeNode","CLOSE","attributes","set","fixedFence","ORD","mathPalette","isType","getChildren","side","D","T","fixInitialMO","nodes","i","child","isEmbellished","getTexClass","REL","mi","unshift","internalMath","text","level","font","options","mathvariant","def","k","c","node","braces","charAt","push","internalText","atom","substr","len","TexError_js_1","displaystyle","scriptlevel","Entities_js_1","nbsp","textNode","underOver","base","script","pos","checkMovableLimits","setProperties","getCoreMO","lspace","rspace","setChild","over","under","OP","movesupsub","setProperty","symbol","getForm","getProperty","movablelimits","trimSpaces","TEXT","trim","setArrayAlign","array","align","arraydef","substituteArgs","args","str","newstring","parseInt","addArgs","s1","s2","checkMaxMacros","isMacro","macroCount","checkEqnEnv","global","eqnenv","copyNode","tree","copy","walkTree","addNode","kind","lists","split","lists_1_1","list","MmlFilterAttribute","_parser","_name","getFontDef","keyvalOptions","attrib","allowed","error","readKeyval","keys","_c","key","hasOwnProperty","end","val","readValue","JSON","parse","removeBraces","count","index","start","startCount","stopCount","indexOf","exports"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/input/tex/ParseUtil.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2009-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview A namespace for utility functions for the TeX Parser.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {TEXCLASS, MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {EnvList} from './StackItem.js';\nimport {ArrayItem} from './base/BaseItems.js';\nimport ParseOptions from './ParseOptions.js';\nimport NodeUtil from './NodeUtil.js';\nimport TexParser from './TexParser.js';\nimport TexError from './TexError.js';\nimport {entities} from '../../util/Entities.js';\nimport {MmlMunderover} from '../../core/MmlTree/MmlNodes/munderover.js';\n\n\nnamespace ParseUtil {\n\n  // TODO (VS): Combine some of this with lengths in util.\n  const emPerInch = 7.2;\n  const pxPerInch = 72;\n  // Note, the following are TeX CM font values.\n  const UNIT_CASES: {[key: string]: ((m: number) => number)}  = {\n    'em': m => m,\n    'ex': m => m * .43,\n    'pt': m => m / 10,                    // 10 pt to an em\n    'pc': m => m * 1.2,                   // 12 pt to a pc\n    'px': m => m * emPerInch / pxPerInch,\n    'in': m => m * emPerInch,\n    'cm': m => m * emPerInch / 2.54, // 2.54 cm to an inch\n    'mm': m => m * emPerInch / 25.4, // 10 mm to a cm\n    'mu': m => m / 18,\n  };\n  const num = '([-+]?([.,]\\\\d+|\\\\d+([.,]\\\\d*)?))';\n  const unit = '(pt|em|ex|mu|px|mm|cm|in|pc)';\n  const dimenEnd = RegExp('^\\\\s*' + num + '\\\\s*' + unit + '\\\\s*$');\n  const dimenRest = RegExp('^\\\\s*' + num + '\\\\s*' + unit + ' ?');\n\n\n  /**\n   * Matches for a dimension argument.\n   * @param {string} dim The argument.\n   * @param {boolean} rest Allow for trailing garbage in the dimension string.\n   * @return {[string, string, number]} The match result as (Anglosaxon) value,\n   *     unit name, length of matched string. The latter is interesting in the\n   *     case of trailing garbage.\n   */\n  export function matchDimen(\n    dim: string, rest: boolean = false): [string, string, number] {\n      let match = dim.match(rest ? dimenRest : dimenEnd);\n      return match ?\n        muReplace([match[1].replace(/,/, '.'), match[4], match[0].length]) :\n        [null, null, 0];\n  }\n\n\n  /**\n   * Transforms mu dimension to em if necessary.\n   * @param {[string, string, number]} [value, unit, length] The dimension triple.\n   * @return {[string, string, number]} [value, unit, length] The transformed triple.\n   */\n  function muReplace([value, unit, length]: [string, string, number]): [string, string, number] {\n    if (unit !== 'mu') {\n      return [value, unit, length];\n    }\n    let em = Em(UNIT_CASES[unit](parseFloat(value || '1')));\n    return [em.slice(0, -2), 'em', length];\n  }\n\n\n  /**\n   * Convert a dimension string into standard em dimension.\n   * @param {string} dim The attribute string.\n   * @return {number} The numerical value.\n   */\n  export function dimen2em(dim: string): number {\n    let [value, unit] = matchDimen(dim);\n    let m = parseFloat(value || '1');\n    let func = UNIT_CASES[unit];\n    return func ? func(m) : 0;\n  }\n\n\n  /**\n   * Turns a number into an em value.\n   * @param {number} m The number.\n   * @return {string} The em dimension string.\n   */\n  export function Em(m: number): string {\n    if (Math.abs(m) < .0006) {\n      return '0em';\n    }\n    return m.toFixed(3).replace(/\\.?0+$/, '') + 'em';\n  }\n\n\n  /**\n   * Takes an array of numbers and returns a space-separated string of em values.\n   * @param {number[]} W  The widths to be turned into em values\n   * @return {string}     The numbers with em units, separated by spaces.\n   */\n  export function cols(...W: number[]): string {\n    return W.map(n => Em(n)).join(' ');\n  }\n\n\n  /**\n   * Create an mrow that has stretchy delimiters at either end, as needed\n   * @param {ParseOptions} configuration Current parse options.\n   * @param {string} open The opening fence.\n   * @param {MmlNode} mml The enclosed node.\n   * @param {string} close The closing fence.\n   * @param {string=} big Bigg command.\n   */\n  export function fenced(configuration: ParseOptions, open: string, mml: MmlNode,\n                         close: string, big: string = '', color: string = '') {\n    // @test Fenced, Fenced3\n    let nf = configuration.nodeFactory;\n    let mrow = nf.create('node', 'mrow', [],\n                         {open: open, close: close, texClass: TEXCLASS.INNER});\n    let mo;\n    if (big) {\n      mo = new TexParser('\\\\' + big + 'l' + open, configuration.parser.stack.env, configuration).mml();\n    } else {\n      let openNode = nf.create('text', open);\n      mo = nf.create('node', 'mo', [],\n                     {fence: true, stretchy: true, symmetric: true, texClass: TEXCLASS.OPEN},\n                     openNode);\n    }\n    NodeUtil.appendChildren(mrow, [mo, mml]);\n    if (big) {\n      mo = new TexParser('\\\\' + big + 'r' + close, configuration.parser.stack.env, configuration).mml();\n    } else {\n      let closeNode = nf.create('text', close);\n      mo = nf.create('node', 'mo', [],\n                     {fence: true, stretchy: true, symmetric: true, texClass: TEXCLASS.CLOSE},\n                     closeNode);\n    }\n    color && mo.attributes.set('mathcolor', color);\n    NodeUtil.appendChildren(mrow, [mo]);\n    return mrow;\n  }\n\n\n  /**\n   *  Create an mrow that has \\\\mathchoice using \\\\bigg and \\\\big for the delimiters.\n   * @param {ParseOptions} configuration The current parse options.\n   * @param {string} open The opening fence.\n   * @param {MmlNode} mml The enclosed node.\n   * @param {string} close The closing fence.\n   * @return {MmlNode} The mrow node.\n   */\n  export function fixedFence(configuration: ParseOptions, open: string,\n                             mml: MmlNode, close: string): MmlNode {\n    // @test Choose, Over With Delims, Above with Delims\n    let mrow = configuration.nodeFactory.create('node',\n      'mrow', [], {open: open, close: close, texClass: TEXCLASS.ORD});\n    if (open) {\n      NodeUtil.appendChildren(mrow, [mathPalette(configuration, open, 'l')]);\n    }\n    if (NodeUtil.isType(mml, 'mrow')) {\n      NodeUtil.appendChildren(mrow, NodeUtil.getChildren(mml));\n    } else {\n      NodeUtil.appendChildren(mrow, [mml]);\n    }\n    if (close) {\n      NodeUtil.appendChildren(mrow, [mathPalette(configuration, close, 'r')]);\n    }\n    return mrow;\n  }\n\n\n  /**\n   * Generates a mathchoice element for fences. These will be resolved later,\n   * once the position, and therefore size, of the of the fenced expression is\n   * known.\n   * @param {ParseOptions} configuration The current parse otpions.\n   * @param {string} fence The fence.\n   * @param {string} side The side of the fence (l or r).\n   * @return {MmlNode} The mathchoice node.\n   */\n  export function mathPalette(configuration: ParseOptions, fence: string,\n                              side: string): MmlNode  {\n    if (fence === '{' || fence === '}') {\n      fence = '\\\\' + fence;\n    }\n    let D = '{\\\\bigg' + side + ' ' + fence + '}';\n    let T = '{\\\\big' + side + ' ' + fence + '}';\n    return new TexParser('\\\\mathchoice' + D + T + T + T, {}, configuration).mml();\n  }\n\n\n  /**\n   * If the initial child, skipping any initial space or\n   * empty braces (TeXAtom with child being an empty inferred row),\n   * is an <mo>, precede it by an empty <mi> to force the <mo> to\n   * be infix.\n   * @param {ParseOptions} configuration The current parse options.\n   * @param {MmlNode[]} nodes The row of nodes to scan for an initial <mo>\n   */\n  export function fixInitialMO(configuration: ParseOptions, nodes: MmlNode[]) {\n    for (let i = 0, m = nodes.length; i < m; i++) {\n      let child = nodes[i];\n      if (child && (!NodeUtil.isType(child, 'mspace') &&\n                    (!NodeUtil.isType(child, 'TeXAtom') ||\n                     (NodeUtil.getChildren(child)[0] &&\n                      NodeUtil.getChildren(NodeUtil.getChildren(child)[0]).length)))) {\n        if (NodeUtil.isEmbellished(child) ||\n            (NodeUtil.isType(child, 'TeXAtom') && NodeUtil.getTexClass(child) === TEXCLASS.REL)) {\n          let mi = configuration.nodeFactory.create('node', 'mi');\n          nodes.unshift(mi);\n        }\n        break;\n      }\n    }\n  }\n\n\n  /**\n   * Break up a string into text and math blocks.\n   * @param {TexParser} parser The calling parser.\n   * @param {string} text The text in the math expression to parse.\n   * @param {number|string=} level The scriptlevel.\n   * @param {string} font The mathvariant to use\n   * @return {MmlNode[]} The nodes corresponding to the internal math expression.\n   */\n  export function internalMath(parser: TexParser, text: string,\n                               level?: number | string, font?: string): MmlNode[] {\n    if (parser.configuration.options.internalMath) {\n      return parser.configuration.options.internalMath(parser, text, level, font);\n    }\n    let mathvariant = font || parser.stack.env.font;\n    let def = (mathvariant ? {mathvariant} : {});\n    let mml: MmlNode[] = [], i = 0, k = 0, c, node, match = '', braces = 0;\n    if (text.match(/\\\\?[${}\\\\]|\\\\\\(|\\\\(eq)?ref\\s*\\{/)) {\n      while (i < text.length) {\n        c = text.charAt(i++);\n        if (c === '$') {\n          if (match === '$' && braces === 0) {\n            // @test Interspersed Text\n            node = parser.create(\n              'node', 'TeXAtom',\n              [(new TexParser(text.slice(k, i - 1), {}, parser.configuration)).mml()]);\n            mml.push(node);\n            match = '';\n            k = i;\n          } else if (match === '') {\n            // @test Interspersed Text\n            if (k < i - 1) {\n              // @test Interspersed Text\n              mml.push(internalText(parser, text.slice(k, i - 1), def));\n            }\n            match = '$';\n            k = i;\n          }\n        } else if (c === '{' && match !== '') {\n          // @test Mbox Mbox, Mbox Math\n          braces++;\n        } else if (c === '}') {\n          // @test Mbox Mbox, Mbox Math\n          if (match === '}' && braces === 0) {\n            // @test Mbox Eqref, Mbox Math\n            let atom = (new TexParser(text.slice(k, i), {}, parser.configuration)).mml();\n            node = parser.create('node', 'TeXAtom', [atom], def);\n            mml.push(node);\n            match = '';\n            k = i;\n          } else if (match !== '') {\n            // @test Mbox Math, Mbox Mbox\n            if (braces) {\n              // @test Mbox Math, Mbox Mbox\n              braces--;\n            }\n          }\n        } else if (c === '\\\\') {\n          // @test Mbox Eqref, Mbox CR\n          if (match === '' && text.substr(i).match(/^(eq)?ref\\s*\\{/)) {\n            // @test Mbox Eqref\n            let len = ((RegExp as any)['$&'] as string).length;\n            if (k < i - 1) {\n              // @test Mbox Eqref\n              mml.push(internalText(parser, text.slice(k, i - 1), def));\n            }\n            match = '}';\n            k = i - 1;\n            i += len;\n          } else {\n            // @test Mbox CR, Mbox Mbox\n            c = text.charAt(i++);\n            if (c === '(' && match === '') {\n              // @test Mbox Internal Display\n              if (k < i - 2) {\n                // @test Mbox Internal Display\n                mml.push(internalText(parser, text.slice(k, i - 2), def));\n              }\n              match = ')'; k = i;\n            } else if (c === ')' && match === ')' && braces === 0) {\n              // @test Mbox Internal Display\n              node = parser.create(\n                'node', 'TeXAtom',\n                [(new TexParser(text.slice(k, i - 2), {}, parser.configuration)).mml()]);\n              mml.push(node);\n              match = '';\n              k = i;\n            } else if (c.match(/[${}\\\\]/) && match === '')  {\n              // @test Mbox CR\n              i--;\n              text = text.substr(0, i - 1) + text.substr(i); // remove \\ from \\$, \\{, \\}, or \\\\\n            }\n          }\n        }\n      }\n      if (match !== '') {\n        // @test Internal Math Error\n        throw new TexError('MathNotTerminated', 'Math not terminated in text box');\n      }\n    }\n    if (k < text.length) {\n      // @test Interspersed Text, Mbox Mbox\n      mml.push(internalText(parser, text.slice(k), def));\n    }\n    if (level != null) {\n      // @test Label, Fbox, Hbox\n      mml = [parser.create('node', 'mstyle', mml, {displaystyle: false, scriptlevel: level})];\n    } else if (mml.length > 1) {\n      // @test Interspersed Text\n      mml = [parser.create('node', 'mrow', mml)];\n    }\n    return mml;\n  }\n\n\n  /**\n   * Parses text internal to boxes or labels.\n   * @param {TexParser} parser The current tex parser.\n   * @param {string} text The text to parse.\n   * @param {EnvList} def The attributes of the text node.\n   * @return {MmlNode} The text node.\n   */\n  export function internalText(parser: TexParser, text: string, def: EnvList): MmlNode {\n    // @test Label, Fbox, Hbox\n    text = text.replace(/^\\s+/, entities.nbsp).replace(/\\s+$/, entities.nbsp);\n    let textNode = parser.create('text', text);\n    return parser.create('node', 'mtext', [], def, textNode);\n  }\n\n  /**\n   * Create an munderover node with the given script position.\n   * @param {TexParser} parser   The current TeX parser.\n   * @param {MmlNode} base       The base node.\n   * @param {MmlNode} script     The under- or over-script.\n   * @param {string} pos         Either 'over' or 'under'.\n   * @param {boolean} stack      True if super- or sub-scripts should stack.\n   * @return {MmlNode}           The generated node (MmlMunderover or TeXAtom)\n   */\n  export function underOver(parser: TexParser, base: MmlNode, script: MmlNode, pos: string, stack: boolean): MmlNode {\n    // @test Overline\n    ParseUtil.checkMovableLimits(base);\n    if (NodeUtil.isType(base, 'munderover') && NodeUtil.isEmbellished(base)) {\n      // @test Overline Limits\n      NodeUtil.setProperties(NodeUtil.getCoreMO(base), {lspace: 0, rspace: 0});\n      const mo = parser.create('node', 'mo', [], {rspace: 0});\n      base = parser.create('node', 'mrow', [mo, base]);\n      // TODO? add an empty <mi> so it's not embellished any more\n    }\n    const mml = parser.create('node', 'munderover', [base]) as MmlMunderover;\n    NodeUtil.setChild(mml, pos === 'over' ?  mml.over : mml.under, script);\n    let node: MmlNode = mml;\n    if (stack) {\n      // @test Overbrace 1 2 3, Underbrace, Overbrace Op 1 2\n      node = parser.create('node', 'TeXAtom', [mml], {texClass: TEXCLASS.OP, movesupsub: true});\n    }\n    NodeUtil.setProperty(node, 'subsupOK', true);\n    return node;\n  }\n\n  /**\n   * Set movablelimits to false if necessary.\n   * @param {MmlNode} base   The base node being tested.\n   */\n  export function checkMovableLimits(base: MmlNode) {\n    const symbol = (NodeUtil.isType(base, 'mo') ? NodeUtil.getForm(base) : null);\n    if (NodeUtil.getProperty(base, 'movablelimits') || (symbol && symbol[3] && symbol[3].movablelimits)) {\n      // @test Overline Sum\n      NodeUtil.setProperties(base, {movablelimits: false});\n    }\n  }\n\n  /**\n   * Trim spaces from a string.\n   * @param {string} text The string to clean.\n   * @return {string} The string with leading and trailing whitespace removed.\n   */\n  export function trimSpaces(text: string): string {\n    if (typeof(text) !== 'string') {\n      return text;\n    }\n    let TEXT = text.trim();\n    if (TEXT.match(/\\\\$/) && text.match(/ $/)) {\n      TEXT += ' ';\n    }\n    return TEXT;\n  }\n\n\n  /**\n   * Sets alignment in array definitions.\n   * @param {ArrayItem} array The array item.\n   * @param {string} align The alignment string.\n   * @return {ArrayItem} The altered array item.\n   */\n  export function setArrayAlign(array: ArrayItem, align: string): ArrayItem {\n    // @test Array1, Array2, Array Test\n    align = ParseUtil.trimSpaces(align || '');\n    if (align === 't') {\n      array.arraydef.align = 'baseline 1';\n    } else if (align === 'b') {\n      array.arraydef.align = 'baseline -1';\n    } else if (align === 'c') {\n      array.arraydef.align = 'axis';\n    } else if (align) {\n      array.arraydef.align = align;\n    } // FIXME: should be an error?\n    return array;\n  }\n\n\n  /**\n   * Replace macro parameters with their values.\n   * @param {TexParser} parser The current TeX parser.\n   * @param {string[]} args A list of arguments for macro parameters.\n   * @param {string} str The macro parameter string.\n   * @return {string} The string with all parameters replaced by arguments.\n   */\n  export function substituteArgs(parser: TexParser, args: string[],\n                                 str: string): string {\n    let text = '';\n    let newstring = '';\n    let i = 0;\n    while (i < str.length) {\n      let c = str.charAt(i++);\n      if (c === '\\\\') {\n        text += c + str.charAt(i++);\n      }\n      else if (c === '#') {\n        c = str.charAt(i++);\n        if (c === '#') {\n          text += c;\n        } else {\n          if (!c.match(/[1-9]/) || parseInt(c, 10) > args.length) {\n            throw new TexError('IllegalMacroParam',\n                                'Illegal macro parameter reference');\n          }\n          newstring = addArgs(parser, addArgs(parser, newstring, text),\n                              args[parseInt(c, 10) - 1]);\n          text = '';\n        }\n      } else {\n        text += c;\n      }\n    }\n    return addArgs(parser, newstring, text);\n  }\n\n\n  /**\n   * Adds a new expanded argument to an already macro parameter string.  Makes\n   * sure that macros are followed by a space if their names could accidentally\n   * be continued into the following text.\n   * @param {TexParser} parser The current TeX parser.\n   * @param {string} s1 The already expanded string.\n   * @param {string} s2 The string to add.\n   * @return {string} The combined string.\n   */\n  export function addArgs(parser: TexParser, s1: string, s2: string): string {\n    if (s2.match(/^[a-z]/i) && s1.match(/(^|[^\\\\])(\\\\\\\\)*\\\\[a-z]+$/i)) {\n      s1 += ' ';\n    }\n    if (s1.length + s2.length > parser.configuration.options['maxBuffer']) {\n      throw new TexError('MaxBufferSize',\n                          'MathJax internal buffer size exceeded; is there a' +\n                          ' recursive macro call?');\n    }\n    return s1 + s2;\n  }\n\n  /**\n   * Report an error if there are too many macro substitutions.\n   * @param {TexParser} parser The current TeX parser.\n   * @param {boolean} isMacro  True if we are substituting a macro, false for environment.\n   */\n  export function checkMaxMacros(parser: TexParser, isMacro: boolean = true) {\n    if (++parser.macroCount <= parser.configuration.options['maxMacros']) {\n      return;\n    }\n    if (isMacro) {\n      throw new TexError('MaxMacroSub1',\n                         'MathJax maximum macro substitution count exceeded; ' +\n                         'is here a recursive macro call?');\n    } else {\n      throw new TexError('MaxMacroSub2',\n                         'MathJax maximum substitution count exceeded; ' +\n                         'is there a recursive latex environment?');\n    }\n  }\n\n\n  /**\n   *  Check for bad nesting of equation environments\n   */\n  export function checkEqnEnv(parser: TexParser) {\n    if (parser.stack.global.eqnenv) {\n      // @test ErroneousNestingEq\n      throw new TexError('ErroneousNestingEq', 'Erroneous nesting of equation structures');\n    }\n    parser.stack.global.eqnenv = true;\n  }\n\n  /**\n   * Copy an MmlNode and add it (and its children) to the proper lists.\n   *\n   * @param {MmlNode} node       The MmlNode to copy\n   * @param {TexParser} parser   The active tex parser\n   * @return {MmlNode}           The duplicate tree\n   */\n  export function copyNode(node: MmlNode, parser: TexParser): MmlNode  {\n    const tree = node.copy() as MmlNode;\n    const options = parser.configuration;\n    tree.walkTree((n: MmlNode) => {\n      options.addNode(n.kind, n);\n      const lists = (n.getProperty('in-lists') as string || '').split(/,/);\n      for (const list of lists) {\n        options.addNode(list, n);\n      }\n    });\n    return tree;\n  }\n\n  /**\n   * This is a placeholder for future security filtering of attributes.\n   * @param {TexParser} parser The current parser.\n   * @param {string} name The attribute name.\n   * @param {string} value The attribute value to filter.\n   * @return {string} The filtered value.\n   */\n  export function MmlFilterAttribute(_parser: TexParser, _name: string, value: string): string {\n    // TODO: Implement in security package.\n    return value;\n  }\n\n\n  /**\n   * Initialises an stack environment with current font definition in the parser.\n   * @param {TexParser} parser The current tex parser.\n   * @return {EnvList} The initialised environment list.\n   */\n  export function getFontDef(parser: TexParser): EnvList {\n    const font = parser.stack.env['font'];\n    return (font ? {mathvariant: font} : {});\n  }\n\n\n  /**\n   * Splits a package option list of the form [x=y,z=1] into an attribute list\n   * of the form {x: y, z: 1}.\n   * @param {string} attrib The attributes of the package.\n   * @param {{[key: string]: number}?} allowed A list of allowed options. If\n   *     given only allowed arguments are returned.\n   * @param {boolean?} error If true, raises an exception if not allowed options\n   *     are found.\n   * @return {EnvList} The attribute list.\n   */\n  export function keyvalOptions(attrib: string,\n                                allowed: {[key: string]: number} = null,\n                                error: boolean = false): EnvList {\n    let def: EnvList = readKeyval(attrib);\n    if (allowed) {\n      for (let key of Object.keys(def)) {\n        if (!allowed.hasOwnProperty(key)) {\n          if (error) {\n            throw new TexError('InvalidOption', 'Invalid option: %1', key);\n          }\n          delete def[key];\n        }\n      }\n    }\n    return def;\n  }\n\n\n  /**\n   * Implementation of the keyval function from https://www.ctan.org/pkg/keyval\n   * @param {string} text The optional parameter string for a package or\n   *     command.\n   * @return {EnvList} Set of options as key/value pairs.\n   */\n  function readKeyval(text: string): EnvList {\n    let options: EnvList = {};\n    let rest = text;\n    let end, key, val;\n    while (rest) {\n      [key, end, rest] = readValue(rest, ['=', ',']);\n      if (end === '=') {\n        [val, end, rest] = readValue(rest, [',']);\n        val = (val === 'false' || val === 'true') ?\n            JSON.parse(val) : val;\n        options[key] = val;\n      } else if (key) {\n        options[key] = true;\n      }\n    }\n    return options;\n  }\n\n\n  /**\n   * Removes pairs of outer braces.\n   * @param {string} text The string to clean.\n   * @param {number} count The number of outer braces to slice off.\n   * @return {string} The cleaned string.\n   */\n  function removeBraces(text: string, count: number): string {\n    while (count > 0) {\n      text = text.trim().slice(1, -1);\n      count--;\n    }\n    return text.trim();\n  }\n\n\n  /**\n   * Read a value from the given string until an end parameter is reached or\n   * string is exhausted.\n   * @param {string} text The string to process.\n   * @param {string[]} end List of possible end characters.\n   * @return {[string, string, string]} The collected value, the actual end\n   *     character, and the rest of the string still to parse.\n   */\n  function readValue(text: string, end: string[]): [string, string, string] {\n    let length = text.length;\n    let braces = 0;\n    let value = '';\n    let index = 0;\n    let start = 0;             // Counter for the starting left braces.\n    let startCount = true;     // Flag for counting starting left braces.\n    let stopCount = false;     // If true right braces are found directly\n                               // after starting braces, but no other char yet.\n    while (index < length) {\n      let c = text[index++];\n      switch (c) {\n      case ' ':                // Ignore spaces.\n        break;\n      case '{':\n        if (startCount) {      // Count start left braces at start.\n          start++;\n        } else {\n          stopCount = false;\n          if (start > braces) {   // Some start left braces have been closed.\n            start = braces;\n          }\n        }\n        braces++;\n        break;\n      case '}':\n        if (braces) {          // Closing braces.\n          braces--;\n        }\n        if (startCount || stopCount) {  // Closing braces at the start.\n          start--;\n          stopCount = true;    // Continue to close braces.\n        }\n        startCount = false;    // Stop counting start left braces.\n        break;\n      default:\n        if (!braces && end.indexOf(c) !== -1) {   // End character reached.\n          return [stopCount ? 'true' :            // If Stop count is true we\n                                                  // have balanced braces, only.\n                  removeBraces(value, start), c, text.slice(index)];\n        }\n        startCount = false;\n        stopCount = false;\n      }\n      value += c;\n    }\n    if (braces) {\n      throw new TexError('ExtraOpenMissingClose',\n                         'Extra open brace or missing close brace');\n    }\n    return [stopCount ? 'true' : removeBraces(value, start), '', text.slice(index)];\n  }\n\n}\n\nexport default ParseUtil;\n"]},"metadata":{},"sourceType":"script"}