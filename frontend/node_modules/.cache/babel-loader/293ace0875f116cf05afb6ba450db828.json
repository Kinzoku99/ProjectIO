{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar sitem = require(\"./BaseItems.js\");\n\nvar NodeUtil_js_1 = require(\"../NodeUtil.js\");\n\nvar TexError_js_1 = require(\"../TexError.js\");\n\nvar TexParser_js_1 = require(\"../TexParser.js\");\n\nvar TexConstants_js_1 = require(\"../TexConstants.js\");\n\nvar ParseUtil_js_1 = require(\"../ParseUtil.js\");\n\nvar MmlNode_js_1 = require(\"../../../core/MmlTree/MmlNode.js\");\n\nvar Tags_js_1 = require(\"../Tags.js\");\n\nvar lengths_js_1 = require(\"../../../util/lengths.js\");\n\nvar Entities_js_1 = require(\"../../../util/Entities.js\");\n\nvar Options_js_1 = require(\"../../../util/Options.js\");\n\nvar BaseMethods = {};\nvar P_HEIGHT = 1.2 / .85;\nvar MmlTokenAllow = {\n  fontfamily: 1,\n  fontsize: 1,\n  fontweight: 1,\n  fontstyle: 1,\n  color: 1,\n  background: 1,\n  id: 1,\n  'class': 1,\n  href: 1,\n  style: 1\n};\n\nBaseMethods.Open = function (parser, _c) {\n  parser.Push(parser.itemFactory.create('open'));\n};\n\nBaseMethods.Close = function (parser, _c) {\n  parser.Push(parser.itemFactory.create('close'));\n};\n\nBaseMethods.Tilde = function (parser, _c) {\n  parser.Push(parser.create('token', 'mtext', {}, Entities_js_1.entities.nbsp));\n};\n\nBaseMethods.Space = function (_parser, _c) {};\n\nBaseMethods.Superscript = function (parser, _c) {\n  var _a;\n\n  if (parser.GetNext().match(/\\d/)) {\n    parser.string = parser.string.substr(0, parser.i + 1) + ' ' + parser.string.substr(parser.i + 1);\n  }\n\n  var primes;\n  var base;\n  var top = parser.stack.Top();\n\n  if (top.isKind('prime')) {\n    _a = __read(top.Peek(2), 2), base = _a[0], primes = _a[1];\n    parser.stack.Pop();\n  } else {\n    base = parser.stack.Prev();\n\n    if (!base) {\n      base = parser.create('token', 'mi', {}, '');\n    }\n  }\n\n  var movesupsub = NodeUtil_js_1.default.getProperty(base, 'movesupsub');\n  var position = NodeUtil_js_1.default.isType(base, 'msubsup') ? base.sup : base.over;\n\n  if (NodeUtil_js_1.default.isType(base, 'msubsup') && !NodeUtil_js_1.default.isType(base, 'msup') && NodeUtil_js_1.default.getChildAt(base, base.sup) || NodeUtil_js_1.default.isType(base, 'munderover') && !NodeUtil_js_1.default.isType(base, 'mover') && NodeUtil_js_1.default.getChildAt(base, base.over) && !NodeUtil_js_1.default.getProperty(base, 'subsupOK')) {\n    throw new TexError_js_1.default('DoubleExponent', 'Double exponent: use braces to clarify');\n  }\n\n  if (!NodeUtil_js_1.default.isType(base, 'msubsup') || NodeUtil_js_1.default.isType(base, 'msup')) {\n    if (movesupsub) {\n      if (!NodeUtil_js_1.default.isType(base, 'munderover') || NodeUtil_js_1.default.isType(base, 'mover') || NodeUtil_js_1.default.getChildAt(base, base.over)) {\n        base = parser.create('node', 'munderover', [base], {\n          movesupsub: true\n        });\n      }\n\n      position = base.over;\n    } else {\n      base = parser.create('node', 'msubsup', [base]);\n      position = base.sup;\n    }\n  }\n\n  parser.Push(parser.itemFactory.create('subsup', base).setProperties({\n    position: position,\n    primes: primes,\n    movesupsub: movesupsub\n  }));\n};\n\nBaseMethods.Subscript = function (parser, _c) {\n  var _a;\n\n  if (parser.GetNext().match(/\\d/)) {\n    parser.string = parser.string.substr(0, parser.i + 1) + ' ' + parser.string.substr(parser.i + 1);\n  }\n\n  var primes, base;\n  var top = parser.stack.Top();\n\n  if (top.isKind('prime')) {\n    _a = __read(top.Peek(2), 2), base = _a[0], primes = _a[1];\n    parser.stack.Pop();\n  } else {\n    base = parser.stack.Prev();\n\n    if (!base) {\n      base = parser.create('token', 'mi', {}, '');\n    }\n  }\n\n  var movesupsub = NodeUtil_js_1.default.getProperty(base, 'movesupsub');\n  var position = NodeUtil_js_1.default.isType(base, 'msubsup') ? base.sub : base.under;\n\n  if (NodeUtil_js_1.default.isType(base, 'msubsup') && !NodeUtil_js_1.default.isType(base, 'msup') && NodeUtil_js_1.default.getChildAt(base, base.sub) || NodeUtil_js_1.default.isType(base, 'munderover') && !NodeUtil_js_1.default.isType(base, 'mover') && NodeUtil_js_1.default.getChildAt(base, base.under) && !NodeUtil_js_1.default.getProperty(base, 'subsupOK')) {\n    throw new TexError_js_1.default('DoubleSubscripts', 'Double subscripts: use braces to clarify');\n  }\n\n  if (!NodeUtil_js_1.default.isType(base, 'msubsup') || NodeUtil_js_1.default.isType(base, 'msup')) {\n    if (movesupsub) {\n      if (!NodeUtil_js_1.default.isType(base, 'munderover') || NodeUtil_js_1.default.isType(base, 'mover') || NodeUtil_js_1.default.getChildAt(base, base.under)) {\n        base = parser.create('node', 'munderover', [base], {\n          movesupsub: true\n        });\n      }\n\n      position = base.under;\n    } else {\n      base = parser.create('node', 'msubsup', [base]);\n      position = base.sub;\n    }\n  }\n\n  parser.Push(parser.itemFactory.create('subsup', base).setProperties({\n    position: position,\n    primes: primes,\n    movesupsub: movesupsub\n  }));\n};\n\nBaseMethods.Prime = function (parser, c) {\n  var base = parser.stack.Prev();\n\n  if (!base) {\n    base = parser.create('node', 'mi');\n  }\n\n  if (NodeUtil_js_1.default.isType(base, 'msubsup') && !NodeUtil_js_1.default.isType(base, 'msup') && NodeUtil_js_1.default.getChildAt(base, base.sup)) {\n    throw new TexError_js_1.default('DoubleExponentPrime', 'Prime causes double exponent: use braces to clarify');\n  }\n\n  var sup = '';\n  parser.i--;\n\n  do {\n    sup += Entities_js_1.entities.prime;\n    parser.i++, c = parser.GetNext();\n  } while (c === '\\'' || c === Entities_js_1.entities.rsquo);\n\n  sup = ['', '\\u2032', '\\u2033', '\\u2034', '\\u2057'][sup.length] || sup;\n  var node = parser.create('token', 'mo', {\n    variantForm: true\n  }, sup);\n  parser.Push(parser.itemFactory.create('prime', base, node));\n};\n\nBaseMethods.Comment = function (parser, _c) {\n  while (parser.i < parser.string.length && parser.string.charAt(parser.i) !== '\\n') {\n    parser.i++;\n  }\n};\n\nBaseMethods.Hash = function (_parser, _c) {\n  throw new TexError_js_1.default('CantUseHash1', 'You can\\'t use \\'macro parameter character #\\' in math mode');\n};\n\nBaseMethods.MathFont = function (parser, name, variant) {\n  var text = parser.GetArgument(name);\n  var mml = new TexParser_js_1.default(text, __assign(__assign({}, parser.stack.env), {\n    font: variant,\n    multiLetterIdentifiers: true\n  }), parser.configuration).mml();\n  parser.Push(parser.create('node', 'TeXAtom', [mml]));\n};\n\nBaseMethods.SetFont = function (parser, _name, font) {\n  parser.stack.env['font'] = font;\n};\n\nBaseMethods.SetStyle = function (parser, _name, texStyle, style, level) {\n  parser.stack.env['style'] = texStyle;\n  parser.stack.env['level'] = level;\n  parser.Push(parser.itemFactory.create('style').setProperty('styles', {\n    displaystyle: style,\n    scriptlevel: level\n  }));\n};\n\nBaseMethods.SetSize = function (parser, _name, size) {\n  parser.stack.env['size'] = size;\n  parser.Push(parser.itemFactory.create('style').setProperty('styles', {\n    mathsize: lengths_js_1.em(size)\n  }));\n};\n\nBaseMethods.Spacer = function (parser, _name, space) {\n  var node = parser.create('node', 'mspace', [], {\n    width: lengths_js_1.em(space)\n  });\n  var style = parser.create('node', 'mstyle', [node], {\n    scriptlevel: 0\n  });\n  parser.Push(style);\n};\n\nBaseMethods.LeftRight = function (parser, name) {\n  var first = name.substr(1);\n  parser.Push(parser.itemFactory.create(first, parser.GetDelimiter(name), parser.stack.env.color));\n};\n\nBaseMethods.NamedFn = function (parser, name, id) {\n  if (!id) {\n    id = name.substr(1);\n  }\n\n  var mml = parser.create('token', 'mi', {\n    texClass: MmlNode_js_1.TEXCLASS.OP\n  }, id);\n  parser.Push(parser.itemFactory.create('fn', mml));\n};\n\nBaseMethods.NamedOp = function (parser, name, id) {\n  if (!id) {\n    id = name.substr(1);\n  }\n\n  id = id.replace(/&thinsp;/, '\\u2006');\n  var mml = parser.create('token', 'mo', {\n    movablelimits: true,\n    movesupsub: true,\n    form: TexConstants_js_1.TexConstant.Form.PREFIX,\n    texClass: MmlNode_js_1.TEXCLASS.OP\n  }, id);\n  parser.Push(mml);\n};\n\nBaseMethods.Limits = function (parser, _name, limits) {\n  var op = parser.stack.Prev(true);\n\n  if (!op || NodeUtil_js_1.default.getTexClass(NodeUtil_js_1.default.getCoreMO(op)) !== MmlNode_js_1.TEXCLASS.OP && NodeUtil_js_1.default.getProperty(op, 'movesupsub') == null) {\n    throw new TexError_js_1.default('MisplacedLimits', '%1 is allowed only on operators', parser.currentCS);\n  }\n\n  var top = parser.stack.Top();\n  var node;\n\n  if (NodeUtil_js_1.default.isType(op, 'munderover') && !limits) {\n    node = parser.create('node', 'msubsup');\n    NodeUtil_js_1.default.copyChildren(op, node);\n    op = top.Last = node;\n  } else if (NodeUtil_js_1.default.isType(op, 'msubsup') && limits) {\n    node = parser.create('node', 'munderover');\n    NodeUtil_js_1.default.copyChildren(op, node);\n    op = top.Last = node;\n  }\n\n  NodeUtil_js_1.default.setProperty(op, 'movesupsub', limits ? true : false);\n  NodeUtil_js_1.default.setProperties(NodeUtil_js_1.default.getCoreMO(op), {\n    'movablelimits': false\n  });\n\n  if (NodeUtil_js_1.default.getAttribute(op, 'movablelimits') || NodeUtil_js_1.default.getProperty(op, 'movablelimits')) {\n    NodeUtil_js_1.default.setProperties(op, {\n      'movablelimits': false\n    });\n  }\n};\n\nBaseMethods.Over = function (parser, name, open, close) {\n  var mml = parser.itemFactory.create('over').setProperty('name', parser.currentCS);\n\n  if (open || close) {\n    mml.setProperty('open', open);\n    mml.setProperty('close', close);\n  } else if (name.match(/withdelims$/)) {\n    mml.setProperty('open', parser.GetDelimiter(name));\n    mml.setProperty('close', parser.GetDelimiter(name));\n  }\n\n  if (name.match(/^\\\\above/)) {\n    mml.setProperty('thickness', parser.GetDimen(name));\n  } else if (name.match(/^\\\\atop/) || open || close) {\n    mml.setProperty('thickness', 0);\n  }\n\n  parser.Push(mml);\n};\n\nBaseMethods.Frac = function (parser, name) {\n  var num = parser.ParseArg(name);\n  var den = parser.ParseArg(name);\n  var node = parser.create('node', 'mfrac', [num, den]);\n  parser.Push(node);\n};\n\nBaseMethods.Sqrt = function (parser, name) {\n  var n = parser.GetBrackets(name);\n  var arg = parser.GetArgument(name);\n\n  if (arg === '\\\\frac') {\n    arg += '{' + parser.GetArgument(arg) + '}{' + parser.GetArgument(arg) + '}';\n  }\n\n  var mml = new TexParser_js_1.default(arg, parser.stack.env, parser.configuration).mml();\n\n  if (!n) {\n    mml = parser.create('node', 'msqrt', [mml]);\n  } else {\n    mml = parser.create('node', 'mroot', [mml, parseRoot(parser, n)]);\n  }\n\n  parser.Push(mml);\n};\n\nfunction parseRoot(parser, n) {\n  var env = parser.stack.env;\n  var inRoot = env['inRoot'];\n  env['inRoot'] = true;\n  var newParser = new TexParser_js_1.default(n, env, parser.configuration);\n  var node = newParser.mml();\n  var global = newParser.stack.global;\n\n  if (global['leftRoot'] || global['upRoot']) {\n    var def = {};\n\n    if (global['leftRoot']) {\n      def['width'] = global['leftRoot'];\n    }\n\n    if (global['upRoot']) {\n      def['voffset'] = global['upRoot'];\n      def['height'] = global['upRoot'];\n    }\n\n    node = parser.create('node', 'mpadded', [node], def);\n  }\n\n  env['inRoot'] = inRoot;\n  return node;\n}\n\nBaseMethods.Root = function (parser, name) {\n  var n = parser.GetUpTo(name, '\\\\of');\n  var arg = parser.ParseArg(name);\n  var node = parser.create('node', 'mroot', [arg, parseRoot(parser, n)]);\n  parser.Push(node);\n};\n\nBaseMethods.MoveRoot = function (parser, name, id) {\n  if (!parser.stack.env['inRoot']) {\n    throw new TexError_js_1.default('MisplacedMoveRoot', '%1 can appear only within a root', parser.currentCS);\n  }\n\n  if (parser.stack.global[id]) {\n    throw new TexError_js_1.default('MultipleMoveRoot', 'Multiple use of %1', parser.currentCS);\n  }\n\n  var n = parser.GetArgument(name);\n\n  if (!n.match(/-?[0-9]+/)) {\n    throw new TexError_js_1.default('IntegerArg', 'The argument to %1 must be an integer', parser.currentCS);\n  }\n\n  n = parseInt(n, 10) / 15 + 'em';\n\n  if (n.substr(0, 1) !== '-') {\n    n = '+' + n;\n  }\n\n  parser.stack.global[id] = n;\n};\n\nBaseMethods.Accent = function (parser, name, accent, stretchy) {\n  var c = parser.ParseArg(name);\n\n  var def = __assign(__assign({}, ParseUtil_js_1.default.getFontDef(parser)), {\n    accent: true,\n    mathaccent: true\n  });\n\n  var entity = NodeUtil_js_1.default.createEntity(accent);\n  var moNode = parser.create('token', 'mo', def, entity);\n  var mml = moNode;\n  NodeUtil_js_1.default.setAttribute(mml, 'stretchy', stretchy ? true : false);\n  var mo = NodeUtil_js_1.default.isEmbellished(c) ? NodeUtil_js_1.default.getCoreMO(c) : c;\n\n  if (NodeUtil_js_1.default.isType(mo, 'mo')) {\n    NodeUtil_js_1.default.setProperties(mo, {\n      'movablelimits': false\n    });\n  }\n\n  var muoNode = parser.create('node', 'munderover');\n  NodeUtil_js_1.default.setChild(muoNode, 0, c);\n  NodeUtil_js_1.default.setChild(muoNode, 1, null);\n  NodeUtil_js_1.default.setChild(muoNode, 2, mml);\n  var texAtom = parser.create('node', 'TeXAtom', [muoNode]);\n  parser.Push(texAtom);\n};\n\nBaseMethods.UnderOver = function (parser, name, c, stack) {\n  var entity = NodeUtil_js_1.default.createEntity(c);\n  var mo = parser.create('token', 'mo', {\n    stretchy: true,\n    accent: true\n  }, entity);\n  var pos = name.charAt(1) === 'o' ? 'over' : 'under';\n  var base = parser.ParseArg(name);\n  parser.Push(ParseUtil_js_1.default.underOver(parser, base, mo, pos, stack));\n};\n\nBaseMethods.Overset = function (parser, name) {\n  var top = parser.ParseArg(name);\n  var base = parser.ParseArg(name);\n  ParseUtil_js_1.default.checkMovableLimits(base);\n  var node = parser.create('node', 'mover', [base, top]);\n  parser.Push(node);\n};\n\nBaseMethods.Underset = function (parser, name) {\n  var bot = parser.ParseArg(name);\n  var base = parser.ParseArg(name);\n  ParseUtil_js_1.default.checkMovableLimits(base);\n  var node = parser.create('node', 'munder', [base, bot]);\n  parser.Push(node);\n};\n\nBaseMethods.Overunderset = function (parser, name) {\n  var top = parser.ParseArg(name);\n  var bot = parser.ParseArg(name);\n  var base = parser.ParseArg(name);\n  ParseUtil_js_1.default.checkMovableLimits(base);\n  var node = parser.create('node', 'munderover', [base, bot, top]);\n  parser.Push(node);\n};\n\nBaseMethods.TeXAtom = function (parser, name, mclass) {\n  var def = {\n    texClass: mclass\n  };\n  var mml;\n  var node;\n  var parsed;\n\n  if (mclass === MmlNode_js_1.TEXCLASS.OP) {\n    def['movesupsub'] = def['movablelimits'] = true;\n    var arg = parser.GetArgument(name);\n    var match = arg.match(/^\\s*\\\\rm\\s+([a-zA-Z0-9 ]+)$/);\n\n    if (match) {\n      def['mathvariant'] = TexConstants_js_1.TexConstant.Variant.NORMAL;\n      node = parser.create('token', 'mi', def, match[1]);\n    } else {\n      parsed = new TexParser_js_1.default(arg, parser.stack.env, parser.configuration).mml();\n      node = parser.create('node', 'TeXAtom', [parsed], def);\n    }\n\n    mml = parser.itemFactory.create('fn', node);\n  } else {\n    parsed = parser.ParseArg(name);\n    mml = parser.create('node', 'TeXAtom', [parsed], def);\n  }\n\n  parser.Push(mml);\n};\n\nBaseMethods.MmlToken = function (parser, name) {\n  var kind = parser.GetArgument(name);\n  var attr = parser.GetBrackets(name, '').replace(/^\\s+/, '');\n  var text = parser.GetArgument(name);\n  var def = {};\n  var node;\n\n  try {\n    node = parser.create('node', kind);\n  } catch (e) {\n    node = null;\n  }\n\n  if (!node || !node.isToken) {\n    throw new TexError_js_1.default('NotMathMLToken', '%1 is not a token element', kind);\n  }\n\n  while (attr !== '') {\n    var match = attr.match(/^([a-z]+)\\s*=\\s*('[^']*'|\"[^\"]*\"|[^ ,]*)\\s*,?\\s*/i);\n\n    if (!match) {\n      throw new TexError_js_1.default('InvalidMathMLAttr', 'Invalid MathML attribute: %1', attr);\n    }\n\n    if (!node.attributes.hasDefault(match[1]) && !MmlTokenAllow[match[1]]) {\n      throw new TexError_js_1.default('UnknownAttrForElement', '%1 is not a recognized attribute for %2', match[1], kind);\n    }\n\n    var value = ParseUtil_js_1.default.MmlFilterAttribute(parser, match[1], match[2].replace(/^(['\"])(.*)\\1$/, '$2'));\n\n    if (value) {\n      if (value.toLowerCase() === 'true') {\n        value = true;\n      } else if (value.toLowerCase() === 'false') {\n        value = false;\n      }\n\n      def[match[1]] = value;\n    }\n\n    attr = attr.substr(match[0].length);\n  }\n\n  var textNode = parser.create('text', text);\n  node.appendChild(textNode);\n  NodeUtil_js_1.default.setProperties(node, def);\n  parser.Push(node);\n};\n\nBaseMethods.Strut = function (parser, _name) {\n  var row = parser.create('node', 'mrow');\n  var padded = parser.create('node', 'mpadded', [row], {\n    height: '8.6pt',\n    depth: '3pt',\n    width: 0\n  });\n  parser.Push(padded);\n};\n\nBaseMethods.Phantom = function (parser, name, v, h) {\n  var box = parser.create('node', 'mphantom', [parser.ParseArg(name)]);\n\n  if (v || h) {\n    box = parser.create('node', 'mpadded', [box]);\n\n    if (h) {\n      NodeUtil_js_1.default.setAttribute(box, 'height', 0);\n      NodeUtil_js_1.default.setAttribute(box, 'depth', 0);\n    }\n\n    if (v) {\n      NodeUtil_js_1.default.setAttribute(box, 'width', 0);\n    }\n  }\n\n  var atom = parser.create('node', 'TeXAtom', [box]);\n  parser.Push(atom);\n};\n\nBaseMethods.Smash = function (parser, name) {\n  var bt = ParseUtil_js_1.default.trimSpaces(parser.GetBrackets(name, ''));\n  var smash = parser.create('node', 'mpadded', [parser.ParseArg(name)]);\n\n  switch (bt) {\n    case 'b':\n      NodeUtil_js_1.default.setAttribute(smash, 'depth', 0);\n      break;\n\n    case 't':\n      NodeUtil_js_1.default.setAttribute(smash, 'height', 0);\n      break;\n\n    default:\n      NodeUtil_js_1.default.setAttribute(smash, 'height', 0);\n      NodeUtil_js_1.default.setAttribute(smash, 'depth', 0);\n  }\n\n  var atom = parser.create('node', 'TeXAtom', [smash]);\n  parser.Push(atom);\n};\n\nBaseMethods.Lap = function (parser, name) {\n  var mml = parser.create('node', 'mpadded', [parser.ParseArg(name)], {\n    width: 0\n  });\n\n  if (name === '\\\\llap') {\n    NodeUtil_js_1.default.setAttribute(mml, 'lspace', '-1width');\n  }\n\n  var atom = parser.create('node', 'TeXAtom', [mml]);\n  parser.Push(atom);\n};\n\nBaseMethods.RaiseLower = function (parser, name) {\n  var h = parser.GetDimen(name);\n  var item = parser.itemFactory.create('position').setProperties({\n    name: parser.currentCS,\n    move: 'vertical'\n  });\n\n  if (h.charAt(0) === '-') {\n    h = h.slice(1);\n    name = name.substr(1) === 'raise' ? '\\\\lower' : '\\\\raise';\n  }\n\n  if (name === '\\\\lower') {\n    item.setProperty('dh', '-' + h);\n    item.setProperty('dd', '+' + h);\n  } else {\n    item.setProperty('dh', '+' + h);\n    item.setProperty('dd', '-' + h);\n  }\n\n  parser.Push(item);\n};\n\nBaseMethods.MoveLeftRight = function (parser, name) {\n  var h = parser.GetDimen(name);\n  var nh = h.charAt(0) === '-' ? h.slice(1) : '-' + h;\n\n  if (name === '\\\\moveleft') {\n    var tmp = h;\n    h = nh;\n    nh = tmp;\n  }\n\n  parser.Push(parser.itemFactory.create('position').setProperties({\n    name: parser.currentCS,\n    move: 'horizontal',\n    left: parser.create('node', 'mspace', [], {\n      width: h\n    }),\n    right: parser.create('node', 'mspace', [], {\n      width: nh\n    })\n  }));\n};\n\nBaseMethods.Hskip = function (parser, name) {\n  var node = parser.create('node', 'mspace', [], {\n    width: parser.GetDimen(name)\n  });\n  parser.Push(node);\n};\n\nBaseMethods.Nonscript = function (parser, _name) {\n  parser.Push(parser.itemFactory.create('nonscript'));\n};\n\nBaseMethods.Rule = function (parser, name, style) {\n  var w = parser.GetDimen(name),\n      h = parser.GetDimen(name),\n      d = parser.GetDimen(name);\n  var def = {\n    width: w,\n    height: h,\n    depth: d\n  };\n\n  if (style !== 'blank') {\n    def['mathbackground'] = parser.stack.env['color'] || 'black';\n  }\n\n  var node = parser.create('node', 'mspace', [], def);\n  parser.Push(node);\n};\n\nBaseMethods.rule = function (parser, name) {\n  var v = parser.GetBrackets(name),\n      w = parser.GetDimen(name),\n      h = parser.GetDimen(name);\n  var mml = parser.create('node', 'mspace', [], {\n    width: w,\n    height: h,\n    mathbackground: parser.stack.env['color'] || 'black'\n  });\n\n  if (v) {\n    mml = parser.create('node', 'mpadded', [mml], {\n      voffset: v\n    });\n\n    if (v.match(/^\\-/)) {\n      NodeUtil_js_1.default.setAttribute(mml, 'height', v);\n      NodeUtil_js_1.default.setAttribute(mml, 'depth', '+' + v.substr(1));\n    } else {\n      NodeUtil_js_1.default.setAttribute(mml, 'height', '+' + v);\n    }\n  }\n\n  parser.Push(mml);\n};\n\nBaseMethods.MakeBig = function (parser, name, mclass, size) {\n  size *= P_HEIGHT;\n  var sizeStr = String(size).replace(/(\\.\\d\\d\\d).+/, '$1') + 'em';\n  var delim = parser.GetDelimiter(name, true);\n  var mo = parser.create('token', 'mo', {\n    minsize: sizeStr,\n    maxsize: sizeStr,\n    fence: true,\n    stretchy: true,\n    symmetric: true\n  }, delim);\n  var node = parser.create('node', 'TeXAtom', [mo], {\n    texClass: mclass\n  });\n  parser.Push(node);\n};\n\nBaseMethods.BuildRel = function (parser, name) {\n  var top = parser.ParseUpTo(name, '\\\\over');\n  var bot = parser.ParseArg(name);\n  var node = parser.create('node', 'munderover');\n  NodeUtil_js_1.default.setChild(node, 0, bot);\n  NodeUtil_js_1.default.setChild(node, 1, null);\n  NodeUtil_js_1.default.setChild(node, 2, top);\n  var atom = parser.create('node', 'TeXAtom', [node], {\n    texClass: MmlNode_js_1.TEXCLASS.REL\n  });\n  parser.Push(atom);\n};\n\nBaseMethods.HBox = function (parser, name, style, font) {\n  parser.PushAll(ParseUtil_js_1.default.internalMath(parser, parser.GetArgument(name), style, font));\n};\n\nBaseMethods.FBox = function (parser, name) {\n  var internal = ParseUtil_js_1.default.internalMath(parser, parser.GetArgument(name));\n  var node = parser.create('node', 'menclose', internal, {\n    notation: 'box'\n  });\n  parser.Push(node);\n};\n\nBaseMethods.FrameBox = function (parser, name) {\n  var width = parser.GetBrackets(name);\n  var pos = parser.GetBrackets(name) || 'c';\n  var mml = ParseUtil_js_1.default.internalMath(parser, parser.GetArgument(name));\n\n  if (width) {\n    mml = [parser.create('node', 'mpadded', mml, {\n      width: width,\n      'data-align': Options_js_1.lookup(pos, {\n        l: 'left',\n        r: 'right'\n      }, 'center')\n    })];\n  }\n\n  var node = parser.create('node', 'TeXAtom', [parser.create('node', 'menclose', mml, {\n    notation: 'box'\n  })], {\n    texClass: MmlNode_js_1.TEXCLASS.ORD\n  });\n  parser.Push(node);\n};\n\nBaseMethods.Not = function (parser, _name) {\n  parser.Push(parser.itemFactory.create('not'));\n};\n\nBaseMethods.Dots = function (parser, _name) {\n  var ldotsEntity = NodeUtil_js_1.default.createEntity('2026');\n  var cdotsEntity = NodeUtil_js_1.default.createEntity('22EF');\n  var ldots = parser.create('token', 'mo', {\n    stretchy: false\n  }, ldotsEntity);\n  var cdots = parser.create('token', 'mo', {\n    stretchy: false\n  }, cdotsEntity);\n  parser.Push(parser.itemFactory.create('dots').setProperties({\n    ldots: ldots,\n    cdots: cdots\n  }));\n};\n\nBaseMethods.Matrix = function (parser, _name, open, close, align, spacing, vspacing, style, cases, numbered) {\n  var c = parser.GetNext();\n\n  if (c === '') {\n    throw new TexError_js_1.default('MissingArgFor', 'Missing argument for %1', parser.currentCS);\n  }\n\n  if (c === '{') {\n    parser.i++;\n  } else {\n    parser.string = c + '}' + parser.string.slice(parser.i + 1);\n    parser.i = 0;\n  }\n\n  var array = parser.itemFactory.create('array').setProperty('requireClose', true);\n  array.arraydef = {\n    rowspacing: vspacing || '4pt',\n    columnspacing: spacing || '1em'\n  };\n\n  if (cases) {\n    array.setProperty('isCases', true);\n  }\n\n  if (numbered) {\n    array.setProperty('isNumbered', true);\n    array.arraydef.side = numbered;\n  }\n\n  if (open || close) {\n    array.setProperty('open', open);\n    array.setProperty('close', close);\n  }\n\n  if (style === 'D') {\n    array.arraydef.displaystyle = true;\n  }\n\n  if (align != null) {\n    array.arraydef.columnalign = align;\n  }\n\n  parser.Push(array);\n};\n\nBaseMethods.Entry = function (parser, name) {\n  parser.Push(parser.itemFactory.create('cell').setProperties({\n    isEntry: true,\n    name: name\n  }));\n  var top = parser.stack.Top();\n  var env = top.getProperty('casesEnv');\n  var cases = top.getProperty('isCases');\n  if (!cases && !env) return;\n  var str = parser.string;\n  var braces = 0,\n      close = -1,\n      i = parser.i,\n      m = str.length;\n  var end = env ? new RegExp(\"^\\\\\\\\end\\\\s*\\\\{\" + env.replace(/\\*/, '\\\\*') + \"\\\\}\") : null;\n\n  while (i < m) {\n    var c = str.charAt(i);\n\n    if (c === '{') {\n      braces++;\n      i++;\n    } else if (c === '}') {\n      if (braces === 0) {\n        m = 0;\n      } else {\n        braces--;\n\n        if (braces === 0 && close < 0) {\n          close = i - parser.i;\n        }\n\n        i++;\n      }\n    } else if (c === '&' && braces === 0) {\n      throw new TexError_js_1.default('ExtraAlignTab', 'Extra alignment tab in \\\\cases text');\n    } else if (c === '\\\\') {\n      var rest = str.substr(i);\n\n      if (rest.match(/^((\\\\cr)[^a-zA-Z]|\\\\\\\\)/) || end && rest.match(end)) {\n        m = 0;\n      } else {\n        i += 2;\n      }\n    } else {\n      i++;\n    }\n  }\n\n  var text = str.substr(parser.i, i - parser.i);\n\n  if (!text.match(/^\\s*\\\\text[^a-zA-Z]/) || close !== text.replace(/\\s+$/, '').length - 1) {\n    var internal = ParseUtil_js_1.default.internalMath(parser, ParseUtil_js_1.default.trimSpaces(text), 0);\n    parser.PushAll(internal);\n    parser.i = i;\n  }\n};\n\nBaseMethods.Cr = function (parser, name) {\n  parser.Push(parser.itemFactory.create('cell').setProperties({\n    isCR: true,\n    name: name\n  }));\n};\n\nBaseMethods.CrLaTeX = function (parser, name, nobrackets) {\n  if (nobrackets === void 0) {\n    nobrackets = false;\n  }\n\n  var n;\n\n  if (!nobrackets) {\n    if (parser.string.charAt(parser.i) === '*') {\n      parser.i++;\n    }\n\n    if (parser.string.charAt(parser.i) === '[') {\n      var dim = parser.GetBrackets(name, '');\n\n      var _a = __read(ParseUtil_js_1.default.matchDimen(dim), 2),\n          value = _a[0],\n          unit = _a[1];\n\n      if (dim && !value) {\n        throw new TexError_js_1.default('BracketMustBeDimension', 'Bracket argument to %1 must be a dimension', parser.currentCS);\n      }\n\n      n = value + unit;\n    }\n  }\n\n  parser.Push(parser.itemFactory.create('cell').setProperties({\n    isCR: true,\n    name: name,\n    linebreak: true\n  }));\n  var top = parser.stack.Top();\n  var node;\n\n  if (top instanceof sitem.ArrayItem) {\n    if (n) {\n      top.addRowSpacing(n);\n    }\n  } else {\n    if (n) {\n      node = parser.create('node', 'mspace', [], {\n        depth: n\n      });\n      parser.Push(node);\n    }\n\n    node = parser.create('node', 'mspace', [], {\n      linebreak: TexConstants_js_1.TexConstant.LineBreak.NEWLINE\n    });\n    parser.Push(node);\n  }\n};\n\nBaseMethods.HLine = function (parser, _name, style) {\n  if (style == null) {\n    style = 'solid';\n  }\n\n  var top = parser.stack.Top();\n\n  if (!(top instanceof sitem.ArrayItem) || top.Size()) {\n    throw new TexError_js_1.default('Misplaced', 'Misplaced %1', parser.currentCS);\n  }\n\n  if (!top.table.length) {\n    top.frame.push('top');\n  } else {\n    var lines = top.arraydef['rowlines'] ? top.arraydef['rowlines'].split(/ /) : [];\n\n    while (lines.length < top.table.length) {\n      lines.push('none');\n    }\n\n    lines[top.table.length - 1] = style;\n    top.arraydef['rowlines'] = lines.join(' ');\n  }\n};\n\nBaseMethods.HFill = function (parser, _name) {\n  var top = parser.stack.Top();\n\n  if (top instanceof sitem.ArrayItem) {\n    top.hfill.push(top.Size());\n  } else {\n    throw new TexError_js_1.default('UnsupportedHFill', 'Unsupported use of %1', parser.currentCS);\n  }\n};\n\nBaseMethods.BeginEnd = function (parser, name) {\n  var env = parser.GetArgument(name);\n\n  if (env.match(/\\\\/i)) {\n    throw new TexError_js_1.default('InvalidEnv', 'Invalid environment name \\'%1\\'', env);\n  }\n\n  var macro = parser.configuration.handlers.get('environment').lookup(env);\n\n  if (macro && name === '\\\\end') {\n    if (!macro.args[0]) {\n      var mml = parser.itemFactory.create('end').setProperty('name', env);\n      parser.Push(mml);\n      return;\n    }\n\n    parser.stack.env['closing'] = env;\n  }\n\n  ParseUtil_js_1.default.checkMaxMacros(parser, false);\n  parser.parse('environment', [parser, env]);\n};\n\nBaseMethods.Array = function (parser, begin, open, close, align, spacing, vspacing, style, raggedHeight) {\n  if (!align) {\n    align = parser.GetArgument('\\\\begin{' + begin.getName() + '}');\n  }\n\n  var lines = ('c' + align).replace(/[^clr|:]/g, '').replace(/[^|:]([|:])+/g, '$1');\n  align = align.replace(/[^clr]/g, '').split('').join(' ');\n  align = align.replace(/l/g, 'left').replace(/r/g, 'right').replace(/c/g, 'center');\n  var array = parser.itemFactory.create('array');\n  array.arraydef = {\n    columnalign: align,\n    columnspacing: spacing || '1em',\n    rowspacing: vspacing || '4pt'\n  };\n\n  if (lines.match(/[|:]/)) {\n    if (lines.charAt(0).match(/[|:]/)) {\n      array.frame.push('left');\n      array.dashed = lines.charAt(0) === ':';\n    }\n\n    if (lines.charAt(lines.length - 1).match(/[|:]/)) {\n      array.frame.push('right');\n    }\n\n    lines = lines.substr(1, lines.length - 2);\n    array.arraydef.columnlines = lines.split('').join(' ').replace(/[^|: ]/g, 'none').replace(/\\|/g, 'solid').replace(/:/g, 'dashed');\n  }\n\n  if (open) {\n    array.setProperty('open', parser.convertDelimiter(open));\n  }\n\n  if (close) {\n    array.setProperty('close', parser.convertDelimiter(close));\n  }\n\n  if ((style || '').charAt(1) === '\\'') {\n    array.arraydef['data-cramped'] = true;\n    style = style.charAt(0);\n  }\n\n  if (style === 'D') {\n    array.arraydef['displaystyle'] = true;\n  } else if (style) {\n    array.arraydef['displaystyle'] = false;\n  }\n\n  if (style === 'S') {\n    array.arraydef['scriptlevel'] = 1;\n  }\n\n  if (raggedHeight) {\n    array.arraydef['useHeight'] = false;\n  }\n\n  parser.Push(begin);\n  return array;\n};\n\nBaseMethods.AlignedArray = function (parser, begin) {\n  var align = parser.GetBrackets('\\\\begin{' + begin.getName() + '}');\n  var item = BaseMethods.Array(parser, begin);\n  return ParseUtil_js_1.default.setArrayAlign(item, align);\n};\n\nBaseMethods.Equation = function (parser, begin, numbered) {\n  parser.Push(begin);\n  ParseUtil_js_1.default.checkEqnEnv(parser);\n  return parser.itemFactory.create('equation', numbered).setProperty('name', begin.getName());\n};\n\nBaseMethods.EqnArray = function (parser, begin, numbered, taggable, align, spacing) {\n  parser.Push(begin);\n\n  if (taggable) {\n    ParseUtil_js_1.default.checkEqnEnv(parser);\n  }\n\n  align = align.replace(/[^clr]/g, '').split('').join(' ');\n  align = align.replace(/l/g, 'left').replace(/r/g, 'right').replace(/c/g, 'center');\n  var newItem = parser.itemFactory.create('eqnarray', begin.getName(), numbered, taggable, parser.stack.global);\n  newItem.arraydef = {\n    displaystyle: true,\n    columnalign: align,\n    columnspacing: spacing || '1em',\n    rowspacing: '3pt',\n    side: parser.options['tagSide'],\n    minlabelspacing: parser.options['tagIndent']\n  };\n  return newItem;\n};\n\nBaseMethods.HandleNoTag = function (parser, _name) {\n  parser.tags.notag();\n};\n\nBaseMethods.HandleLabel = function (parser, name) {\n  var label = parser.GetArgument(name);\n\n  if (label === '') {\n    return;\n  }\n\n  if (!parser.tags.refUpdate) {\n    if (parser.tags.label) {\n      throw new TexError_js_1.default('MultipleCommand', 'Multiple %1', parser.currentCS);\n    }\n\n    parser.tags.label = label;\n\n    if ((parser.tags.allLabels[label] || parser.tags.labels[label]) && !parser.options['ignoreDuplicateLabels']) {\n      throw new TexError_js_1.default('MultipleLabel', 'Label \\'%1\\' multiply defined', label);\n    }\n\n    parser.tags.labels[label] = new Tags_js_1.Label();\n  }\n};\n\nBaseMethods.HandleRef = function (parser, name, eqref) {\n  var label = parser.GetArgument(name);\n  var ref = parser.tags.allLabels[label] || parser.tags.labels[label];\n\n  if (!ref) {\n    if (!parser.tags.refUpdate) {\n      parser.tags.redo = true;\n    }\n\n    ref = new Tags_js_1.Label();\n  }\n\n  var tag = ref.tag;\n\n  if (eqref) {\n    tag = parser.tags.formatTag(tag);\n  }\n\n  var node = parser.create('node', 'mrow', ParseUtil_js_1.default.internalMath(parser, tag), {\n    href: parser.tags.formatUrl(ref.id, parser.options.baseURL),\n    'class': 'MathJax_ref'\n  });\n  parser.Push(node);\n};\n\nBaseMethods.Macro = function (parser, name, macro, argcount, def) {\n  if (argcount) {\n    var args = [];\n\n    if (def != null) {\n      var optional = parser.GetBrackets(name);\n      args.push(optional == null ? def : optional);\n    }\n\n    for (var i = args.length; i < argcount; i++) {\n      args.push(parser.GetArgument(name));\n    }\n\n    macro = ParseUtil_js_1.default.substituteArgs(parser, args, macro);\n  }\n\n  parser.string = ParseUtil_js_1.default.addArgs(parser, macro, parser.string.slice(parser.i));\n  parser.i = 0;\n  ParseUtil_js_1.default.checkMaxMacros(parser);\n};\n\nBaseMethods.MathChoice = function (parser, name) {\n  var D = parser.ParseArg(name);\n  var T = parser.ParseArg(name);\n  var S = parser.ParseArg(name);\n  var SS = parser.ParseArg(name);\n  parser.Push(parser.create('node', 'MathChoice', [D, T, S, SS]));\n};\n\nexports.default = BaseMethods;","map":{"version":3,"mappings":"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","names":["BaseMethods","P_HEIGHT","MmlTokenAllow","fontfamily","fontsize","fontweight","fontstyle","color","background","id","href","style","Open","parser","_c","Push","itemFactory","create","Close","Tilde","Entities_js_1","nbsp","Space","_parser","Superscript","GetNext","match","string","substr","i","primes","base","top","stack","Top","isKind","_a","Peek","Pop","Prev","movesupsub","NodeUtil_js_1","getProperty","position","isType","sup","over","getChildAt","TexError_js_1","setProperties","Subscript","sub","under","Prime","c","prime","rsquo","length","node","variantForm","Comment","charAt","Hash","MathFont","name","variant","text","GetArgument","mml","TexParser_js_1","__assign","env","font","multiLetterIdentifiers","configuration","SetFont","_name","SetStyle","texStyle","level","setProperty","displaystyle","scriptlevel","SetSize","size","mathsize","lengths_js_1","Spacer","space","width","LeftRight","first","GetDelimiter","NamedFn","texClass","MmlNode_js_1","OP","NamedOp","replace","movablelimits","form","TexConstants_js_1","Form","PREFIX","Limits","limits","op","getTexClass","getCoreMO","currentCS","copyChildren","Last","getAttribute","Over","open","close","GetDimen","Frac","num","ParseArg","den","Sqrt","n","GetBrackets","arg","parseRoot","inRoot","newParser","global","def","Root","GetUpTo","MoveRoot","parseInt","Accent","accent","stretchy","ParseUtil_js_1","getFontDef","mathaccent","entity","createEntity","moNode","setAttribute","mo","isEmbellished","muoNode","setChild","texAtom","UnderOver","pos","underOver","Overset","checkMovableLimits","Underset","bot","Overunderset","TeXAtom","mclass","parsed","Variant","NORMAL","MmlToken","kind","attr","e","isToken","attributes","hasDefault","value","MmlFilterAttribute","toLowerCase","textNode","appendChild","Strut","row","padded","height","depth","Phantom","v","h","box","atom","Smash","bt","trimSpaces","smash","Lap","RaiseLower","item","move","slice","MoveLeftRight","nh","tmp","left","right","Hskip","Nonscript","Rule","w","d","rule","mathbackground","voffset","MakeBig","sizeStr","String","delim","minsize","maxsize","fence","symmetric","BuildRel","ParseUpTo","REL","HBox","PushAll","internalMath","FBox","internal","notation","FrameBox","Options_js_1","l","r","ORD","Not","Dots","ldotsEntity","cdotsEntity","ldots","cdots","Matrix","align","spacing","vspacing","cases","numbered","array","arraydef","rowspacing","columnspacing","side","columnalign","Entry","isEntry","str","braces","m","end","RegExp","rest","Cr","isCR","CrLaTeX","nobrackets","dim","matchDimen","unit","linebreak","sitem","ArrayItem","addRowSpacing","LineBreak","NEWLINE","HLine","Size","table","frame","push","lines","split","join","HFill","hfill","BeginEnd","macro","handlers","get","lookup","args","checkMaxMacros","parse","Array","begin","raggedHeight","getName","dashed","columnlines","convertDelimiter","AlignedArray","setArrayAlign","Equation","checkEqnEnv","EqnArray","taggable","newItem","options","minlabelspacing","HandleNoTag","tags","notag","HandleLabel","label","refUpdate","allLabels","labels","Tags_js_1","HandleRef","eqref","ref","redo","tag","formatTag","formatUrl","baseURL","Macro","argcount","optional","substituteArgs","addArgs","MathChoice","D","T","S","SS","exports"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/input/tex/base/BaseMethods.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview The Basic Parse methods.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport * as sitem from './BaseItems.js';\nimport {StackItem, EnvList} from '../StackItem.js';\nimport {Macro} from '../Symbol.js';\nimport {ParseMethod} from '../Types.js';\nimport NodeUtil from '../NodeUtil.js';\nimport TexError from '../TexError.js';\nimport TexParser from '../TexParser.js';\nimport {TexConstant} from '../TexConstants.js';\nimport ParseUtil from '../ParseUtil.js';\nimport {MmlNode, TEXCLASS} from '../../../core/MmlTree/MmlNode.js';\nimport {MmlMsubsup} from '../../../core/MmlTree/MmlNodes/msubsup.js';\nimport {MmlMunderover} from '../../../core/MmlTree/MmlNodes/munderover.js';\nimport {Label} from '../Tags.js';\nimport {em} from '../../../util/lengths.js';\nimport {entities} from '../../../util/Entities.js';\nimport {lookup} from '../../../util/Options.js';\n\n\n// Namespace\nlet BaseMethods: Record<string, ParseMethod> = {};\n\nconst P_HEIGHT = 1.2 / .85;   // cmex10 height plus depth over .85\nconst MmlTokenAllow: {[key: string]: number} = {\n  fontfamily: 1, fontsize: 1, fontweight: 1, fontstyle: 1,\n  color: 1, background: 1,\n  id: 1, 'class': 1, href: 1, style: 1\n};\n\n\n\n/**\n * Handle LaTeX tokens.\n */\n\n/**\n * Handle {\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Open = function(parser: TexParser, _c: string) {\n  // @test Identifier Font, Prime, Prime with subscript\n  parser.Push(parser.itemFactory.create('open'));\n};\n\n/**\n * Handle }\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Close = function(parser: TexParser, _c: string) {\n  // @test Identifier Font, Prime, Prime with subscript\n  parser.Push(parser.itemFactory.create('close'));\n};\n\n\n/**\n * Handle tilde and spaces.\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Tilde = function(parser: TexParser, _c: string) {\n  // @test Tilde, Tilde2\n  parser.Push(parser.create('token', 'mtext', {}, entities.nbsp));\n};\n\n/**\n * Handling space, by doing nothing.\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Space = function(_parser: TexParser, _c: string) {};\n\n/**\n * Handle ^\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Superscript = function(parser: TexParser, _c: string) {\n  if (parser.GetNext().match(/\\d/)) {\n    // don't treat numbers as a unit\n    parser.string = parser.string.substr(0, parser.i + 1) +\n      ' ' + parser.string.substr(parser.i + 1);\n  }\n  let primes: MmlNode;\n  let base: MmlNode | void;\n  const top = parser.stack.Top();\n  if (top.isKind('prime')) {\n    // @test Prime on Prime\n    [base, primes] = top.Peek(2);\n    parser.stack.Pop();\n  } else {\n    // @test Empty base2, Square, Cube\n    base = parser.stack.Prev();\n    if (!base) {\n      // @test Empty base\n      base = parser.create('token', 'mi', {}, '');\n    }\n  }\n  const movesupsub = NodeUtil.getProperty(base, 'movesupsub');\n  let position = NodeUtil.isType(base, 'msubsup') ? (base as MmlMsubsup).sup :\n    (base as MmlMunderover).over;\n  if ((NodeUtil.isType(base, 'msubsup') && !NodeUtil.isType(base, 'msup') &&\n       NodeUtil.getChildAt(base, (base as MmlMsubsup).sup)) ||\n      (NodeUtil.isType(base, 'munderover') && !NodeUtil.isType(base, 'mover') &&\n       NodeUtil.getChildAt(base, (base as MmlMunderover).over) &&\n       !NodeUtil.getProperty(base, 'subsupOK'))) {\n    // @test Double-super-error, Double-over-error\n    throw new TexError('DoubleExponent', 'Double exponent: use braces to clarify');\n  }\n  if (!NodeUtil.isType(base, 'msubsup') || NodeUtil.isType(base, 'msup')) {\n    if (movesupsub) {\n      // @test Move Superscript, Large Operator\n      if (!NodeUtil.isType(base, 'munderover') || NodeUtil.isType(base, 'mover') ||\n          NodeUtil.getChildAt(base, (base as MmlMunderover).over)) {\n        // @test Large Operator\n        base = parser.create('node', 'munderover', [base], {movesupsub: true});\n      }\n      position = (base as MmlMunderover).over;\n    } else {\n      // @test Empty base, Empty base2, Square, Cube\n      base = parser.create('node', 'msubsup', [base]);\n      position = (base as MmlMsubsup).sup;\n    }\n  }\n  parser.Push(\n    parser.itemFactory.create('subsup', base).setProperties({\n      position: position, primes: primes, movesupsub: movesupsub\n    }) );\n};\n\n\n/**\n * Handle _\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Subscript = function(parser: TexParser, _c: string) {\n  if (parser.GetNext().match(/\\d/)) {\n    // don't treat numbers as a unit\n    parser.string =\n      parser.string.substr(0, parser.i + 1) + ' ' +\n      parser.string.substr(parser.i + 1);\n  }\n  let primes, base;\n  const top = parser.stack.Top();\n  if (top.isKind('prime')) {\n    // @test Prime on Sub\n    [base, primes] = top.Peek(2);\n    parser.stack.Pop();\n  } else {\n    base = parser.stack.Prev();\n    if (!base) {\n      // @test Empty Base Index\n      base = parser.create('token', 'mi', {}, '');\n    }\n  }\n  const movesupsub = NodeUtil.getProperty(base, 'movesupsub');\n  let position = NodeUtil.isType(base, 'msubsup') ?\n    (base as MmlMsubsup).sub : (base as MmlMunderover).under;\n  if ((NodeUtil.isType(base, 'msubsup') && !NodeUtil.isType(base, 'msup') &&\n       NodeUtil.getChildAt(base, (base as MmlMsubsup).sub)) ||\n      (NodeUtil.isType(base, 'munderover') && !NodeUtil.isType(base, 'mover') &&\n       NodeUtil.getChildAt(base, (base as MmlMunderover).under) &&\n       !NodeUtil.getProperty(base, 'subsupOK'))) {\n    // @test Double-sub-error, Double-under-error\n    throw new TexError('DoubleSubscripts', 'Double subscripts: use braces to clarify');\n  }\n  if (!NodeUtil.isType(base, 'msubsup') || NodeUtil.isType(base, 'msup')) {\n    if (movesupsub) {\n      // @test Large Operator, Move Superscript\n      if (!NodeUtil.isType(base, 'munderover') || NodeUtil.isType(base, 'mover') ||\n          NodeUtil.getChildAt(base, (base as MmlMunderover).under)) {\n        // @test Move Superscript\n        base = parser.create('node', 'munderover', [base], {movesupsub: true});\n      }\n      position = (base as MmlMunderover).under;\n    } else {\n      // @test Empty Base Index, Empty Base Index2, Index\n      base = parser.create('node', 'msubsup', [base]);\n      position = (base as MmlMsubsup).sub;\n    }\n  }\n  parser.Push(\n    parser.itemFactory.create('subsup', base).setProperties({\n      position: position, primes: primes, movesupsub: movesupsub\n    }) );\n};\n\n\n/**\n * Handle '\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Prime = function(parser: TexParser, c: string) {\n  // @test Prime\n  let base = parser.stack.Prev();\n  if (!base) {\n    // @test PrimeSup, PrePrime, Prime on Sup\n    base = parser.create('node', 'mi');\n  }\n  if (NodeUtil.isType(base, 'msubsup') && !NodeUtil.isType(base, 'msup') &&\n      NodeUtil.getChildAt(base, (base as MmlMsubsup).sup)) {\n    // @test Double Prime Error\n    throw new TexError('DoubleExponentPrime',\n                        'Prime causes double exponent: use braces to clarify');\n  }\n  let sup = '';\n  parser.i--;\n  do {\n    // @test Prime, PrimeSup, Double Prime, PrePrime\n    sup += entities.prime; parser.i++, c = parser.GetNext();\n  } while (c === '\\'' || c === entities.rsquo);\n  sup = ['', '\\u2032', '\\u2033', '\\u2034', '\\u2057'][sup.length] || sup;\n  const node = parser.create('token', 'mo', {variantForm: true}, sup);\n  parser.Push(\n    parser.itemFactory.create('prime', base, node) );\n};\n\n\n/**\n * Handle comments\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Comment = function(parser: TexParser, _c: string) {\n  while (parser.i < parser.string.length && parser.string.charAt(parser.i) !== '\\n') {\n    parser.i++;\n  }\n};\n\n\n/**\n * Handle hash marks outside of definitions\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Hash = function(_parser: TexParser, _c: string) {\n  // @test Hash Error\n  throw new TexError('CantUseHash1',\n                      'You can\\'t use \\'macro parameter character #\\' in math mode');\n};\n\n\n\n/**\n *\n * Handle LaTeX Macros\n *\n */\n\n\n/**\n * Handle \\mathrm, \\mathbf, etc, allowing for multi-letter runs to be one <mi>.\n */\nBaseMethods.MathFont = function(parser: TexParser, name: string, variant: string) {\n  const text = parser.GetArgument(name);\n  let mml = new TexParser(text, {\n    ...parser.stack.env,\n    font: variant,\n    multiLetterIdentifiers: true\n  }, parser.configuration).mml();\n  parser.Push(parser.create('node', 'TeXAtom', [mml]));\n};\n\n/**\n * Setting font, e.g., via \\\\rm, \\\\bf etc.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} font The font name.\n */\nBaseMethods.SetFont = function(parser: TexParser, _name: string, font: string) {\n  parser.stack.env['font'] = font;\n};\n\n/**\n * Setting style, e.g., via \\\\displaystyle, \\\\textstyle, etc.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} texStyle The tex style name: D, T, S, SS\n * @param {boolean} style True if we are in displaystyle.\n * @param {string} level The nesting level for scripts.\n */\nBaseMethods.SetStyle = function(parser: TexParser, _name: string,\n                                texStyle: string, style: boolean,\n                                level: string) {\n  parser.stack.env['style'] = texStyle;\n  parser.stack.env['level'] = level;\n  parser.Push(\n    parser.itemFactory.create('style').setProperty(\n      'styles', {displaystyle: style, scriptlevel: level}));\n};\n\n\n/**\n * Setting size of an expression, e.g., \\\\small, \\\\huge.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {number} size The size value.\n */\nBaseMethods.SetSize = function(parser: TexParser, _name: string, size: number) {\n  parser.stack.env['size'] = size;\n  parser.Push(\n    parser.itemFactory.create('style').setProperty('styles', {mathsize: em(size)}));\n};\n\n/**\n * Setting explicit spaces, e.g., via commata or colons.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} space The space value.\n */\nBaseMethods.Spacer = function(parser: TexParser, _name: string, space: number) {\n  // @test Positive Spacing, Negative Spacing\n  const node = parser.create('node', 'mspace', [], {width: em(space)});\n  const style = parser.create('node', 'mstyle', [node], {scriptlevel: 0});\n  parser.Push(style);\n};\n\n\n/**\n * Parses left/right fenced expressions.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.LeftRight = function(parser: TexParser, name: string) {\n  // @test Fenced, Fenced3\n  const first = name.substr(1);\n  parser.Push(parser.itemFactory.create(first, parser.GetDelimiter(name), parser.stack.env.color));\n};\n\n/**\n * Handle a named math function, e.g., \\\\sin, \\\\cos\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} id Alternative string representation of the function.\n */\nBaseMethods.NamedFn = function(parser: TexParser, name: string, id: string) {\n  // @test Named Function\n  if (!id) {\n    id = name.substr(1);\n  }\n  const mml = parser.create('token', 'mi', {texClass: TEXCLASS.OP}, id);\n  parser.Push(parser.itemFactory.create('fn', mml));\n};\n\n\n/**\n * Handle a named math operator, e.g., \\\\min, \\\\lim\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} id Alternative string representation of the operator.\n */\nBaseMethods.NamedOp = function(parser: TexParser, name: string, id: string) {\n  // @test Limit\n  if (!id) {\n    id = name.substr(1);\n  }\n  id = id.replace(/&thinsp;/, '\\u2006');\n  const mml = parser.create('token', 'mo', {\n    movablelimits: true,\n    movesupsub: true,\n    form: TexConstant.Form.PREFIX,\n    texClass: TEXCLASS.OP\n  }, id);\n  parser.Push(mml);\n};\n\n/**\n * Handle a limits command for math operators.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} limits The limits arguments.\n */\nBaseMethods.Limits = function(parser: TexParser, _name: string, limits: string) {\n  // @test Limits\n  let op = parser.stack.Prev(true);\n  // Get the texclass for the core operator.\n  if (!op || (NodeUtil.getTexClass(NodeUtil.getCoreMO(op)) !== TEXCLASS.OP &&\n              NodeUtil.getProperty(op, 'movesupsub') == null)) {\n    // @test Limits Error\n    throw new TexError('MisplacedLimits', '%1 is allowed only on operators', parser.currentCS);\n  }\n  const top = parser.stack.Top();\n  let node;\n  if (NodeUtil.isType(op, 'munderover') && !limits) {\n    // @test Limits UnderOver\n    node = parser.create('node', 'msubsup');\n    NodeUtil.copyChildren(op, node);\n    op = top.Last = node;\n  } else if (NodeUtil.isType(op, 'msubsup') && limits) {\n    // @test Limits SubSup\n    // node = parser.create('node', 'munderover', NodeUtil.getChildren(op), {});\n    // Needs to be copied, otherwise we get an error in MmlNode.appendChild!\n    node = parser.create('node', 'munderover');\n    NodeUtil.copyChildren(op, node);\n    op = top.Last = node;\n  }\n  NodeUtil.setProperty(op, 'movesupsub', limits ? true : false);\n  NodeUtil.setProperties(NodeUtil.getCoreMO(op), {'movablelimits': false});\n  if (NodeUtil.getAttribute(op, 'movablelimits') ||\n      NodeUtil.getProperty(op, 'movablelimits')) {\n    NodeUtil.setProperties(op, {'movablelimits': false});\n  }\n};\n\n\n/**\n * Handle over commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} open The open delimiter in case of a \"withdelim\" version.\n * @param {string} close The close delimiter.\n */\nBaseMethods.Over = function(parser: TexParser, name: string, open: string, close: string) {\n  // @test Over\n  const mml = parser.itemFactory.create('over').setProperty('name', parser.currentCS) ;\n  if (open || close) {\n    // @test Choose\n    mml.setProperty('open', open);\n    mml.setProperty('close', close);\n  } else if (name.match(/withdelims$/)) {\n    // @test Over With Delims, Above With Delims\n    mml.setProperty('open', parser.GetDelimiter(name));\n    mml.setProperty('close', parser.GetDelimiter(name));\n  }\n  if (name.match(/^\\\\above/)) {\n    // @test Above, Above With Delims\n    mml.setProperty('thickness', parser.GetDimen(name));\n  }\n  else if (name.match(/^\\\\atop/) || open || close) {\n    // @test Choose\n    mml.setProperty('thickness', 0);\n  }\n  parser.Push(mml);\n};\n\n/**\n * Parses a fraction.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Frac = function(parser: TexParser, name: string) {\n  // @test Frac\n  const num = parser.ParseArg(name);\n  const den = parser.ParseArg(name);\n  const node = parser.create('node', 'mfrac', [num, den]);\n  parser.Push(node);\n};\n\n/**\n * Parses a square root element.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Sqrt = function(parser: TexParser, name: string) {\n  const n = parser.GetBrackets(name);\n  let arg = parser.GetArgument(name);\n  if (arg === '\\\\frac') {\n    arg  += '{' + parser.GetArgument(arg) + '}{' + parser.GetArgument(arg) + '}';\n  }\n  let mml = new TexParser(arg, parser.stack.env, parser.configuration).mml();\n  if (!n) {\n    // @test Square Root\n    mml = parser.create('node', 'msqrt', [mml]);\n  } else {\n    // @test General Root\n    mml = parser.create('node', 'mroot', [mml, parseRoot(parser, n)]);\n  }\n  parser.Push(mml);\n};\n\n\n// Utility\n/**\n * Parse a general root.\n * @param {TexParser} parser The calling parser.\n * @param {string} n The index of the root.\n */\nfunction parseRoot(parser: TexParser, n: string) {\n  // @test General Root, Explicit Root\n  const env = parser.stack.env;\n  const inRoot = env['inRoot'];\n  env['inRoot'] = true;\n  const newParser = new TexParser(n, env, parser.configuration);\n  let node = newParser.mml();\n  const global = newParser.stack.global;\n  if (global['leftRoot'] || global['upRoot']) {\n    // @test Tweaked Root\n    const def: EnvList = {};\n    if (global['leftRoot']) {\n      def['width'] = global['leftRoot'];\n    }\n    if (global['upRoot']) {\n      def['voffset'] = global['upRoot'];\n      def['height'] = global['upRoot'];\n    }\n    node = parser.create('node', 'mpadded', [node], def);\n  }\n  env['inRoot'] = inRoot;\n  return node;\n}\n\n\n/**\n * Parse a general root.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Root = function(parser: TexParser, name: string) {\n  const n = parser.GetUpTo(name, '\\\\of');\n  const arg = parser.ParseArg(name);\n  const node = parser.create('node', 'mroot', [arg, parseRoot(parser, n)]);\n  parser.Push(node);\n};\n\n\n/**\n * Parses a movable index element in a root, e.g. \\\\uproot, \\\\leftroot\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} id Argument which should be a string representation of an integer.\n */\nBaseMethods.MoveRoot = function(parser: TexParser, name: string, id: string) {\n  // @test Tweaked Root\n  if (!parser.stack.env['inRoot']) {\n    // @test Misplaced Move Root\n    throw new TexError('MisplacedMoveRoot', '%1 can appear only within a root', parser.currentCS);\n  }\n  if (parser.stack.global[id]) {\n    // @test Multiple Move Root\n    throw new TexError('MultipleMoveRoot', 'Multiple use of %1', parser.currentCS);\n  }\n  let n = parser.GetArgument(name);\n  if (!n.match(/-?[0-9]+/)) {\n    // @test Incorrect Move Root\n    throw new TexError('IntegerArg', 'The argument to %1 must be an integer', parser.currentCS);\n  }\n  n = (parseInt(n, 10) / 15) + 'em';\n  if (n.substr(0, 1) !== '-') {\n    n = '+' + n;\n  }\n  parser.stack.global[id] = n;\n};\n\n\n/**\n * Handle accents.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} accent The accent.\n * @param {boolean} stretchy True if accent is stretchy.\n */\nBaseMethods.Accent = function(parser: TexParser, name: string, accent: string, stretchy: boolean) {\n  // @test Vector\n  const c = parser.ParseArg(name);\n  // @test Vector Font\n  const def = {...ParseUtil.getFontDef(parser), accent: true, mathaccent: true};\n  const entity = NodeUtil.createEntity(accent);\n  const moNode = parser.create('token', 'mo', def, entity);\n  const mml = moNode;\n  NodeUtil.setAttribute(mml, 'stretchy', stretchy ? true : false);\n  // @test Vector Op, Vector\n  const mo = (NodeUtil.isEmbellished(c) ? NodeUtil.getCoreMO(c) : c);\n  if (NodeUtil.isType(mo, 'mo')) {\n    // @test Vector Op\n    NodeUtil.setProperties(mo, {'movablelimits': false});\n  }\n  const muoNode = parser.create('node', 'munderover');\n  // This is necessary to get the empty element into the children.\n  NodeUtil.setChild(muoNode, 0, c);\n  NodeUtil.setChild(muoNode, 1, null);\n  NodeUtil.setChild(muoNode, 2, mml);\n  let texAtom = parser.create('node', 'TeXAtom', [muoNode]);\n  parser.Push(texAtom);\n};\n\n\n/**\n * Handles stacked elements.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} c Character to stack.\n * @param {boolean} stack True if stacked operator.\n */\nBaseMethods.UnderOver = function(parser: TexParser, name: string, c: string, stack: boolean) {\n  const entity = NodeUtil.createEntity(c);\n  const mo = parser.create('token', 'mo', {stretchy: true, accent: true}, entity);\n  const pos = (name.charAt(1) === 'o' ? 'over' : 'under');\n  const base = parser.ParseArg(name);\n  parser.Push(ParseUtil.underOver(parser, base, mo, pos, stack));\n};\n\n\n/**\n * Handles overset.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Overset = function(parser: TexParser, name: string) {\n  // @test Overset\n  const top = parser.ParseArg(name);\n  const base = parser.ParseArg(name);\n  ParseUtil.checkMovableLimits(base);\n  const node = parser.create('node', 'mover', [base, top]);\n  parser.Push(node);\n};\n\n\n/**\n * Handles underset.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Underset = function(parser: TexParser, name: string) {\n  // @test Underset\n  const bot = parser.ParseArg(name);\n  const base = parser.ParseArg(name);\n  ParseUtil.checkMovableLimits(base);\n  const node = parser.create('node', 'munder', [base, bot]);\n  parser.Push(node);\n};\n\n\n/**\n * Handles overunderset.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Overunderset = function(parser: TexParser, name: string) {\n  const top = parser.ParseArg(name);\n  const bot = parser.ParseArg(name);\n  const base = parser.ParseArg(name);\n  ParseUtil.checkMovableLimits(base);\n  const node = parser.create('node', 'munderover', [base, bot, top]);\n  parser.Push(node);\n};\n\n\n/**\n * Creates TeXAtom, when class of element is changed explicitly.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {number} mclass The new TeX class.\n */\nBaseMethods.TeXAtom = function(parser: TexParser, name: string, mclass: number) {\n  let def: EnvList = {texClass: mclass};\n  let mml: StackItem | MmlNode;\n  let node: MmlNode;\n  let parsed: MmlNode;\n  if (mclass === TEXCLASS.OP) {\n    def['movesupsub'] = def['movablelimits'] = true;\n    const arg = parser.GetArgument(name);\n    const match = arg.match(/^\\s*\\\\rm\\s+([a-zA-Z0-9 ]+)$/);\n    if (match) {\n      // @test Mathop\n      def['mathvariant'] = TexConstant.Variant.NORMAL;\n      node = parser.create('token', 'mi', def, match[1]);\n    } else {\n      // @test Mathop Cal\n      parsed = new TexParser(arg, parser.stack.env, parser.configuration).mml();\n      node = parser.create('node', 'TeXAtom', [parsed], def);\n    }\n    mml = parser.itemFactory.create('fn', node);\n  } else {\n    // @test Mathrel\n    parsed = parser.ParseArg(name);\n    mml = parser.create('node', 'TeXAtom', [parsed], def);\n  }\n  parser.Push(mml);\n};\n\n\n/**\n * Creates mmltoken elements. Used in Macro substitutions.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.MmlToken = function(parser: TexParser, name: string) {\n  // @test Modulo\n  const kind = parser.GetArgument(name);\n  let attr = parser.GetBrackets(name, '').replace(/^\\s+/, '');\n  const text = parser.GetArgument(name);\n  const def: EnvList = {};\n  let node: MmlNode;\n  try {\n    node = parser.create('node', kind);\n  } catch (e) {\n    node = null;\n  }\n  if (!node || !node.isToken) {\n    // @test Token Illegal Type, Token Wrong Type\n    throw new TexError('NotMathMLToken', '%1 is not a token element', kind);\n  }\n  while (attr !== '') {\n    const match = attr.match(/^([a-z]+)\\s*=\\s*('[^']*'|\"[^\"]*\"|[^ ,]*)\\s*,?\\s*/i);\n    if (!match) {\n      // @test Token Invalid Attribute\n      throw new TexError('InvalidMathMLAttr', 'Invalid MathML attribute: %1', attr);\n    }\n    if (!node.attributes.hasDefault(match[1]) && !MmlTokenAllow[match[1]]) {\n      // @test Token Unknown Attribute, Token Wrong Attribute\n      throw new TexError('UnknownAttrForElement',\n                          '%1 is not a recognized attribute for %2',\n                          match[1], kind);\n    }\n    let value: string | boolean = ParseUtil.MmlFilterAttribute(\n      parser, match[1], match[2].replace(/^(['\"])(.*)\\1$/, '$2'));\n    if (value) {\n      if (value.toLowerCase() === 'true') {\n        value = true;\n      }\n      else if (value.toLowerCase() === 'false') {\n        value = false;\n      }\n      def[match[1]] = value;\n    }\n    attr = attr.substr(match[0].length);\n  }\n  const textNode = parser.create('text', text);\n  node.appendChild(textNode);\n  NodeUtil.setProperties(node, def);\n  parser.Push(node);\n};\n\n\n/**\n * Handle strut.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Strut = function(parser: TexParser, _name: string) {\n  // @test Strut\n  const row = parser.create('node', 'mrow');\n  const padded = parser.create('node', 'mpadded', [row],\n                                                         {height: '8.6pt', depth: '3pt', width: 0});\n  parser.Push(padded);\n};\n\n/**\n * Handle phantom commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} v Vertical size.\n * @param {string} h Horizontal size.\n */\nBaseMethods.Phantom = function(parser: TexParser, name: string, v: string, h: string) {\n  // @test Phantom\n  let box = parser.create('node', 'mphantom', [parser.ParseArg(name)]);\n  if (v || h) {\n    // TEMP: Changes here\n    box = parser.create('node', 'mpadded', [box]);\n    if (h) {\n      // @test Horizontal Phantom\n      NodeUtil.setAttribute(box, 'height', 0);\n      NodeUtil.setAttribute(box, 'depth', 0);\n    }\n    if (v) {\n      // @test Vertical Phantom\n      NodeUtil.setAttribute(box, 'width', 0);\n    }\n  }\n  const atom = parser.create('node', 'TeXAtom', [box]);\n  parser.Push(atom);\n};\n\n/**\n * Handle smash.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Smash = function(parser: TexParser, name: string) {\n  // @test Smash, Smash Top, Smash Bottom\n  const bt = ParseUtil.trimSpaces(parser.GetBrackets(name, ''));\n  const smash = parser.create('node', 'mpadded', [parser.ParseArg(name)]);\n  // TEMP: Changes here:\n  switch (bt) {\n  case 'b': NodeUtil.setAttribute(smash, 'depth', 0); break;\n  case 't': NodeUtil.setAttribute(smash, 'height', 0); break;\n  default:\n    NodeUtil.setAttribute(smash, 'height', 0);\n    NodeUtil.setAttribute(smash, 'depth', 0);\n  }\n  const atom = parser.create('node', 'TeXAtom', [smash]);\n  parser.Push(atom);\n};\n\n/**\n * Handle rlap and llap commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Lap = function(parser: TexParser, name: string) {\n  // @test Llap, Rlap\n  const mml = parser.create('node', 'mpadded', [parser.ParseArg(name)], {width: 0});\n  if (name === '\\\\llap') {\n    // @test Llap\n    NodeUtil.setAttribute(mml, 'lspace', '-1width');\n  }\n  const atom = parser.create('node', 'TeXAtom', [mml]);\n  parser.Push(atom);\n};\n\n/**\n * Handle raise and lower commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.RaiseLower = function(parser: TexParser, name: string) {\n  // @test Raise, Lower, Raise Negative, Lower Negative\n  let h = parser.GetDimen(name);\n  let item =\n    parser.itemFactory.create('position').setProperties({name: parser.currentCS, move: 'vertical'}) ;\n  // TEMP: Changes here:\n  if (h.charAt(0) === '-') {\n    // @test Raise Negative, Lower Negative\n    h = h.slice(1);\n    name = name.substr(1) === 'raise' ? '\\\\lower' : '\\\\raise';\n  }\n  if (name === '\\\\lower') {\n    // @test Raise, Raise Negative\n    item.setProperty('dh', '-' + h);\n    item.setProperty('dd', '+' + h);\n  } else {\n    // @test Lower, Lower Negative\n    item.setProperty('dh', '+' + h);\n    item.setProperty('dd', '-' + h);\n  }\n  parser.Push(item);\n};\n\n\n/**\n * Handle moveleft, moveright commands\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.MoveLeftRight = function(parser: TexParser, name: string) {\n  // @test Move Left, Move Right, Move Left Negative, Move Right Negative\n  let h = parser.GetDimen(name);\n  let nh = (h.charAt(0) === '-' ? h.slice(1) : '-' + h);\n  if (name === '\\\\moveleft') {\n    let tmp = h;\n    h = nh;\n    nh = tmp;\n  }\n  parser.Push(\n    parser.itemFactory.create('position').setProperties({\n      name: parser.currentCS, move: 'horizontal',\n      left:  parser.create('node', 'mspace', [], {width: h}),\n      right: parser.create('node', 'mspace', [], {width: nh})}) );\n};\n\n\n/**\n * Handle horizontal spacing commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Hskip = function(parser: TexParser, name: string) {\n  // @test Modulo\n  const node = parser.create('node', 'mspace', [],\n                             {width: parser.GetDimen(name)});\n  parser.Push(node);\n};\n\n\n/**\n * Handle removal of spaces in script modes\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Nonscript = function(parser: TexParser, _name: string) {\n  parser.Push(parser.itemFactory.create('nonscript'));\n};\n\n\n/**\n * Handle Rule and Space command\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} style The style of the rule spacer.\n */\nBaseMethods.Rule = function(parser: TexParser, name: string, style: string) {\n  // @test Rule 3D, Space 3D\n  const w = parser.GetDimen(name),\n  h = parser.GetDimen(name),\n  d = parser.GetDimen(name);\n  let def: EnvList = {width: w, height: h, depth: d};\n  if (style !== 'blank') {\n    def['mathbackground'] = (parser.stack.env['color'] || 'black');\n  }\n  const node = parser.create('node', 'mspace', [], def);\n  parser.Push(node);\n};\n\n\n/**\n * Handle rule command.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.rule = function(parser: TexParser, name: string) {\n  // @test Rule 2D\n  const v = parser.GetBrackets(name),\n  w = parser.GetDimen(name),\n  h = parser.GetDimen(name);\n  let mml = parser.create('node', 'mspace', [], {\n    width: w, height: h,\n    mathbackground: (parser.stack.env['color'] || 'black') });\n  if (v) {\n    mml = parser.create('node', 'mpadded', [mml], {voffset: v});\n    if (v.match(/^\\-/)) {\n      NodeUtil.setAttribute(mml, 'height', v);\n      NodeUtil.setAttribute(mml, 'depth', '+' + v.substr(1));\n    } else {\n      NodeUtil.setAttribute(mml, 'height', '+' + v);\n    }\n  }\n  parser.Push(mml);\n};\n\n/**\n * Handle big command sequences, e.g., \\\\big, \\\\Bigg.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {number} mclass The TeX class of the element.\n * @param {number} size The em size.\n */\nBaseMethods.MakeBig = function(parser: TexParser, name: string, mclass: number, size: number) {\n  // @test Choose, Over With Delims, Above With Delims\n  size *= P_HEIGHT;\n  let sizeStr = String(size).replace(/(\\.\\d\\d\\d).+/, '$1') + 'em';\n  const delim = parser.GetDelimiter(name, true);\n  const mo = parser.create('token', 'mo', {\n    minsize: sizeStr, maxsize: sizeStr,\n    fence: true, stretchy: true, symmetric: true\n  }, delim);\n  const node = parser.create('node', 'TeXAtom', [mo], {texClass: mclass});\n  parser.Push(node);\n};\n\n\n/**\n * Handle buildrel command.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.BuildRel = function(parser: TexParser, name: string) {\n  // @test BuildRel, BuildRel Expression\n  const top = parser.ParseUpTo(name, '\\\\over');\n  const bot = parser.ParseArg(name);\n  const node = parser.create('node', 'munderover');\n  // This is necessary to get the empty element into the children.\n  NodeUtil.setChild(node, 0, bot);\n  NodeUtil.setChild(node, 1, null);\n  NodeUtil.setChild(node, 2, top);\n  const atom = parser.create('node', 'TeXAtom', [node], {texClass: TEXCLASS.REL});\n  parser.Push(atom);\n};\n\n\n/**\n * Handle horizontal boxes.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} style Box style.\n * @param {string} font The mathvariant to use\n */\nBaseMethods.HBox = function(parser: TexParser, name: string, style: string, font?: string) {\n  // @test Hbox\n  parser.PushAll(ParseUtil.internalMath(parser, parser.GetArgument(name), style, font));\n};\n\n/**\n * Handle framed boxes.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.FBox = function(parser: TexParser, name: string) {\n  // @test Fbox\n  const internal = ParseUtil.internalMath(parser, parser.GetArgument(name));\n  const node = parser.create('node', 'menclose', internal, {notation: 'box'});\n  parser.Push(node);\n};\n\n/**\n * Handle framed boxes with options.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.FrameBox = function(parser: TexParser, name: string) {\n  const width = parser.GetBrackets(name);\n  const pos = parser.GetBrackets(name) || 'c';\n  let mml = ParseUtil.internalMath(parser, parser.GetArgument(name));\n  if (width) {\n    mml = [parser.create('node', 'mpadded', mml, {\n      width,\n      'data-align': lookup(pos, {l: 'left', r: 'right'}, 'center')\n    })];\n  }\n  const node = parser.create('node', 'TeXAtom',\n                             [parser.create('node', 'menclose', mml, {notation: 'box'})],\n                             {texClass: TEXCLASS.ORD});\n  parser.Push(node);\n};\n\n\n/**\n * Handle \\\\not.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Not = function(parser: TexParser, _name: string) {\n  // @test Negation Simple, Negation Complex, Negation Explicit,\n  //       Negation Large\n  parser.Push(parser.itemFactory.create('not'));\n};\n\n\n/**\n * Handle dots.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Dots = function(parser: TexParser, _name: string) {\n  // @test Operator Dots\n  const ldotsEntity = NodeUtil.createEntity('2026');\n  const cdotsEntity = NodeUtil.createEntity('22EF');\n  const ldots = parser.create('token', 'mo', {stretchy: false}, ldotsEntity);\n  const cdots = parser.create('token', 'mo', {stretchy: false}, cdotsEntity);\n  parser.Push(\n    parser.itemFactory.create('dots').setProperties({\n      ldots: ldots,\n      cdots: cdots\n    }) );\n};\n\n\n/**\n * Handle small matrix environments.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} open Opening fence.\n * @param {string} close Closing fence.\n * @param {string} align Column alignment.\n * @param {string} spacing Column spacing.\n * @param {string} vspacing Row spacing.\n * @param {string} style Display or text style.\n * @param {boolean} cases Is it a cases environment.\n * @param {boolean} numbered Is it a numbered environment.\n */\nBaseMethods.Matrix = function(parser: TexParser, _name: string,\n                              open: string, close: string, align: string,\n                              spacing: string, vspacing: string, style: string,\n                              cases: boolean, numbered: boolean) {\n  const c = parser.GetNext();\n  if (c === '') {\n    // @test Matrix Error\n    throw new TexError('MissingArgFor', 'Missing argument for %1', parser.currentCS);\n  }\n  if (c === '{') {\n    // @test Matrix Braces, Matrix Columns, Matrix Rows.\n    parser.i++;\n  } else {\n    // @test Matrix Arg\n    parser.string = c + '}' + parser.string.slice(parser.i + 1);\n    parser.i = 0;\n  }\n  // @test Matrix Braces, Matrix Columns, Matrix Rows.\n  const array = parser.itemFactory.create('array').setProperty('requireClose', true) as sitem.ArrayItem;\n  array.arraydef = {\n    rowspacing: (vspacing || '4pt'),\n    columnspacing: (spacing || '1em')\n  };\n  if (cases) {\n    // @test Matrix Cases\n    array.setProperty('isCases', true);\n  }\n  if (numbered) {\n    // @test Matrix Numbered\n    array.setProperty('isNumbered', true);\n    array.arraydef.side = numbered;\n  }\n  if (open || close) {\n    // @test Matrix Parens, Matrix Parens Subscript, Matrix Cases\n    array.setProperty('open', open);\n    array.setProperty('close', close);\n  }\n  if (style === 'D') {\n    // @test Matrix Numbered\n    array.arraydef.displaystyle = true;\n  }\n  if (align != null) {\n    // @test Matrix Cases, Matrix Numbered\n    array.arraydef.columnalign = align;\n  }\n  parser.Push(array);\n};\n\n\n/**\n * Handle array entry.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Entry = function(parser: TexParser, name: string) {\n  // @test Label, Array, Cross Product Formula\n  parser.Push(parser.itemFactory.create('cell').setProperties({isEntry: true, name: name}));\n  const top = parser.stack.Top();\n  const env = top.getProperty('casesEnv') as string;\n  const cases = top.getProperty('isCases');\n  if (!cases && !env) return;\n  //\n  //  Make second column be in \\text{...} (unless it is already\n  //  in a \\text{...}, for backward compatibility).\n  //\n  const str = parser.string;\n  let braces = 0, close = -1, i = parser.i, m = str.length;\n  const end = (env ? new RegExp(`^\\\\\\\\end\\\\s*\\\\{${env.replace(/\\*/, '\\\\*')}\\\\}`) : null);\n  //\n  //  Look through the string character by character...\n  //\n  while (i < m) {\n    const c = str.charAt(i);\n    if (c === '{') {\n      //\n      //  Increase the nested brace count and go on\n      //\n      braces++;\n      i++;\n    } else if (c === '}') {\n      //\n      //  If there are too many close braces, just end (we will get an\n      //    error message later when the rest of the string is parsed)\n      //  Otherwise\n      //    decrease the nested brace count,\n      //    if it is now zero and we haven't already marked the end of the\n      //      first brace group, record the position (use to check for \\text{} later)\n      //    go on to the next character.\n      //\n      if (braces === 0) {\n        m = 0;\n      } else {\n        braces--;\n        if (braces === 0 && close < 0) {\n          close = i - parser.i;\n        }\n        i++;\n      }\n    } else if (c === '&' && braces === 0) {\n      //\n      //  Extra alignment tabs are not allowed in cases\n      //\n      // @test ExtraAlignTab\n      throw new TexError('ExtraAlignTab', 'Extra alignment tab in \\\\cases text');\n    } else if (c === '\\\\') {\n      //\n      //  If the macro is \\cr or \\\\, end the search, otherwise skip the macro\n      //  (multi-letter names don't matter, as we will skip the rest of the\n      //   characters in the main loop)\n      //\n      const rest = str.substr(i);\n      if (rest.match(/^((\\\\cr)[^a-zA-Z]|\\\\\\\\)/) || (end && rest.match(end))) {\n        m = 0;\n      } else {\n        i += 2;\n      }\n    } else {\n      //\n      //  Go on to the next character\n      //\n      i++;\n    }\n  }\n  //\n  //  Check if the second column text is already in \\text{};\n  //  If not, process the second column as text and continue parsing from there,\n  //    (otherwise process the second column as normal, since it is in \\text{}\n  //\n  const text = str.substr(parser.i, i - parser.i);\n  if (!text.match(/^\\s*\\\\text[^a-zA-Z]/) || close !== text.replace(/\\s+$/, '').length - 1) {\n    const internal = ParseUtil.internalMath(parser, ParseUtil.trimSpaces(text), 0);\n    parser.PushAll(internal);\n    parser.i = i;\n  }\n};\n\n/**\n * Handle newline in array.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Cr = function(parser: TexParser, name: string) {\n  // @test Cr Linebreak, Misplaced Cr\n  parser.Push(\n    parser.itemFactory.create('cell').setProperties({isCR: true, name: name}));\n};\n\n\n/**\n * Handle newline outside array.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {boolean} nobrackets Flag indicating if newline is followed by\n *     brackets.\n */\nBaseMethods.CrLaTeX = function(parser: TexParser, name: string, nobrackets: boolean = false) {\n  let n: string;\n  if (!nobrackets) {\n    // TODO: spaces before * and [ are not allowed in AMS environments like align, but\n    //       should be allowed in array and eqnarray.  This distinction should be honored here.\n    if (parser.string.charAt(parser.i) === '*') {  // The * controls page breaking, so ignore it\n      parser.i++;\n    }\n    if (parser.string.charAt(parser.i) === '[') {\n      let dim = parser.GetBrackets(name, '');\n      let [value, unit, ] = ParseUtil.matchDimen(dim);\n      // @test Custom Linebreak\n      if (dim && !value) {\n        // @test Dimension Error\n        throw new TexError('BracketMustBeDimension',\n                           'Bracket argument to %1 must be a dimension', parser.currentCS);\n      }\n      n = value + unit;\n    }\n  }\n  parser.Push(\n    parser.itemFactory.create('cell').setProperties({isCR: true, name: name, linebreak: true})\n  );\n  const top = parser.stack.Top();\n  let node: MmlNode;\n  if (top instanceof sitem.ArrayItem) {\n    // @test Array\n    if (n) {\n      top.addRowSpacing(n);\n    }\n  } else {\n    if (n) {\n      // @test Custom Linebreak\n      node = parser.create('node', 'mspace', [], {depth: n});\n      parser.Push(node);\n    }\n    // @test Linebreak\n    node = parser.create('node', 'mspace', [], {linebreak: TexConstant.LineBreak.NEWLINE});\n    parser.Push(node);\n  }\n};\n\n/**\n * Handle horizontal lines in arrays.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} style Style of the line. E.g., dashed.\n */\nBaseMethods.HLine = function(parser: TexParser, _name: string, style: string) {\n  if (style == null) {\n    style = 'solid';\n  }\n  const top = parser.stack.Top();\n  if (!(top instanceof sitem.ArrayItem) || top.Size()) {\n    // @test Misplaced hline\n    throw new TexError('Misplaced', 'Misplaced %1', parser.currentCS);\n  }\n  if (!top.table.length) {\n    // @test Enclosed top, Enclosed top bottom\n    top.frame.push('top');\n  } else {\n    // @test Enclosed bottom, Enclosed top bottom\n    const lines = (top.arraydef['rowlines'] ? (top.arraydef['rowlines'] as string).split(/ /) : []);\n    while (lines.length < top.table.length) {\n      lines.push('none');\n    }\n    lines[top.table.length - 1] = style;\n    top.arraydef['rowlines'] = lines.join(' ');\n  }\n};\n\n\n/**\n * Handle hfill commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.HFill = function(parser: TexParser, _name: string) {\n  const top = parser.stack.Top();\n  if (top instanceof sitem.ArrayItem) {\n    // @test Hfill\n    top.hfill.push(top.Size());\n  } else {\n    // @test UnsupportedHFill\n    throw new TexError('UnsupportedHFill', 'Unsupported use of %1', parser.currentCS);\n  }\n};\n\n\n/**\n *   LaTeX environments\n */\n\n/**\n * Handle begin and end environments. This is a macro method.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.BeginEnd = function(parser: TexParser, name: string) {\n  // @test Array1, Array2, Array Test\n  let env = parser.GetArgument(name);\n  if (env.match(/\\\\/i)) {\n    // @test InvalidEnv\n    throw new TexError('InvalidEnv', 'Invalid environment name \\'%1\\'', env);\n  }\n  let macro = parser.configuration.handlers.get('environment').lookup(env) as Macro;\n  if (macro && name === '\\\\end') {\n    // If the first argument is true, we have some sort of user defined\n    // environment. Otherwise we have a standard LaTeX environment that is\n    // handled with begin and end items.\n    if (!macro.args[0]) {\n      const mml = parser.itemFactory.create('end').setProperty('name', env);\n      parser.Push(mml);\n      return;\n    }\n    // Remember the user defined environment we are closing.\n    parser.stack.env['closing'] = env;\n  }\n  ParseUtil.checkMaxMacros(parser, false);\n  parser.parse('environment', [parser, env]);\n};\n\n\n/**\n * Handle array environment.\n * @param {TexParser} parser The calling parser.\n * @param {StackItem} begin The opening stackitem.\n * @param {string} open Opening fence.\n * @param {string} close Closing fence.\n * @param {string} align Column alignment.\n * @param {string} spacing Column spacing.\n * @param {string} vspacing Row spacing.\n * @param {string} style Display or text style.\n * @param {boolean} raggedHeight Does the height need to be adjusted?\n */\nBaseMethods.Array = function(parser: TexParser, begin: StackItem,\n                             open: string, close: string, align: string,\n                             spacing: string, vspacing: string, style: string,\n                             raggedHeight: boolean) {\n  if (!align) {\n    // @test Array Single\n    align = parser.GetArgument('\\\\begin{' + begin.getName() + '}');\n  }\n  let lines = ('c' + align).replace(/[^clr|:]/g, '').replace(/[^|:]([|:])+/g, '$1');\n  align = align.replace(/[^clr]/g, '').split('').join(' ');\n  align = align.replace(/l/g, 'left').replace(/r/g, 'right').replace(/c/g, 'center');\n  const array = parser.itemFactory.create('array') as sitem.ArrayItem;\n  array.arraydef = {\n    columnalign: align,\n    columnspacing: (spacing || '1em'),\n    rowspacing: (vspacing || '4pt')\n  };\n  if (lines.match(/[|:]/)) {\n    // @test Enclosed left right\n    if (lines.charAt(0).match(/[|:]/)) {\n      // @test Enclosed left right, Enclosed left\n      array.frame.push('left');\n      array.dashed = lines.charAt(0) === ':';\n    }\n    if (lines.charAt(lines.length - 1).match(/[|:]/)) {\n      // @test Enclosed left right, Enclosed right\n      array.frame.push('right');\n    }\n    // @test Enclosed left right\n    lines = lines.substr(1, lines.length - 2);\n    array.arraydef.columnlines =\n      lines.split('').join(' ').replace(/[^|: ]/g, 'none').replace(/\\|/g, 'solid').replace(/:/g, 'dashed');\n  }\n  if (open)  {\n    // @test Cross Product\n    array.setProperty('open', parser.convertDelimiter(open));\n  }\n  if (close) {\n    // @test Cross Product\n    array.setProperty('close', parser.convertDelimiter(close));\n  }\n  if ((style || '').charAt(1) === '\\'') {\n    array.arraydef['data-cramped'] = true;\n    style = style.charAt(0);\n  }\n  if (style === 'D') {\n    // TODO: This case never seems to occur! No test.\n    array.arraydef['displaystyle'] = true;\n  }\n  else if (style) {\n    // @test Subarray, Small Matrix\n    array.arraydef['displaystyle'] = false;\n  }\n  if (style === 'S') {\n    // @test Subarray, Small Matrix\n    array.arraydef['scriptlevel'] = 1;\n  }\n  if (raggedHeight)  {\n    // @test Subarray, Small Matrix\n    array.arraydef['useHeight'] = false;\n  }\n  parser.Push(begin);\n  return array;\n};\n\n\n/**\n * Handle aligned arrays.\n * @param {TexParser} parser The calling parser.\n * @param {StackItem} begin The opening stackitem.\n */\nBaseMethods.AlignedArray = function(parser: TexParser, begin: StackItem) {\n  // @test Array1, Array2, Array Test\n  const align = parser.GetBrackets('\\\\begin{' + begin.getName() + '}');\n  let item = BaseMethods.Array(parser, begin);\n  return ParseUtil.setArrayAlign(item as sitem.ArrayItem, align);\n};\n\n\n/**\n * Handle equation environment.\n * @param {TexParser} parser The calling parser.\n * @param {StackItem} begin The opening stackitem.\n * @param {boolean} numbered True if environment is numbered.\n */\nBaseMethods.Equation = function (parser: TexParser, begin: StackItem, numbered: boolean) {\n  parser.Push(begin);\n  ParseUtil.checkEqnEnv(parser);\n  return parser.itemFactory.create('equation', numbered).\n    setProperty('name', begin.getName());\n};\n\n\n/**\n * Handle eqnarray.\n * @param {TexParser} parser The calling parser.\n * @param {StackItem} begin The opening stackitem.\n * @param {boolean} numbered True if environment is numbered.\n * @param {boolean} taggable True if taggable.\n * @param {string} align Alignment string.\n * @param {string} spacing Spacing between columns.\n */\nBaseMethods.EqnArray = function(parser: TexParser, begin: StackItem,\n                                numbered: boolean, taggable: boolean,\n                                align: string, spacing: string) {\n  // @test The Lorenz Equations, Maxwell's Equations, Cubic Binomial\n  parser.Push(begin);\n  if (taggable) {\n    ParseUtil.checkEqnEnv(parser);\n  }\n  align = align.replace(/[^clr]/g, '').split('').join(' ');\n  align = align.replace(/l/g, 'left').replace(/r/g, 'right').replace(/c/g, 'center');\n  let newItem = parser.itemFactory.create('eqnarray', begin.getName(),\n                                          numbered, taggable, parser.stack.global) as sitem.ArrayItem;\n  newItem.arraydef = {\n    displaystyle: true,\n    columnalign: align,\n    columnspacing: (spacing || '1em'),\n    rowspacing: '3pt',\n    side: parser.options['tagSide'],\n    minlabelspacing: parser.options['tagIndent']\n  };\n  return newItem;\n};\n\n\n/**\n * Handles no tag commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.HandleNoTag = function(parser: TexParser, _name: string) {\n  parser.tags.notag();\n};\n\n\n/**\n * Record a label name for a tag\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.HandleLabel = function(parser: TexParser, name: string) {\n  // @test Label, Label Empty\n  let label = parser.GetArgument(name);\n  if (label === '') {\n    // @test Label Empty\n    return;\n  }\n  if (!parser.tags.refUpdate) {\n    // @test Label, Ref, Ref Unknown\n    if (parser.tags.label) {\n      // @test Double Label Error\n      throw new TexError('MultipleCommand', 'Multiple %1', parser.currentCS);\n    }\n    parser.tags.label = label;\n    if ((parser.tags.allLabels[label] || parser.tags.labels[label]) && !parser.options['ignoreDuplicateLabels']) {\n      // @ Duplicate Label Error\n      throw new TexError('MultipleLabel', 'Label \\'%1\\' multiply defined', label);\n    }\n    // TODO: This should be set in the tags structure!\n    parser.tags.labels[label] = new Label(); // will be replaced by tag value later\n  }\n};\n\n\n/**\n * Handle a label reference.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {boolean} eqref True if formatted as eqref.\n */\nBaseMethods.HandleRef = function(parser: TexParser, name: string, eqref: boolean) {\n  // @test Ref, Ref Unknown, Eqref, Ref Default, Ref Named\n  let label = parser.GetArgument(name);\n  let ref = parser.tags.allLabels[label] || parser.tags.labels[label];\n  if (!ref) {\n    // @test Ref Unknown\n    if (!parser.tags.refUpdate) {\n      parser.tags.redo = true;\n    }\n    ref = new Label();\n  }\n  let tag = ref.tag;\n  if (eqref) {\n    // @test Eqref\n    tag = parser.tags.formatTag(tag);\n  }\n  let node = parser.create('node', 'mrow', ParseUtil.internalMath(parser, tag), {\n    href: parser.tags.formatUrl(ref.id, parser.options.baseURL), 'class': 'MathJax_ref'\n  });\n  parser.Push(node);\n};\n\n\n\n/**\n * Macros\n */\nBaseMethods.Macro = function(parser: TexParser, name: string,\n                             macro: string, argcount: number,\n                             def?: string) {\n  if (argcount) {\n    const args: string[] = [];\n    if (def != null) {\n      const optional = parser.GetBrackets(name);\n      args.push(optional == null ? def : optional);\n    }\n    for (let i = args.length; i < argcount; i++) {\n      args.push(parser.GetArgument(name));\n    }\n    macro = ParseUtil.substituteArgs(parser, args, macro);\n  }\n  parser.string = ParseUtil.addArgs(parser, macro, parser.string.slice(parser.i));\n  parser.i = 0;\n  ParseUtil.checkMaxMacros(parser);\n};\n\n\n/**\n * Handle MathChoice for elements whose exact size/style properties can only be\n * determined after the expression has been parsed.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.MathChoice = function(parser: TexParser, name: string) {\n  const D  = parser.ParseArg(name);\n  const T  = parser.ParseArg(name);\n  const S  = parser.ParseArg(name);\n  const SS = parser.ParseArg(name);\n  parser.Push(parser.create('node', 'MathChoice', [D, T, S, SS]));\n};\n\n\nexport default BaseMethods;\n"]},"metadata":{},"sourceType":"script"}