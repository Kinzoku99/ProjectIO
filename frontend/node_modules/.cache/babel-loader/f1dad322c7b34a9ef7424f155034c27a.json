{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommonArrow = exports.CommonDiagonalArrow = exports.CommonDiagonalStrike = exports.CommonBorder2 = exports.CommonBorder = exports.arrowBBox = exports.diagonalArrowDef = exports.arrowDef = exports.arrowBBoxW = exports.arrowBBoxHD = exports.arrowHead = exports.fullBorder = exports.fullPadding = exports.fullBBox = exports.sideNames = exports.sideIndex = exports.SOLID = exports.PADDING = exports.THICKNESS = exports.ARROWY = exports.ARROWDX = exports.ARROWX = void 0;\nexports.ARROWX = 4, exports.ARROWDX = 1, exports.ARROWY = 2;\nexports.THICKNESS = .067;\nexports.PADDING = .2;\nexports.SOLID = exports.THICKNESS + 'em solid';\nexports.sideIndex = {\n  top: 0,\n  right: 1,\n  bottom: 2,\n  left: 3\n};\nexports.sideNames = Object.keys(exports.sideIndex);\n\nexports.fullBBox = function (node) {\n  return new Array(4).fill(node.thickness + node.padding);\n};\n\nexports.fullPadding = function (node) {\n  return new Array(4).fill(node.padding);\n};\n\nexports.fullBorder = function (node) {\n  return new Array(4).fill(node.thickness);\n};\n\nvar arrowHead = function (node) {\n  return Math.max(node.padding, node.thickness * (node.arrowhead.x + node.arrowhead.dx + 1));\n};\n\nexports.arrowHead = arrowHead;\n\nvar arrowBBoxHD = function (node, TRBL) {\n  if (node.childNodes[0]) {\n    var _a = node.childNodes[0].getBBox(),\n        h = _a.h,\n        d = _a.d;\n\n    TRBL[0] = TRBL[2] = Math.max(0, node.thickness * node.arrowhead.y - (h + d) / 2);\n  }\n\n  return TRBL;\n};\n\nexports.arrowBBoxHD = arrowBBoxHD;\n\nvar arrowBBoxW = function (node, TRBL) {\n  if (node.childNodes[0]) {\n    var w = node.childNodes[0].getBBox().w;\n    TRBL[1] = TRBL[3] = Math.max(0, node.thickness * node.arrowhead.y - w / 2);\n  }\n\n  return TRBL;\n};\n\nexports.arrowBBoxW = arrowBBoxW;\nexports.arrowDef = {\n  up: [-Math.PI / 2, false, true, 'verticalstrike'],\n  down: [Math.PI / 2, false, true, 'verticakstrike'],\n  right: [0, false, false, 'horizontalstrike'],\n  left: [Math.PI, false, false, 'horizontalstrike'],\n  updown: [Math.PI / 2, true, true, 'verticalstrike uparrow downarrow'],\n  leftright: [0, true, false, 'horizontalstrike leftarrow rightarrow']\n};\nexports.diagonalArrowDef = {\n  updiagonal: [-1, 0, false, 'updiagonalstrike northeastarrow'],\n  northeast: [-1, 0, false, 'updiagonalstrike updiagonalarrow'],\n  southeast: [1, 0, false, 'downdiagonalstrike'],\n  northwest: [1, Math.PI, false, 'downdiagonalstrike'],\n  southwest: [-1, Math.PI, false, 'updiagonalstrike'],\n  northeastsouthwest: [-1, 0, true, 'updiagonalstrike northeastarrow updiagonalarrow southwestarrow'],\n  northwestsoutheast: [1, 0, true, 'downdiagonalstrike northwestarrow southeastarrow']\n};\nexports.arrowBBox = {\n  up: function (node) {\n    return exports.arrowBBoxW(node, [exports.arrowHead(node), 0, node.padding, 0]);\n  },\n  down: function (node) {\n    return exports.arrowBBoxW(node, [node.padding, 0, exports.arrowHead(node), 0]);\n  },\n  right: function (node) {\n    return exports.arrowBBoxHD(node, [0, exports.arrowHead(node), 0, node.padding]);\n  },\n  left: function (node) {\n    return exports.arrowBBoxHD(node, [0, node.padding, 0, exports.arrowHead(node)]);\n  },\n  updown: function (node) {\n    return exports.arrowBBoxW(node, [exports.arrowHead(node), 0, exports.arrowHead(node), 0]);\n  },\n  leftright: function (node) {\n    return exports.arrowBBoxHD(node, [0, exports.arrowHead(node), 0, exports.arrowHead(node)]);\n  }\n};\n\nvar CommonBorder = function (render) {\n  return function (side) {\n    var i = exports.sideIndex[side];\n    return [side, {\n      renderer: render,\n      bbox: function (node) {\n        var bbox = [0, 0, 0, 0];\n        bbox[i] = node.thickness + node.padding;\n        return bbox;\n      },\n      border: function (node) {\n        var bbox = [0, 0, 0, 0];\n        bbox[i] = node.thickness;\n        return bbox;\n      }\n    }];\n  };\n};\n\nexports.CommonBorder = CommonBorder;\n\nvar CommonBorder2 = function (render) {\n  return function (name, side1, side2) {\n    var i1 = exports.sideIndex[side1];\n    var i2 = exports.sideIndex[side2];\n    return [name, {\n      renderer: render,\n      bbox: function (node) {\n        var t = node.thickness + node.padding;\n        var bbox = [0, 0, 0, 0];\n        bbox[i1] = bbox[i2] = t;\n        return bbox;\n      },\n      border: function (node) {\n        var bbox = [0, 0, 0, 0];\n        bbox[i1] = bbox[i2] = node.thickness;\n        return bbox;\n      },\n      remove: side1 + ' ' + side2\n    }];\n  };\n};\n\nexports.CommonBorder2 = CommonBorder2;\n\nvar CommonDiagonalStrike = function (render) {\n  return function (name) {\n    var cname = 'mjx-' + name.charAt(0) + 'strike';\n    return [name + 'diagonalstrike', {\n      renderer: render(cname),\n      bbox: exports.fullBBox\n    }];\n  };\n};\n\nexports.CommonDiagonalStrike = CommonDiagonalStrike;\n\nvar CommonDiagonalArrow = function (render) {\n  return function (name) {\n    var _a = __read(exports.diagonalArrowDef[name], 4),\n        c = _a[0],\n        pi = _a[1],\n        double = _a[2],\n        remove = _a[3];\n\n    return [name + 'arrow', {\n      renderer: function (node, _child) {\n        var _a = __read(node.arrowAW(), 2),\n            a = _a[0],\n            W = _a[1];\n\n        var arrow = node.arrow(W, c * (a - pi), double);\n        render(node, arrow);\n      },\n      bbox: function (node) {\n        var _a = node.arrowData(),\n            a = _a.a,\n            x = _a.x,\n            y = _a.y;\n\n        var _b = __read([node.arrowhead.x, node.arrowhead.y, node.arrowhead.dx], 3),\n            ax = _b[0],\n            ay = _b[1],\n            adx = _b[2];\n\n        var _c = __read(node.getArgMod(ax + adx, ay), 2),\n            b = _c[0],\n            ar = _c[1];\n\n        var dy = y + (b > a ? node.thickness * ar * Math.sin(b - a) : 0);\n        var dx = x + (b > Math.PI / 2 - a ? node.thickness * ar * Math.sin(b + a - Math.PI / 2) : 0);\n        return [dy, dx, dy, dx];\n      },\n      remove: remove\n    }];\n  };\n};\n\nexports.CommonDiagonalArrow = CommonDiagonalArrow;\n\nvar CommonArrow = function (render) {\n  return function (name) {\n    var _a = __read(exports.arrowDef[name], 4),\n        angle = _a[0],\n        double = _a[1],\n        isVertical = _a[2],\n        remove = _a[3];\n\n    return [name + 'arrow', {\n      renderer: function (node, _child) {\n        var _a = node.getBBox(),\n            w = _a.w,\n            h = _a.h,\n            d = _a.d;\n\n        var _b = __read(isVertical ? [h + d, 'X'] : [w, 'Y'], 2),\n            W = _b[0],\n            offset = _b[1];\n\n        var dd = node.getOffset(offset);\n        var arrow = node.arrow(W, angle, double, offset, dd);\n        render(node, arrow);\n      },\n      bbox: exports.arrowBBox[name],\n      remove: remove\n    }];\n  };\n};\n\nexports.CommonArrow = CommonArrow;","map":{"version":3,"mappings":"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","names":["exports","top","right","bottom","left","Object","keys","node","Array","fill","thickness","padding","arrowHead","Math","max","arrowhead","x","dx","arrowBBoxHD","TRBL","childNodes","getBBox","h","d","y","arrowBBoxW","w","up","PI","down","updown","leftright","updiagonal","northeast","southeast","northwest","southwest","northeastsouthwest","northwestsoutheast","CommonBorder","render","side","i","renderer","bbox","border","CommonBorder2","name","side1","side2","i1","i2","t","remove","CommonDiagonalStrike","cname","charAt","CommonDiagonalArrow","c","pi","double","_child","arrowAW","a","W","arrow","arrowData","ax","ay","adx","getArgMod","b","ar","dy","sin","CommonArrow","angle","isVertical","offset","dd","getOffset"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/output/common/Notation.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements utilities for notations for menclose elements\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AnyWrapper} from './Wrapper.js';\nimport {CommonMenclose} from './Wrappers/menclose.js';\n\n/*****************************************************************/\n\nexport const ARROWX = 4, ARROWDX = 1, ARROWY = 2;  // default relative arrowhead values\n\nexport const THICKNESS = .067;  // default rule thickness\nexport const PADDING = .2;      // default padding\n\nexport const SOLID = THICKNESS + 'em solid';  // a solid border\n\n/*****************************************************************/\n\n/**\n * Shorthand for CommonMenclose\n */\nexport type Menclose = CommonMenclose<any, any, any>;\n\n/**\n * Top, right, bottom, left padding data\n */\nexport type PaddingData = [number, number, number, number];\n\n/**\n * The functions used for notation definitions\n *\n * @templare N  The DOM node class\n */\nexport type Renderer<W extends AnyWrapper, N> = (node: W, child: N) => void;\nexport type BBoxExtender<W extends AnyWrapper> = (node: W) => PaddingData;\nexport type BBoxBorder<W extends AnyWrapper> = (node: W) => PaddingData;\nexport type Initializer<W extends AnyWrapper> = (node: W) => void;\n\n/**\n * The definition of a notation\n *\n * @template W  The menclose wrapper class\n * @templare N  The DOM node class\n */\nexport type NotationDef<W extends AnyWrapper, N> = {\n  renderer: Renderer<W, N>;  // renders the DOM nodes for the notation\n  bbox: BBoxExtender<W>;     // gives the offsets to the child bounding box: [top, right, bottom, left]\n  border?: BBoxBorder<W>;    // gives the amount of the bbox offset that is due to borders on the child\n  renderChild?: boolean;     // true if the notation is used to render the child directly (e.g., radical)\n  init?: Initializer<W>;     // function to be called during wrapper construction\n  remove?: string;           // list of notations that are suppressed by this one\n};\n\n/**\n * For defining notation maps\n *\n * @template W  The menclose wrapper class\n * @templare N  The DOM node class\n */\nexport type DefPair<W extends AnyWrapper, N> = [string, NotationDef<W, N>];\nexport type DefList<W extends AnyWrapper, N> = Map<string, NotationDef<W, N>>;\n\nexport type DefPairF<T, W extends AnyWrapper, N> = (name: T) => DefPair<W, N>;\n\n/**\n * The list of notations for an menclose element\n *\n * @template W  The menclose wrapper class\n * @templare N  The DOM node class\n */\nexport type List<W extends AnyWrapper, N> = {[notation: string]: NotationDef<W, N>};\n\n/*****************************************************************/\n\n/**\n * The names and indices of sides for borders, padding, etc.\n */\nexport const sideIndex = {top: 0, right: 1, bottom: 2, left: 3};\nexport type Side = keyof typeof sideIndex;\nexport const sideNames = Object.keys(sideIndex) as Side[];\n\n/**\n * Common BBox and Border functions\n */\nexport const fullBBox = ((node) => new Array(4).fill(node.thickness + node.padding)) as BBoxExtender<Menclose>;\nexport const fullPadding = ((node) => new Array(4).fill(node.padding)) as BBoxExtender<Menclose>;\nexport const fullBorder = ((node) => new Array(4).fill(node.thickness)) as BBoxBorder<Menclose>;\n\n/*****************************************************************/\n\n/**\n * The length of an arrowhead\n */\nexport const arrowHead = (node: Menclose) => {\n  return Math.max(node.padding, node.thickness * (node.arrowhead.x + node.arrowhead.dx + 1));\n};\n\n/**\n * Adjust short bbox for tall arrow heads\n */\nexport const arrowBBoxHD = (node: Menclose, TRBL: PaddingData) => {\n  if (node.childNodes[0]) {\n    const {h, d} = node.childNodes[0].getBBox();\n    TRBL[0] = TRBL[2] = Math.max(0, node.thickness * node.arrowhead.y - (h + d) / 2);\n  }\n  return TRBL;\n};\n\n/**\n * Adjust thin bbox for wide arrow heads\n */\nexport const arrowBBoxW = (node: Menclose, TRBL: PaddingData) => {\n  if (node.childNodes[0]) {\n    const {w} = node.childNodes[0].getBBox();\n    TRBL[1] = TRBL[3] = Math.max(0, node.thickness * node.arrowhead.y - w / 2);\n  }\n  return TRBL;\n};\n\n/**\n * The data for horizontal and vertical arrow notations\n *   [angle, double, isVertical, remove]\n */\nexport const arrowDef = {\n  up:        [-Math.PI / 2, false, true,  'verticalstrike'],\n  down:      [ Math.PI / 2, false, true,  'verticakstrike'],\n  right:     [ 0,           false, false, 'horizontalstrike'],\n  left:      [ Math.PI,     false, false, 'horizontalstrike'],\n  updown:    [ Math.PI / 2, true,  true,  'verticalstrike uparrow downarrow'],\n  leftright: [ 0,           true,  false, 'horizontalstrike leftarrow rightarrow']\n} as {[name: string]: [number, boolean, boolean, string]};\n\n/**\n * The data for diagonal arrow notations\n *   [c, pi, double, remove]\n */\nexport const diagonalArrowDef = {\n  updiagonal:         [-1, 0,       false, 'updiagonalstrike northeastarrow'],\n  northeast:          [-1, 0,       false, 'updiagonalstrike updiagonalarrow'],\n  southeast:          [ 1, 0,       false, 'downdiagonalstrike'],\n  northwest:          [ 1, Math.PI, false, 'downdiagonalstrike'],\n  southwest:          [-1, Math.PI, false, 'updiagonalstrike'],\n  northeastsouthwest: [-1, 0,       true,  'updiagonalstrike northeastarrow updiagonalarrow southwestarrow'],\n  northwestsoutheast: [ 1, 0,       true,  'downdiagonalstrike northwestarrow southeastarrow']\n} as {[name: string]: [number, number, boolean, string]};\n\n/**\n * The BBox functions for horizontal and vertical arrows\n */\nexport const arrowBBox = {\n  up:    (node) => arrowBBoxW(node, [arrowHead(node), 0, node.padding, 0]),\n  down:  (node) => arrowBBoxW(node, [node.padding, 0, arrowHead(node), 0]),\n  right: (node) => arrowBBoxHD(node, [0, arrowHead(node), 0, node.padding]),\n  left:  (node) => arrowBBoxHD(node, [0, node.padding, 0, arrowHead(node)]),\n  updown:    (node) => arrowBBoxW(node, [arrowHead(node), 0, arrowHead(node), 0]),\n  leftright: (node) => arrowBBoxHD(node, [0, arrowHead(node), 0, arrowHead(node)])\n} as {[name: string]: BBoxExtender<Menclose>};\n\n/*****************************************************************/\n\n/**\n * @param {Renderer} render     The function for adding the border to the node\n * @return {string => DefPair}  The function returingn the notation definition\n *                              for the notation having a line on the given side\n */\nexport const CommonBorder = function<W extends Menclose, N>(render: Renderer<W, N>): DefPairF<Side, W, N> {\n  /**\n   * @param {string} side   The side on which a border should appear\n   * @return {DefPair}      The notation definition for the notation having a line on the given side\n   */\n  return (side: Side) => {\n    const i = sideIndex[side];\n    return [side, {\n      //\n      // Add the border to the main child object\n      //\n      renderer: render,\n      //\n      // Indicate the extra space on the given side\n      //\n      bbox: (node) => {\n        const bbox = [0, 0, 0, 0] as PaddingData;\n        bbox[i] = node.thickness + node.padding;\n        return bbox;\n      },\n      //\n      // Indicate the border on the given side\n      //\n      border: (node) => {\n        const bbox = [0, 0, 0, 0] as PaddingData;\n        bbox[i] = node.thickness;\n        return bbox;\n      }\n    }];\n  };\n};\n\n/**\n * @param {Renderer} render                    The function for adding the borders to the node\n * @return {(sring, Side, Side) => DefPair}    The function returning the notation definition\n *                                             for the notation having lines on two sides\n */\nexport const CommonBorder2 = function<W extends Menclose, N>(render: Renderer<W, N>):\n(name: string, side1: Side, side2: Side) => DefPair<W, N> {\n  /**\n   * @param {string} name    The name of the notation to define\n   * @param {Side} side1   The first side to get a border\n   * @param {Side} side2   The second side to get a border\n   * @return {DefPair}       The notation definition for the notation having lines on two sides\n   */\n  return (name: string, side1: Side, side2: Side) => {\n    const i1 = sideIndex[side1];\n    const i2 = sideIndex[side2];\n    return [name, {\n      //\n      // Add the border along the given sides\n      //\n      renderer: render,\n      //\n      // Mark the extra space along the two sides\n      //\n      bbox: (node) => {\n        const t = node.thickness + node.padding;\n        const bbox = [0, 0, 0, 0] as PaddingData;\n        bbox[i1] = bbox[i2] = t;\n        return bbox;\n      },\n      //\n      // Indicate the border on the two sides\n      //\n      border: (node) => {\n        const bbox = [0, 0, 0, 0] as PaddingData;\n        bbox[i1] = bbox[i2] = node.thickness;\n        return bbox;\n      },\n      //\n      // Remove the single side notations, if present\n      //\n      remove: side1 + ' ' + side2\n    }];\n  };\n};\n\n/*****************************************************************/\n\n/**\n * @param {string => Renderer} render      The function for adding the strike to the node\n * @return {string => DefPair}   The function returning the notation definition for the diagonal strike\n */\nexport const CommonDiagonalStrike = function<W extends Menclose, N>(render: (sname: string) => Renderer<W, N>):\nDefPairF<string, W, N> {\n  /**\n   * @param {string} name  The name of the diagonal strike to define\n   * @return {DefPair}     The notation definition for the diagonal strike\n   */\n  return (name: string) => {\n    const cname = 'mjx-' + name.charAt(0) + 'strike';\n    return [name + 'diagonalstrike', {\n      //\n      // Find the angle and width from the bounding box size and create the diagonal line\n      //\n      renderer: render(cname),\n      //\n      //  Add padding all around\n      //\n      bbox: fullBBox\n    }];\n  };\n};\n\n/*****************************************************************/\n\n/**\n * @param {Renderer} render     The function to add the arrow to the node\n * @return {string => DefPair}  The funciton returning the notation definition for the diagonal arrow\n */\nexport const CommonDiagonalArrow = function<W extends Menclose, N>(render: Renderer<W, N>): DefPairF<string, W, N> {\n  /**\n   * @param {string} name   The name of the diagonal arrow to define\n   * @return {DefPair}      The notation definition for the diagonal arrow\n   */\n  return (name: string) => {\n    const [c, pi, double, remove] = diagonalArrowDef[name];\n    return [name + 'arrow', {\n      //\n      // Find the angle and width from the bounding box size and create\n      //   the arrow from them and the other arrow data\n      //\n      renderer: (node, _child) => {\n        const [a, W] = node.arrowAW();\n       const arrow = node.arrow(W, c * (a - pi), double);\n        render(node, arrow);\n      },\n      //\n      // Add space for the arrowhead all around\n      //\n      bbox: (node) => {\n        const {a, x, y} = node.arrowData();\n        const [ax, ay, adx] = [node.arrowhead.x, node.arrowhead.y, node.arrowhead.dx];\n        const [b, ar] = node.getArgMod(ax + adx, ay);\n        const dy = y + (b > a ? node.thickness * ar * Math.sin(b - a) : 0);\n        const dx = x + (b > Math.PI / 2 - a ? node.thickness * ar * Math.sin(b + a - Math.PI / 2) : 0);\n        return [dy, dx, dy, dx];\n      },\n      //\n      // Remove redundant notations\n      //\n      remove: remove\n    }];\n  };\n};\n\n/**\n * @param {Renderer} render     The function to add the arrow to the node\n * @return {string => DefPair}  The function returning the notation definition for the arrow\n */\nexport const CommonArrow = function<W extends Menclose, N>(render: Renderer<W, N>): DefPairF<string, W, N> {\n  /**\n   * @param {string} name   The name of the horizontal or vertical arrow to define\n   * @return {DefPair}      The notation definition for the arrow\n   */\n  return (name: string) => {\n    const [angle, double, isVertical, remove] = arrowDef[name];\n    return [name + 'arrow', {\n      //\n      // Get the arrow height and depth from the bounding box and the arrow direction\n      //   then create the arrow from that and the other data\n      //\n      renderer: (node, _child) => {\n        const {w, h, d} = node.getBBox();\n        const [W, offset] = (isVertical ? [h + d, 'X'] : [w, 'Y']);\n        const dd = node.getOffset(offset);\n        const arrow = node.arrow(W, angle, double, offset, dd);\n        render(node, arrow);\n      },\n      //\n      // Add the padding to the proper sides\n      //\n      bbox: arrowBBox[name],\n      //\n      // Remove redundant notations\n      //\n      remove: remove\n    }];\n  };\n};\n"]},"metadata":{},"sourceType":"script"}