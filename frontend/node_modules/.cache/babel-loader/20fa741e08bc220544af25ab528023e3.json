{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar MmlNode_js_1 = require(\"../../core/MmlTree/MmlNode.js\");\n\nvar NodeUtil_js_1 = require(\"./NodeUtil.js\");\n\nvar FilterUtil;\n\n(function (FilterUtil) {\n  FilterUtil.cleanStretchy = function (arg) {\n    var e_1, _a;\n\n    var options = arg.data;\n\n    try {\n      for (var _b = __values(options.getList('fixStretchy')), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var mo = _c.value;\n\n        if (NodeUtil_js_1.default.getProperty(mo, 'fixStretchy')) {\n          var symbol = NodeUtil_js_1.default.getForm(mo);\n\n          if (symbol && symbol[3] && symbol[3]['stretchy']) {\n            NodeUtil_js_1.default.setAttribute(mo, 'stretchy', false);\n          }\n\n          var parent_1 = mo.parent;\n\n          if (!NodeUtil_js_1.default.getTexClass(mo) && (!symbol || !symbol[2])) {\n            var texAtom = options.nodeFactory.create('node', 'TeXAtom', [mo]);\n            parent_1.replaceChild(texAtom, mo);\n            texAtom.inheritAttributesFrom(mo);\n          }\n\n          NodeUtil_js_1.default.removeProperties(mo, 'fixStretchy');\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n\n  FilterUtil.cleanAttributes = function (arg) {\n    var node = arg.data.root;\n    node.walkTree(function (mml, _d) {\n      var e_2, _a;\n\n      var attribs = mml.attributes;\n\n      if (!attribs) {\n        return;\n      }\n\n      try {\n        for (var _b = __values(attribs.getExplicitNames()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var key = _c.value;\n\n          if (attribs.attributes[key] === mml.attributes.getInherited(key)) {\n            delete attribs.attributes[key];\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }, {});\n  };\n\n  FilterUtil.combineRelations = function (arg) {\n    var e_3, _a, e_4, _b;\n\n    var remove = [];\n\n    try {\n      for (var _c = __values(arg.data.getList('mo')), _e = _c.next(); !_e.done; _e = _c.next()) {\n        var mo = _e.value;\n\n        if (mo.getProperty('relationsCombined') || !mo.parent || mo.parent && !NodeUtil_js_1.default.isType(mo.parent, 'mrow') || NodeUtil_js_1.default.getTexClass(mo) !== MmlNode_js_1.TEXCLASS.REL) {\n          continue;\n        }\n\n        var mml = mo.parent;\n        var m2 = void 0;\n        var children = mml.childNodes;\n        var next = children.indexOf(mo) + 1;\n        var variantForm = NodeUtil_js_1.default.getProperty(mo, 'variantForm');\n\n        while (next < children.length && (m2 = children[next]) && NodeUtil_js_1.default.isType(m2, 'mo') && NodeUtil_js_1.default.getTexClass(m2) === MmlNode_js_1.TEXCLASS.REL) {\n          if (variantForm === NodeUtil_js_1.default.getProperty(m2, 'variantForm') && _compareExplicit(mo, m2)) {\n            NodeUtil_js_1.default.appendChildren(mo, NodeUtil_js_1.default.getChildren(m2));\n\n            _copyExplicit(['stretchy', 'rspace'], mo, m2);\n\n            try {\n              for (var _f = (e_4 = void 0, __values(m2.getPropertyNames())), _g = _f.next(); !_g.done; _g = _f.next()) {\n                var name_1 = _g.value;\n                mo.setProperty(name_1, m2.getProperty(name_1));\n              }\n            } catch (e_4_1) {\n              e_4 = {\n                error: e_4_1\n              };\n            } finally {\n              try {\n                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n              } finally {\n                if (e_4) throw e_4.error;\n              }\n            }\n\n            children.splice(next, 1);\n            remove.push(m2);\n            m2.parent = null;\n            m2.setProperty('relationsCombined', true);\n          } else {\n            if (mo.attributes.getExplicit('rspace') == null) {\n              NodeUtil_js_1.default.setAttribute(mo, 'rspace', '0pt');\n            }\n\n            if (m2.attributes.getExplicit('lspace') == null) {\n              NodeUtil_js_1.default.setAttribute(m2, 'lspace', '0pt');\n            }\n\n            break;\n          }\n        }\n\n        mo.attributes.setInherited('form', mo.getForms()[0]);\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_e && !_e.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    arg.data.removeFromList('mo', remove);\n  };\n\n  var _copyExplicit = function (attrs, node1, node2) {\n    var attr1 = node1.attributes;\n    var attr2 = node2.attributes;\n    attrs.forEach(function (x) {\n      var attr = attr2.getExplicit(x);\n\n      if (attr != null) {\n        attr1.set(x, attr);\n      }\n    });\n  };\n\n  var _compareExplicit = function (node1, node2) {\n    var e_5, _a;\n\n    var filter = function (attr, space) {\n      var exp = attr.getExplicitNames();\n      return exp.filter(function (x) {\n        return x !== space && (x !== 'stretchy' || attr.getExplicit('stretchy'));\n      });\n    };\n\n    var attr1 = node1.attributes;\n    var attr2 = node2.attributes;\n    var exp1 = filter(attr1, 'lspace');\n    var exp2 = filter(attr2, 'rspace');\n\n    if (exp1.length !== exp2.length) {\n      return false;\n    }\n\n    try {\n      for (var exp1_1 = __values(exp1), exp1_1_1 = exp1_1.next(); !exp1_1_1.done; exp1_1_1 = exp1_1.next()) {\n        var name_2 = exp1_1_1.value;\n\n        if (attr1.getExplicit(name_2) !== attr2.getExplicit(name_2)) {\n          return false;\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (exp1_1_1 && !exp1_1_1.done && (_a = exp1_1.return)) _a.call(exp1_1);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    return true;\n  };\n\n  var _cleanSubSup = function (options, low, up) {\n    var e_6, _a;\n\n    var remove = [];\n\n    try {\n      for (var _b = __values(options.getList('m' + low + up)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var mml = _c.value;\n        var children = mml.childNodes;\n\n        if (children[mml[low]] && children[mml[up]]) {\n          continue;\n        }\n\n        var parent_2 = mml.parent;\n        var newNode = children[mml[low]] ? options.nodeFactory.create('node', 'm' + low, [children[mml.base], children[mml[low]]]) : options.nodeFactory.create('node', 'm' + up, [children[mml.base], children[mml[up]]]);\n        NodeUtil_js_1.default.copyAttributes(mml, newNode);\n\n        if (parent_2) {\n          parent_2.replaceChild(newNode, mml);\n        } else {\n          options.root = newNode;\n        }\n\n        remove.push(mml);\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n\n    options.removeFromList('m' + low + up, remove);\n  };\n\n  FilterUtil.cleanSubSup = function (arg) {\n    var options = arg.data;\n\n    if (options.error) {\n      return;\n    }\n\n    _cleanSubSup(options, 'sub', 'sup');\n\n    _cleanSubSup(options, 'under', 'over');\n  };\n\n  var _moveLimits = function (options, underover, subsup) {\n    var e_7, _a;\n\n    var remove = [];\n\n    try {\n      for (var _b = __values(options.getList(underover)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var mml = _c.value;\n\n        if (mml.attributes.get('displaystyle')) {\n          continue;\n        }\n\n        var base = mml.childNodes[mml.base];\n        var mo = base.coreMO();\n\n        if (base.getProperty('movablelimits') && !mo.attributes.getExplicit('movablelimits')) {\n          var node = options.nodeFactory.create('node', subsup, mml.childNodes);\n          NodeUtil_js_1.default.copyAttributes(mml, node);\n\n          if (mml.parent) {\n            mml.parent.replaceChild(node, mml);\n          } else {\n            options.root = node;\n          }\n\n          remove.push(mml);\n        }\n      }\n    } catch (e_7_1) {\n      e_7 = {\n        error: e_7_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_7) throw e_7.error;\n      }\n    }\n\n    options.removeFromList(underover, remove);\n  };\n\n  FilterUtil.moveLimits = function (arg) {\n    var options = arg.data;\n\n    _moveLimits(options, 'munderover', 'msubsup');\n\n    _moveLimits(options, 'munder', 'msub');\n\n    _moveLimits(options, 'mover', 'msup');\n  };\n\n  FilterUtil.setInherited = function (arg) {\n    arg.data.root.setInheritedAttributes({}, arg.math['display'], 0, false);\n  };\n})(FilterUtil || (FilterUtil = {}));\n\nexports.default = FilterUtil;","map":{"version":3,"mappings":"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","names":["FilterUtil","arg","options","data","getList","_c","mo","NodeUtil_js_1","getProperty","symbol","getForm","setAttribute","parent_1","parent","getTexClass","texAtom","nodeFactory","create","replaceChild","inheritAttributesFrom","removeProperties","node","root","walkTree","mml","_d","attribs","attributes","getExplicitNames","key","getInherited","remove","_e","isType","MmlNode_js_1","REL","m2","children","childNodes","next","indexOf","variantForm","length","_compareExplicit","appendChildren","getChildren","_copyExplicit","getPropertyNames","_g","name_1","setProperty","splice","push","getExplicit","setInherited","getForms","removeFromList","attrs","node1","node2","attr1","attr2","forEach","attr","x","set","filter","space","exp","exp1","exp2","exp1_1_1","name_2","_cleanSubSup","low","up","parent_2","newNode","base","copyAttributes","error","_moveLimits","underover","subsup","get","coreMO","setInheritedAttributes","math","exports"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/input/tex/FilterUtil.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Utility functions for standard pre and post filters.\n *\n * @author sorge@mathjax.org (Volker Sorge)\n */\n\n\nimport {TEXCLASS, MMLNODE, MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport NodeUtil from './NodeUtil.js';\nimport ParseOptions from './ParseOptions.js';\nimport {MmlMo} from '../../core/MmlTree/MmlNodes/mo.js';\nimport {Attributes} from '../../core/MmlTree/Attributes.js';\n\n\nnamespace FilterUtil {\n\n  /**\n   * Visitor to set stretchy attributes to false on <mo> elements, if they are\n   * not used as delimiters. Also wraps non-stretchy infix delimiters into a\n   * TeXAtom.\n   * @param {MmlNode} math The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let cleanStretchy = function(arg: {math: any, data: ParseOptions}) {\n    let options = arg.data;\n    for (let mo of options.getList('fixStretchy')) {\n      if (NodeUtil.getProperty(mo, 'fixStretchy')) {\n        let symbol = NodeUtil.getForm(mo);\n        if (symbol && symbol[3] && symbol[3]['stretchy']) {\n          NodeUtil.setAttribute(mo, 'stretchy', false);\n        }\n        const parent = mo.parent;\n        if (!NodeUtil.getTexClass(mo) && (!symbol || !symbol[2])) {\n          const texAtom = options.nodeFactory.create('node', 'TeXAtom', [mo]);\n          parent.replaceChild(texAtom, mo);\n          texAtom.inheritAttributesFrom(mo);\n        }\n        NodeUtil.removeProperties(mo, 'fixStretchy');\n      }\n    }\n  };\n\n\n  /**\n   * Visitor that removes superfluous attributes from nodes. I.e., if a node has\n   * an attribute, which is also an inherited attribute it will be removed. This\n   * is necessary as attributes are set bottom up in the parser.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let cleanAttributes = function(arg: {data: ParseOptions}) {\n    let node = arg.data.root as MmlNode;\n    node.walkTree((mml: MmlNode, _d: any) => {\n      let attribs = mml.attributes as any;\n      if (!attribs) {\n        return;\n      }\n      for (const key of attribs.getExplicitNames()) {\n        if (attribs.attributes[key] === mml.attributes.getInherited(key)) {\n          delete attribs.attributes[key];\n        }\n      }\n    }, {});\n  };\n\n\n  /**\n   * Combine adjacent <mo> elements that are relations (since MathML treats the\n   * spacing very differently)\n   * @param {ParseOptions} data The parse options.\n   */\n  export let combineRelations = function(arg: {data: ParseOptions}) {\n    const remove: MmlNode[] = [];\n    for (let mo of arg.data.getList('mo')) {\n      if (mo.getProperty('relationsCombined') || !mo.parent ||\n          (mo.parent && !NodeUtil.isType(mo.parent, 'mrow')) ||\n          NodeUtil.getTexClass(mo) !== TEXCLASS.REL) {\n        // @test Prime, PrimeSup, Named Function\n        continue;\n      }\n      let mml = mo.parent;\n      let m2: MmlNode;\n      let children = mml.childNodes as MMLNODE[];\n      let next = children.indexOf(mo) + 1;\n      let variantForm = NodeUtil.getProperty(mo, 'variantForm');\n      while (next < children.length && (m2 = children[next]) &&\n             NodeUtil.isType(m2, 'mo') &&\n             NodeUtil.getTexClass(m2) === TEXCLASS.REL) {\n        if (variantForm === NodeUtil.getProperty(m2, 'variantForm') &&\n            _compareExplicit(mo, m2)) {\n          // @test Shift Left, Less Equal,\n          //       Multirel Font X, Multirel Mathvariant X\n          NodeUtil.appendChildren(mo, NodeUtil.getChildren(m2));\n          // This treatment means we might loose some inheritance structure, but\n          // no properties.\n          _copyExplicit(['stretchy', 'rspace'], mo, m2);\n          for (const name of m2.getPropertyNames()) {\n            mo.setProperty(name, m2.getProperty(name));\n          }\n          children.splice(next, 1);\n          remove.push(m2);\n          m2.parent = null;\n          m2.setProperty('relationsCombined', true);\n        } else {\n          // @test Preset Rspace Lspace\n          if (mo.attributes.getExplicit('rspace') == null) {\n            // @test Mulitrel Mathvariant 3, Mulitrel Mathvariant 4\n            NodeUtil.setAttribute(mo, 'rspace', '0pt');\n          }\n          if (m2.attributes.getExplicit('lspace') == null) {\n            // @test Mulitrel Mathvariant 3, Mulitrel Mathvariant 4\n            NodeUtil.setAttribute(m2, 'lspace', '0pt');\n          }\n          break;\n        }\n      }\n      mo.attributes.setInherited('form', (mo as MmlMo).getForms()[0]);\n    }\n    arg.data.removeFromList('mo', remove);\n  };\n\n\n  /**\n   * Copies the specified explicit attributes from node2 to node1.\n   * @param {string[]} attrs List of explicit attribute names.\n   * @param {MmlNode} node1 The goal node.\n   * @param {MmlNode} node2 The source node.\n   */\n  let _copyExplicit = function(attrs: string[],\n                               node1: MmlNode, node2: MmlNode) {\n    let attr1 = node1.attributes;\n    let attr2 = node2.attributes;\n    attrs.forEach(x => {\n      let attr = attr2.getExplicit(x);\n      if (attr != null) {\n        // @test Infix Stretchy Right, Preset Lspace Rspace\n        attr1.set(x, attr);\n      }\n    });\n  };\n\n\n  /**\n   * Compares the explicit attributes of two nodes. Returns true if they\n   * coincide, with the following exceptions:\n   *   - lspace attribute of node1 is ignored.\n   *   - rspace attribute of node2 is ignored.\n   *   - stretchy=false attributes are ignored.\n   * @param {MmlNode} node1 The first node.\n   * @param {MmlNode} node2 Its next sibling.\n   */\n  let _compareExplicit = function(node1: MmlNode, node2: MmlNode) {\n    let filter = (attr: Attributes, space: string): string[] => {\n      let exp = attr.getExplicitNames();\n      return exp.filter(x => {\n        return x !== space &&\n          (x !== 'stretchy' ||\n           attr.getExplicit('stretchy'));\n      });\n    };\n    let attr1 = node1.attributes;\n    let attr2 = node2.attributes;\n    let exp1 = filter(attr1, 'lspace');\n    let exp2 = filter(attr2, 'rspace');\n    if (exp1.length !== exp2.length) {\n      return false;\n    }\n    for (let name of exp1) {\n      if (attr1.getExplicit(name) !== attr2.getExplicit(name)) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Cleans msubsup and munderover elements.\n   * @param {ParseOptions} options The parse options.\n   * @param {string} low String representing the lower part of the expression.\n   * @param {string} up String representing the upper part.\n   */\n  let _cleanSubSup = function(options: ParseOptions, low: string, up: string) {\n    const remove: MmlNode[] = [];\n    for (let mml of options.getList('m' + low + up) as any[]) {\n      const children = mml.childNodes;\n      if (children[mml[low]] && children[mml[up]]) {\n        continue;\n      }\n      const parent = mml.parent;\n      let newNode = (children[mml[low]] ?\n                 options.nodeFactory.create('node', 'm' + low, [children[mml.base], children[mml[low]]]) :\n                 options.nodeFactory.create('node', 'm' + up, [children[mml.base], children[mml[up]]]));\n      NodeUtil.copyAttributes(mml, newNode);\n      if (parent) {\n        parent.replaceChild(newNode, mml);\n      } else {\n        options.root = newNode;\n      }\n      remove.push(mml);\n    }\n    options.removeFromList('m' + low + up, remove);\n  };\n\n\n  /**\n   * Visitor that rewrites incomplete msubsup/munderover elements in the given\n   * node into corresponding msub/sup/under/over nodes.\n   * @param {MmlNode} math The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let cleanSubSup = function(arg: {math: any, data: ParseOptions}) {\n    let options = arg.data;\n    if (options.error) {\n      return;\n    }\n    _cleanSubSup(options, 'sub', 'sup');\n    _cleanSubSup(options, 'under', 'over');\n  };\n\n\n  /**\n   * Looks through the list of munderover elements for ones that have\n   * movablelimits and bases that are not mo's, and creates new msubsup\n   * elements to replace them if they aren't in displaystyle.\n   *\n   * @param {MmlNode} ath The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  let _moveLimits = function (options: ParseOptions, underover: string, subsup: string) {\n    const remove: MmlNode[] = [];\n    for (const mml of options.getList(underover)) {\n      if (mml.attributes.get('displaystyle')) {\n        continue;\n      }\n      const base = mml.childNodes[(mml as any).base] as MmlNode;\n      const mo = base.coreMO();\n      if (base.getProperty('movablelimits') && !mo.attributes.getExplicit('movablelimits')) {\n        let node = options.nodeFactory.create('node', subsup, mml.childNodes);\n        NodeUtil.copyAttributes(mml, node);\n        if (mml.parent) {\n          mml.parent.replaceChild(node, mml);\n        } else {\n          options.root = node;\n        }\n        remove.push(mml);\n      }\n    }\n    options.removeFromList(underover, remove);\n  };\n\n  /**\n   * Visitor that rewrites in-line munderover elements with movablelimits but bases\n   * that are not mo's into explicit msubsup elements.\n   *\n   * @param {ParseOptions} data  The parse options to use\n   */\n  export let moveLimits = function (arg: {data: ParseOptions}) {\n    const options = arg.data;\n    _moveLimits(options, 'munderover', 'msubsup');\n    _moveLimits(options, 'munder', 'msub');\n    _moveLimits(options, 'mover', 'msup');\n  };\n\n\n  /**\n   * Recursively sets the inherited attributes on the math tree.\n   * @param {MmlNode} math The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let setInherited = function(arg: {math: any, data: ParseOptions}) {\n    arg.data.root.setInheritedAttributes({}, arg.math['display'], 0, false);\n  };\n\n}\n\n\nexport default FilterUtil;\n"]},"metadata":{},"sourceType":"script"}