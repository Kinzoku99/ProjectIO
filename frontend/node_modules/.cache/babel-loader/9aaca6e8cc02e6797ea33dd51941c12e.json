{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lookup = exports.separateOptions = exports.selectOptionsFromKeys = exports.selectOptions = exports.userOptions = exports.defaultOptions = exports.insert = exports.copy = exports.keys = exports.makeArray = exports.expandable = exports.Expandable = exports.OPTIONS = exports.REMOVE = exports.APPEND = exports.isObject = void 0;\nvar OBJECT = {}.constructor;\n\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null && (obj.constructor === OBJECT || obj.constructor === Expandable);\n}\n\nexports.isObject = isObject;\nexports.APPEND = '[+]';\nexports.REMOVE = '[-]';\nexports.OPTIONS = {\n  invalidOption: 'warn',\n  optionError: function (message, _key) {\n    if (exports.OPTIONS.invalidOption === 'fatal') {\n      throw new Error(message);\n    }\n\n    console.warn('MathJax: ' + message);\n  }\n};\n\nvar Expandable = function () {\n  function Expandable() {}\n\n  return Expandable;\n}();\n\nexports.Expandable = Expandable;\n\nfunction expandable(def) {\n  return Object.assign(Object.create(Expandable.prototype), def);\n}\n\nexports.expandable = expandable;\n\nfunction makeArray(x) {\n  return Array.isArray(x) ? x : [x];\n}\n\nexports.makeArray = makeArray;\n\nfunction keys(def) {\n  if (!def) {\n    return [];\n  }\n\n  return Object.keys(def).concat(Object.getOwnPropertySymbols(def));\n}\n\nexports.keys = keys;\n\nfunction copy(def) {\n  var e_1, _a;\n\n  var props = {};\n\n  try {\n    for (var _b = __values(keys(def)), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var key = _c.value;\n      var prop = Object.getOwnPropertyDescriptor(def, key);\n      var value = prop.value;\n\n      if (Array.isArray(value)) {\n        prop.value = insert([], value, false);\n      } else if (isObject(value)) {\n        prop.value = copy(value);\n      }\n\n      if (prop.enumerable) {\n        props[key] = prop;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return Object.defineProperties(def.constructor === Expandable ? expandable({}) : {}, props);\n}\n\nexports.copy = copy;\n\nfunction insert(dst, src, warn) {\n  var e_2, _a;\n\n  if (warn === void 0) {\n    warn = true;\n  }\n\n  var _loop_1 = function (key) {\n    if (warn && dst[key] === undefined && dst.constructor !== Expandable) {\n      if (typeof key === 'symbol') {\n        key = key.toString();\n      }\n\n      exports.OPTIONS.optionError(\"Invalid option \\\"\" + key + \"\\\" (no default value).\", key);\n      return \"continue\";\n    }\n\n    var sval = src[key],\n        dval = dst[key];\n\n    if (isObject(sval) && dval !== null && (typeof dval === 'object' || typeof dval === 'function')) {\n      var ids = keys(sval);\n\n      if (Array.isArray(dval) && (ids.length === 1 && (ids[0] === exports.APPEND || ids[0] === exports.REMOVE) && Array.isArray(sval[ids[0]]) || ids.length === 2 && ids.sort().join(',') === exports.APPEND + ',' + exports.REMOVE && Array.isArray(sval[exports.APPEND]) && Array.isArray(sval[exports.REMOVE]))) {\n        if (sval[exports.REMOVE]) {\n          dval = dst[key] = dval.filter(function (x) {\n            return sval[exports.REMOVE].indexOf(x) < 0;\n          });\n        }\n\n        if (sval[exports.APPEND]) {\n          dst[key] = __spreadArray(__spreadArray([], __read(dval)), __read(sval[exports.APPEND]));\n        }\n      } else {\n        insert(dval, sval, warn);\n      }\n    } else if (Array.isArray(sval)) {\n      dst[key] = [];\n      insert(dst[key], sval, false);\n    } else if (isObject(sval)) {\n      dst[key] = copy(sval);\n    } else {\n      dst[key] = sval;\n    }\n  };\n\n  try {\n    for (var _b = __values(keys(src)), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var key = _c.value;\n\n      _loop_1(key);\n    }\n  } catch (e_2_1) {\n    e_2 = {\n      error: e_2_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_2) throw e_2.error;\n    }\n  }\n\n  return dst;\n}\n\nexports.insert = insert;\n\nfunction defaultOptions(options) {\n  var defs = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    defs[_i - 1] = arguments[_i];\n  }\n\n  defs.forEach(function (def) {\n    return insert(options, def, false);\n  });\n  return options;\n}\n\nexports.defaultOptions = defaultOptions;\n\nfunction userOptions(options) {\n  var defs = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    defs[_i - 1] = arguments[_i];\n  }\n\n  defs.forEach(function (def) {\n    return insert(options, def, true);\n  });\n  return options;\n}\n\nexports.userOptions = userOptions;\n\nfunction selectOptions(options) {\n  var e_3, _a;\n\n  var keys = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    keys[_i - 1] = arguments[_i];\n  }\n\n  var subset = {};\n\n  try {\n    for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n      var key = keys_1_1.value;\n\n      if (options.hasOwnProperty(key)) {\n        subset[key] = options[key];\n      }\n    }\n  } catch (e_3_1) {\n    e_3 = {\n      error: e_3_1\n    };\n  } finally {\n    try {\n      if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\n    } finally {\n      if (e_3) throw e_3.error;\n    }\n  }\n\n  return subset;\n}\n\nexports.selectOptions = selectOptions;\n\nfunction selectOptionsFromKeys(options, object) {\n  return selectOptions.apply(void 0, __spreadArray([options], __read(Object.keys(object))));\n}\n\nexports.selectOptionsFromKeys = selectOptionsFromKeys;\n\nfunction separateOptions(options) {\n  var e_4, _a, e_5, _b;\n\n  var objects = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    objects[_i - 1] = arguments[_i];\n  }\n\n  var results = [];\n\n  try {\n    for (var objects_1 = __values(objects), objects_1_1 = objects_1.next(); !objects_1_1.done; objects_1_1 = objects_1.next()) {\n      var object = objects_1_1.value;\n      var exists = {},\n          missing = {};\n\n      try {\n        for (var _c = (e_5 = void 0, __values(Object.keys(options || {}))), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var key = _d.value;\n          (object[key] === undefined ? missing : exists)[key] = options[key];\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n\n      results.push(exists);\n      options = missing;\n    }\n  } catch (e_4_1) {\n    e_4 = {\n      error: e_4_1\n    };\n  } finally {\n    try {\n      if (objects_1_1 && !objects_1_1.done && (_a = objects_1.return)) _a.call(objects_1);\n    } finally {\n      if (e_4) throw e_4.error;\n    }\n  }\n\n  results.unshift(options);\n  return results;\n}\n\nexports.separateOptions = separateOptions;\n\nfunction lookup(name, lookup, def) {\n  if (def === void 0) {\n    def = null;\n  }\n\n  return lookup.hasOwnProperty(name) ? lookup[name] : def;\n}\n\nexports.lookup = lookup;","map":{"version":3,"mappings":"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","names":["OBJECT","constructor","isObject","obj","Expandable","exports","invalidOption","optionError","message","_key","Error","console","warn","expandable","def","Object","assign","create","prototype","makeArray","x","Array","isArray","keys","concat","getOwnPropertySymbols","copy","props","_c","key","prop","getOwnPropertyDescriptor","value","insert","enumerable","defineProperties","dst","src","undefined","toString","sval","dval","ids","length","sort","join","filter","indexOf","__spreadArray","__read","defaultOptions","options","defs","forEach","userOptions","selectOptions","subset","keys_1_1","hasOwnProperty","selectOptionsFromKeys","object","separateOptions","objects","results","objects_1_1","exists","missing","_d","push","unshift","lookup","name"],"sources":["/home/kinzoku99/Desktop/ProjectIO/frontend/node_modules/mathjax-full/ts/util/Options.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements functions for handling option lists\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\n\n/*****************************************************************/\n/* tslint:disable-next-line:jsdoc-require */\nconst OBJECT = {}.constructor;\n\n/**\n *  Check if an object is an object literal (as opposed to an instance of a class)\n */\nexport function isObject(obj: any) {\n  return typeof obj === 'object' && obj !== null &&\n    (obj.constructor === OBJECT || obj.constructor === Expandable);\n}\n\n/*****************************************************************/\n/**\n * Generic list of options\n */\nexport type OptionList = {[name: string]: any};\n\n/*****************************************************************/\n/**\n *  Used to append an array to an array in default options\n *  E.g., an option of the form\n *\n *    {\n *      name: {[APPEND]: [1, 2, 3]}\n *    }\n *\n *  where 'name' is an array in the default options would end up with name having its\n *  original value with 1, 2, and 3 appended.\n */\nexport const APPEND = '[+]';\n\n/**\n *  Used to remove elements from an array in default options\n *  E.g., an option of the form\n *\n *    {\n *      name: {[REMOVE]: [2]}\n *    }\n *\n *  where 'name' is an array in the default options would end up with name having its\n *  original value but with any entry of 2 removed  So if the original value was [1, 2, 3, 2],\n *  then the final value will be [1, 3] instead.\n */\nexport const REMOVE = '[-]';\n\n\n/**\n *  Provides options for the option utlities.\n */\nexport const OPTIONS = {\n  invalidOption: 'warn' as ('fatal' | 'warn'),\n  /**\n   * Function to report messages for invalid options\n   *\n   * @param {string} message   The message for the invalid parameter.\n   * @param {string} key       The invalid key itself.\n   */\n  optionError: (message: string, _key: string) => {\n    if (OPTIONS.invalidOption === 'fatal') {\n      throw new Error(message);\n    }\n    console.warn('MathJax: ' + message);\n  }\n};\n\n\n/**\n * A Class to use for options that should not produce warnings if an undefined key is used\n */\nexport class Expandable {}\n\n/**\n * Produces an instance of Expandable with the given values (to be used in defining options\n * that can use keys that don't have default values).  E.g., default options of the form:\n *\n *  OPTIONS = {\n *     types: expandable({\n *       a: 1,\n *       b: 2\n *     })\n *  }\n *\n *  would allow user options of\n *\n *  {\n *     types: {\n *       c: 3\n *     }\n *  }\n *\n *  without reporting an error.\n */\nexport function expandable(def: OptionList) {\n  return Object.assign(Object.create(Expandable.prototype), def);\n}\n\n/*****************************************************************/\n/**\n *  Make sure an option is an Array\n */\nexport function makeArray(x: any): any[] {\n  return Array.isArray(x) ? x : [x];\n}\n\n/*****************************************************************/\n/**\n * Get all keys and symbols from an object\n *\n * @param {Optionlist} def        The object whose keys are to be returned\n * @return {(string | symbol)[]}  The list of keys for the object\n */\nexport function keys(def: OptionList): (string | symbol)[] {\n  if (!def) {\n    return [];\n  }\n  return (Object.keys(def) as (string | symbol)[]).concat(Object.getOwnPropertySymbols(def));\n}\n\n/*****************************************************************/\n/**\n * Make a deep copy of an object\n *\n * @param {OptionList} def  The object to be copied\n * @return {OptionList}     The copy of the object\n */\nexport function copy(def: OptionList): OptionList {\n  let props: OptionList = {};\n  for (const key of keys(def)) {\n    let prop = Object.getOwnPropertyDescriptor(def, key);\n    let value = prop.value;\n    if (Array.isArray(value)) {\n      prop.value = insert([], value, false);\n    } else if (isObject(value)) {\n      prop.value = copy(value);\n    }\n    if (prop.enumerable) {\n      props[key as string] = prop;\n    }\n  }\n  return Object.defineProperties(def.constructor === Expandable ? expandable({}) : {}, props);\n}\n\n/*****************************************************************/\n/**\n * Insert one object into another (with optional warnings about\n * keys that aren't in the original)\n *\n * @param {OptionList} dst  The option list to merge into\n * @param {OptionList} src  The options to be merged\n * @param {boolean} warn    True if a warning should be issued for a src option that isn't already in dst\n * @return {OptionList}     The modified destination option list (dst)\n */\nexport function insert(dst: OptionList, src: OptionList, warn: boolean = true): OptionList {\n  for (let key of keys(src) as string[]) {\n    //\n    // Check if the key is valid (i.e., is in the defaults or in an expandable block)\n    //\n    if (warn && dst[key] === undefined && dst.constructor !== Expandable) {\n      if (typeof key === 'symbol') {\n        key = (key as symbol).toString();\n      }\n      OPTIONS.optionError(`Invalid option \"${key}\" (no default value).`, key);\n      continue;\n    }\n    //\n    // Shorthands for the source and destination values\n    //\n    let sval = src[key], dval = dst[key];\n    //\n    // If the source is an object literal and the destination exists and is either an\n    //   object or a function (so can have properties added to it)...\n    //\n    if (isObject(sval) && dval !== null &&\n        (typeof dval === 'object' || typeof dval === 'function')) {\n      const ids = keys(sval);\n      //\n      // Check for APPEND or REMOVE objects:\n      //\n      if (\n        //\n        // If the destination value is an array...\n        //\n        Array.isArray(dval) &&\n          (\n            //\n            // If there is only one key and it is APPEND or REMOVE and the keys value is an array...\n            //\n            (ids.length === 1 && (ids[0] === APPEND || ids[0] === REMOVE) && Array.isArray(sval[ids[0]])) ||\n              //\n              // Or if there are two keys and they are APPEND and REMOVE and both keys' values\n              //   are arrays...\n              //\n              (ids.length === 2 && ids.sort().join(',') === APPEND + ',' + REMOVE &&\n               Array.isArray(sval[APPEND]) && Array.isArray(sval[REMOVE]))\n          )\n      ) {\n        //\n        // Then remove any values to be removed\n        //\n        if (sval[REMOVE]) {\n          dval = dst[key] = dval.filter(x => sval[REMOVE].indexOf(x) < 0);\n        }\n        //\n        // And append any values to be added (make a copy so as not to modify the original)\n        //\n        if (sval[APPEND]) {\n          dst[key] = [...dval, ...sval[APPEND]];\n        }\n      } else {\n        //\n        // Otherwise insert the values of the source object into the destination object\n        //\n        insert(dval, sval, warn);\n      }\n    } else if (Array.isArray(sval)) {\n      //\n      // If the source is an array, replace the destination with an empty array\n      //   and copy the source values into it.\n      //\n      dst[key] = [];\n      insert(dst[key], sval, false);\n    } else if (isObject(sval)) {\n      //\n      // If the source is an object literal, set the destination to a copy of it\n      //\n      dst[key] = copy(sval);\n    } else {\n      //\n      // Otherwise set the destination to the source value\n      //\n      dst[key] = sval;\n    }\n  }\n  return dst;\n}\n\n/*****************************************************************/\n/**\n * Merge options without warnings (so we can add new default values into an\n * existing default list)\n *\n * @param {OptionList} options  The option list to be merged into\n * @param {OptionList[]} defs   The option lists to merge into the first one\n * @return {OptionList}         The modified options list\n */\nexport function defaultOptions(options: OptionList, ...defs: OptionList[]): OptionList {\n  defs.forEach(def => insert(options, def, false));\n  return options;\n}\n\n/*****************************************************************/\n/**\n * Merge options with warnings about undefined ones (so we can merge\n * user options into the default list)\n *\n * @param {OptionList} options  The option list to be merged into\n * @param {OptionList[]} defs   The option lists to merge into the first one\n * @return {OptionList}         The modified options list\n */\nexport function userOptions(options: OptionList, ...defs: OptionList[]): OptionList {\n  defs.forEach(def => insert(options, def, true));\n  return options;\n}\n\n/*****************************************************************/\n/**\n * Select a subset of options by key name\n *\n * @param {OptionList} options  The option list from which option values will be taken\n * @param {string[]} keys       The names of the options to extract\n * @return {OptionList}         The option list consisting of only the ones whose keys were given\n */\nexport function selectOptions(options: OptionList, ...keys: string[]): OptionList {\n  let subset: OptionList = {};\n  for (const key of keys) {\n    if (options.hasOwnProperty(key)) {\n      subset[key] = options[key];\n    }\n  }\n  return subset;\n}\n\n/*****************************************************************/\n/**\n * Select a subset of options by keys from an object\n *\n * @param {OptionList} options  The option list from which the option values will be taken\n * @param {OptionList} object   The option list whose keys will be used to select the options\n * @return {OptionList}         The option list consisting of the option values from the first\n *                               list whose keys are those from the second list.\n */\nexport function selectOptionsFromKeys(options: OptionList, object: OptionList): OptionList {\n  return selectOptions(options, ...Object.keys(object));\n}\n\n/*****************************************************************/\n/**\n *  Separate options into sets: the ones having the same keys\n *  as the second object, the third object, etc, and the ones that don't.\n *  (Used to separate an option list into the options needed for several\n *   subobjects.)\n *\n * @param {OptionList} options    The option list to be split into parts\n * @param {OptionList[]} objects  The list of option lists whose keys are used to break up\n *                                 the original options into separate pieces.\n * @return {OptionList[]}         The option lists taken from the original based on the\n *                                 keys of the other objects.  The first one in the list\n *                                 consists of the values not appearing in any of the others\n *                                 (i.e., whose keys were not in any of the others).\n */\nexport function separateOptions(options: OptionList, ...objects: OptionList[]): OptionList[] {\n  let results: OptionList[] = [];\n  for (const object of objects) {\n    let exists: OptionList = {}, missing: OptionList = {};\n    for (const key of Object.keys(options || {})) {\n      (object[key] === undefined ? missing : exists)[key] = options[key];\n    }\n    results.push(exists);\n    options = missing;\n  }\n  results.unshift(options);\n  return results;\n}\n\n\n/*****************************************************************/\n/**\n *  Look up a value from object literal, being sure it is an\n *  actual property (not inherited), with a default if not found.\n *\n * @param {string} name         The name of the key to look up.\n * @param {OptionList} lookup   The list of options to check.\n * @param {any} def             The default value if the key isn't found.\n */\nexport function lookup(name: string, lookup: OptionList, def: any = null) {\n  return (lookup.hasOwnProperty(name) ? lookup[name] : def);\n}\n\n"]},"metadata":{},"sourceType":"script"}