'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var mathjax = require('mathjax-full/js/mathjax');
var tex$1 = require('mathjax-full/js/input/tex');
var mathml$1 = require('mathjax-full/js/input/mathml');
var svg$1 = require('mathjax-full/js/output/svg');
var browserAdaptor = require('mathjax-full/js/adaptors/browserAdaptor');
var html = require('mathjax-full/js/handlers/html');
var MathItem = require('mathjax-full/js/core/MathItem');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

// create and register adaptor bound to the real DOM
var adaptor = browserAdaptor.browserAdaptor();
html.RegisterHTMLHandler(adaptor);
//  Create input and output jax and a document using them on the content from the HTML file (see: https://github.com/mathjax/MathJax-demos-node/blob/master/direct/tex2svg)
var tex = new tex$1.TeX({ packages: ['base', 'ams'] });
var mathml = new mathml$1.MathML({});
var svg = new svg$1.SVG({ fontCache: 'none' });
var markErrors = [MathItem.STATE.TYPESET + 1, null, onError];
var tex_html = mathjax.mathjax.document('', {
    InputJax: tex,
    OutputJax: svg,
    renderActions: {
        markErrors: markErrors,
    }
});
var mathml_html = mathjax.mathjax.document('', {
    InputJax: mathml,
    OutputJax: svg,
    renderActions: {
        markErrors: markErrors,
    }
});
function onError(math) {
    var root = math.root, typesetRoot = math.typesetRoot;
    if (root.toString().substr(0, 14) === 'math([merror([') {
        var merror = root.childNodes[0].childNodes[0];
        var text = merror.attributes.get('data-mjx-error') || merror.childNodes[0].childNodes[0].getText();
        adaptor.setAttribute(typesetRoot, 'data-mjx-error', text);
    }
}
function updateCSS(nodeID, text) {
    var styleNode = document.getElementById(nodeID);
    if (styleNode === null) {
        styleNode = document.createElement('style');
        styleNode.setAttribute('id', nodeID);
        document.head.appendChild(styleNode);
    }
    styleNode.innerHTML = text;
}
var CancelationException = /** @class */ (function () {
    function CancelationException() {
    }
    return CancelationException;
}());
function convertPromise(srcSpec, node, display, settings) {
    var src = srcSpec.src, lang = srcSpec.lang;
    if (!node)
        throw new Error();
    var html = tex_html;
    if (lang == 'MathML')
        html = mathml_html;
    var math = src.trim();
    // const metrics = svg.getMetricsFor(node, display);
    var canceled = false;
    var cancel = function () { return canceled = true; };
    var res = mathjax.mathjax.handleRetriesFor(function () {
        if (canceled) {
            throw new CancelationException();
        }
        var dom = html.convert(math, __assign({ display: display }, settings
        // ...metrics
        ));
        return dom;
    }).then(function (dom) {
        // do stuff with dom
        html.updateDocument();
        updateCSS('MATHJAX-SVG-STYLESHEET', svg.cssStyles.cssText);
        var err = adaptor.getAttribute(dom, 'data-mjx-error');
        if (err) {
            throw err;
        }
        return adaptor.outerHTML(dom);
    }).catch(function (err) {
        if (!(err instanceof CancelationException)) {
            throw err;
        }
        else {
            console.log('cancelled render!');
        }
    });
    return { promise: res.then(function (v) { return v ? v : ""; }), cancel: cancel };
}

// TODO import config props from mathjax-full
var defaultProps = {
    display: true,
    onError: null,
    onSuccess: null,
    settings: {}
};
var MathComponent = /** @class */ (function (_super) {
    __extends(MathComponent, _super);
    function MathComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.rootDivRef = React.createRef(); // setup root references
        _this.rootSpanRef = React.createRef();
        _this.state = {
            renderSrc: { src: "", lang: "TeX" },
            renderPromise: null,
            renderResult: "",
            src: {
                src: "",
                lang: "TeX"
            },
            cancel: function () { return null; }
        };
        return _this;
    }
    MathComponent.prototype.getRootRef = function () {
        return this.props.display ? this.rootDivRef : this.rootSpanRef;
    };
    MathComponent.parseProps = function (props) {
        // if the prop is present, then it is the ONLY source specified
        // due to XOR type def
        if ("mathml" in props) {
            return {
                src: props.mathml,
                lang: 'MathML'
            };
        }
        else if ("tex" in props) {
            return {
                src: props.tex,
                lang: 'TeX'
            };
        }
        // UNREACHABLE
        return { src: '', lang: 'TeX' };
    };
    MathComponent.getDerivedStateFromProps = function (props, state) {
        var src = MathComponent.parseProps(props);
        return __assign({}, state, { src: src });
    };
    MathComponent.prototype.componentDidMount = function () {
        this._sendRender();
    };
    MathComponent.prototype.componentDidUpdate = function () {
        this._sendRender();
    };
    MathComponent.prototype._sendRender = function () {
        var _this = this;
        var node = this.getRootRef().current;
        var _a = this.state, src = _a.src, renderSrc = _a.renderSrc;
        if (node && !(src.src == renderSrc.src && src.lang == renderSrc.lang)) {
            this.state.cancel();
            var _b = convertPromise(src, node, this.props.display, this.props.settings), promise = _b.promise, cancel = _b.cancel;
            var renderPromise_1 = promise.then(function (htmlStr) {
                // check if promise is correct (ie. most recent)
                if (renderPromise_1 == _this.state.renderPromise) {
                    _this.setState({ renderResult: htmlStr });
                }
                else {
                    console.log('promise expired...');
                }
            });
            if (this.props.onSuccess) {
                renderPromise_1 = renderPromise_1.then(this.props.onSuccess);
            }
            if (this.props.onError) {
                renderPromise_1 = renderPromise_1.catch(this.props.onError);
            }
            this.setState({ renderPromise: renderPromise_1, renderSrc: src, cancel: cancel });
        }
    };
    MathComponent.prototype.render = function () {
        var renderedSVG = this.state.renderResult;
        /*
        let node = this.rootRef.current;
        let src = this.parseProps();
        if (node) {
          renderedSVG = convert(src, node, this.props.display!);
        } else {
          console.log('Didn\'t work!', this.rootRef);
        }
        */
        return this.props.display ? (React.createElement("div", { ref: this.rootDivRef, dangerouslySetInnerHTML: { __html: renderedSVG } })) : (React.createElement("span", { ref: this.rootSpanRef, dangerouslySetInnerHTML: { __html: renderedSVG } }));
    };
    MathComponent.defaultProps = defaultProps; // bind default props
    return MathComponent;
}(React.Component));

exports.MathComponent = MathComponent;
//# sourceMappingURL=index.js.map
